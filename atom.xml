<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dawnki&#39;s Blog</title>
  
  <subtitle>From Apprentice To Artisan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dawnki.github.io/"/>
  <updated>2018-06-09T18:24:53.700Z</updated>
  <id>https://dawnki.github.io/</id>
  
  <author>
    <name>Dawnki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python基础学习笔记</title>
    <link href="https://dawnki.github.io/2018/06/10/python%E7%AC%94%E8%AE%B0/"/>
    <id>https://dawnki.github.io/2018/06/10/python笔记/</id>
    <published>2018-06-09T18:18:00.000Z</published>
    <updated>2018-06-09T18:24:53.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python笔记"><a href="#Python笔记" class="headerlink" title="Python笔记"></a>Python笔记</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>Python 2.7</p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure><p>判断条件为真则继续循环</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> L:</div><div class="line">  <span class="keyword">print</span> L[i]</div></pre></td></tr></table></figure><p>可遍历序列结构的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">3</span>):  <span class="comment">#range能生成等差数列，这种方式可转换成C语言的for循环</span></div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> x&lt;<span class="number">5</span>:</div><div class="line">  <span class="keyword">pass</span></div><div class="line"><span class="keyword">elif</span> x&lt;=<span class="number">10</span>:</div><div class="line">  <span class="keyword">pass</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure><p>if常见三段式</p><h3 id="else的特别用法"><a href="#else的特别用法" class="headerlink" title="else的特别用法"></a>else的特别用法</h3><p>当循环中存在break时，可以配合else使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> x&gt;<span class="number">5</span>:</div><div class="line">  <span class="keyword">if</span> x&lt;<span class="number">7</span>:</div><div class="line">    <span class="keyword">break</span></div><div class="line">  x*=<span class="number">2</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure></p><p>当循环的条件为假并且非break打破循环条件时，就会执行else语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">  <span class="keyword">raise</span> MyError</div><div class="line"><span class="keyword">except</span> NameError:</div><div class="line">  <span class="keyword">pass</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure><p>如上，当try块的语句执行完并且没有异常时，就会执行else中的语句</p><h2 id="有用的杂项"><a href="#有用的杂项" class="headerlink" title="有用的杂项"></a>有用的杂项</h2><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>生成等差数列的列表<br>用法:range(起点,不包含的终点,步长)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">range(<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>) <span class="comment">#[1,3,5]</span></div><div class="line">range(<span class="number">1</span>,<span class="number">4</span>) <span class="comment">#[1,2,3]</span></div></pre></td></tr></table></figure><h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>代表什么都不做,忽略至少一条语句的要求<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> x&gt;<span class="number">5</span>:</div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure></p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>python的逻辑运算使用”or”,”and”,”not”关键字,其中or和and都是短路操作</p><h3 id="is-in"><a href="#is-in" class="headerlink" title="is,in"></a>is,in</h3><p>is,is not用于判断是否为相同对象。in,not in用于判断一个值是否存在于序列或集合中</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"><span class="keyword">print</span> alist[:]    <span class="comment"># 从头到尾输出</span></div><div class="line"><span class="keyword">print</span> alist[<span class="number">1</span>:]   <span class="comment"># 从index为1开始到末尾输出</span></div><div class="line"><span class="keyword">print</span> alist[<span class="number">2</span>:<span class="number">4</span>]  <span class="comment"># 从index为2开始到index为4输出，但不包括4</span></div><div class="line"><span class="keyword">print</span> alist[<span class="number">-1</span>]   <span class="comment"># 输出倒数列表的倒数第一个</span></div><div class="line"><span class="keyword">print</span> alist[<span class="number">-3</span>:<span class="number">-1</span>] <span class="comment"># 输出倒数第3到倒数第1(不包括倒数第一)</span></div></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(value1, value2=<span class="number">3</span>)</span>:</span></div><div class="line">  <span class="keyword">return</span> value1*value2  <span class="comment">#可以没有return</span></div></pre></td></tr></table></figure><p>当函数给出默认值时可以不传对应的参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f = func</div><div class="line">f(<span class="number">1</span>,<span class="number">2</span>)</div></pre></td></tr></table></figure><p>函数名还可以赋值给变量</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f = <span class="keyword">lambda</span> x1,x2: x1*x2</div><div class="line">f(<span class="number">1</span>,<span class="number">2</span>)</div></pre></td></tr></table></figure><p>常用于简单的函数</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>用”[]”表示<br>常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>list.append(x)</td><td>将x元素添加到list末尾</td></tr><tr><td>list.extend(L)</td><td>将列表L加入到list末尾</td></tr><tr><td>list.insert(index,x)</td><td>在list的index索引之前插入x</td></tr><tr><td>list.remove(x)</td><td>删除列表中第一个值为x的元素，如果没有这样的元素会报错</td></tr><tr><td>list.index(x)</td><td>返回第一个元素为x的的索引，没有的话会报错</td></tr><tr><td>list.pop(index)</td><td>index参数可选,删除指定位置并且返回该元素,index不选默认删除最后一个</td></tr><tr><td>list.count(x)</td><td>返回列表中x出现的次数</td></tr><tr><td>list.reverse()</td><td>原地反转列表中的元素</td></tr><tr><td>list.sort(cmp=None,key=None,reverse=False)</td><td>列表排序</td></tr><tr><td>filter(function,List)</td><td>eg. filter(lanmbda x:x%2==0,range(0,9)),迭代List每一项，根据function判断是否过滤</td></tr><tr><td>map(function,List)</td><td>List的每一项都调用function(item)并返回结果</td></tr><tr><td>reduce(function,List,value)</td><td>List的前两项放入function(x,y)中,返回结果后和下一个元素继续调用,value为初始值可选,以免列表为空时返回异常,一般初始值设置0</td></tr></tbody></table><p>列表推导式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="comment"># [0,1,4,9,16,25,36,49,64,81]</span></div></pre></td></tr></table></figure></p><p>del语句可以用于从列表中删除切片或者清除整个列表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">del</span> a[<span class="number">2</span>:<span class="number">4</span>]</div><div class="line"><span class="keyword">del</span> a[<span class="number">2</span>]</div><div class="line"><span class="keyword">del</span> a[:]  <span class="comment"># 清除列表</span></div><div class="line"><span class="keyword">del</span> a     <span class="comment">#删除a这个变量</span></div></pre></td></tr></table></figure></p><h3 id="Tuples-元组"><a href="#Tuples-元组" class="headerlink" title="Tuples(元组)"></a>Tuples(元组)</h3><p>用”()”表示</p><p>可变类型与不可变类型:</p><table><thead><tr><th>是否可变</th><th>具体</th></tr></thead><tbody><tr><td>可变类型</td><td>列表,字典</td></tr><tr><td>不可变类型</td><td>元组,数字,字符串</td></tr></tbody></table><p>元组 <strong>不能</strong> 改变(删除)组内元素值，元组可以拆分赋值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">t1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># t1 = 1,2,3  亦可</span></div><div class="line"><span class="comment"># t1[0] = 2  # 错误</span></div><div class="line">x,y,z = t1   <span class="comment"># 此时 x=1 y=2 z=3</span></div></pre></td></tr></table></figure></p><p>元组常用操作:</p><table><thead><tr><th style="text-align:center">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">t.count(x)</td><td>计算x在元组内出现的次数</td></tr><tr><td style="text-align:center">t.index(‘a’,1,4)</td><td>在索引1,3内寻找元素a，并返回其索引,后两个参数可选</td></tr><tr><td style="text-align:center">len(t)</td><td>计算t的长度</td></tr></tbody></table><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><p>用”{}”表示,不过打印的时候会变成”set([k,w,x])”<br>无顺序且不重复,常用于去重<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</div></pre></td></tr></table></figure></p><p>常用操作:</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>s.add(x)</td><td>将x元素添加到集合中</td></tr><tr><td>s.remove(x)</td><td>在集合中删除x元素</td></tr><tr><td>s.update([1,2,3])</td><td>用于更新多项</td></tr><tr><td>x in s</td><td>判断x元素是否在集合内,反操作not in</td></tr><tr><td>s.issubset(t)</td><td>判断s是否是t的子集,反操作issuperset</td></tr><tr><td>s.union(t)</td><td>将s与t合并</td></tr><tr><td>s.intersection(t)</td><td>s与t的交集</td></tr><tr><td>s.difference(t)</td><td>s-t</td></tr><tr><td>s.copy()</td><td>返回s的浅克隆</td></tr></tbody></table><p>集合推导式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'xdsfsd'</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'abc'</span>&#125;</div></pre></td></tr></table></figure></p><h3 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary(字典)"></a>Dictionary(字典)</h3><p>用{key1:value1,key2:value2}表示<br>实质为键值对,key为不可变类型,可以用于不包含对象的元组表示<br>常用操作:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">di = &#123;<span class="string">"name1"</span>:<span class="number">1</span> , <span class="string">"name2"</span>:<span class="number">2</span>&#125;</div><div class="line">di[<span class="string">"name3"</span>] = <span class="number">3</span></div><div class="line">dict([(<span class="string">'kkk'</span>,<span class="number">213</span>),(<span class="string">'dff'</span>,<span class="number">324</span>)])  <span class="comment">#函数方法创建字典</span></div><div class="line">di.keys()  <span class="comment">#获取字典键的集合</span></div></pre></td></tr></table></figure></p><h3 id="遍历技巧"><a href="#遍历技巧" class="headerlink" title="遍历技巧"></a>遍历技巧</h3><p>对于序列类型(List,String,Tuples,range)遍历方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate([<span class="string">'abc'</span>,<span class="string">'cba'</span>]):</div><div class="line">  <span class="keyword">print</span> index , value</div></pre></td></tr></table></figure></p><p>对于集合:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;:</div><div class="line">  <span class="keyword">print</span> item</div></pre></td></tr></table></figure></p><p>对于字典:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> &#123;<span class="string">'aaa'</span>:<span class="number">1</span>&#125;.iteritems():</div><div class="line">  <span class="keyword">print</span> k,v</div></pre></td></tr></table></figure></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>在python中一个python文件可以看作是一个模块，而文件夹可以看作是一个包。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 假设存在同目录下 test.py</span></div><div class="line"><span class="keyword">import</span> test</div><div class="line">test.xx()  <span class="comment">#调用test模块定义的函数</span></div><div class="line"><span class="comment"># import的变体</span></div><div class="line"><span class="keyword">from</span> test <span class="keyword">import</span> func</div><div class="line">func()</div><div class="line"><span class="keyword">from</span> A <span class="keyword">import</span> B  <span class="comment">#这里的B可以是函数,类,变量</span></div></pre></td></tr></table></figure></p><h3 id="执行模块"><a href="#执行模块" class="headerlink" title="执行模块"></a>执行模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">  <span class="keyword">import</span> sys</div><div class="line">  func(sys.argv[<span class="number">1</span>])</div></pre></td></tr></table></figure><p>此时该py文件可以作为执行脚本使用,其中argv[0]为脚本的名字,argv[1]为往后给脚本的传值</p><h3 id="导入其他文件夹里的模块"><a href="#导入其他文件夹里的模块" class="headerlink" title="导入其他文件夹里的模块"></a>导入其他文件夹里的模块</h3><p>第一种方法是在其他文件夹内创建”<strong>init</strong>.py”文件,使该文件夹成一个包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在创建的__init__.py中可以设置__all__变量</span></div><div class="line">__all__ = [<span class="string">'xxxxxMod'</span>,<span class="string">'xxMod'</span>]  <span class="comment"># 此时当其他模块使用from xx import * 引入该模块时才会生效</span></div></pre></td></tr></table></figure><p>第二种方法可以利用sys.path<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">sys.path.append(<span class="string">'./xxx'</span>)</div></pre></td></tr></table></figure></p><h2 id="输入输出相关"><a href="#输入输出相关" class="headerlink" title="输入输出相关"></a>输入输出相关</h2><h3 id="输出方式"><a href="#输出方式" class="headerlink" title="输出方式"></a>输出方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">"xxx"</span></div><div class="line">sys.stdout.write(<span class="string">'xxxx'</span>)</div></pre></td></tr></table></figure><h3 id="将其他类型转换为字符串"><a href="#将其他类型转换为字符串" class="headerlink" title="将其他类型转换为字符串"></a>将其他类型转换为字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str(<span class="number">12312.55</span>)</div><div class="line">repr(<span class="number">255.332131</span>)</div></pre></td></tr></table></figure><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"test:&#123;0&#125;,&#123;text&#125;"</span>.format(<span class="string">"content"</span>,text=<span class="string">"text"</span>)</div><div class="line"><span class="string">"float:&#123;0:.3f&#125;"</span>.format(<span class="number">0.1</span>)  <span class="comment"># 如果有精度需求的话</span></div></pre></td></tr></table></figure><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sys.stdin.readline().strip(<span class="string">'\n'</span>)  <span class="comment"># strip函数用于去除头尾的字符</span></div></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">f = open(filename,mod)  <span class="comment"># mod 可选w,r,a</span></div><div class="line">f.write(xxx)  <span class="comment"># 写文件</span></div><div class="line">f.readline()  <span class="comment"># 读文件</span></div><div class="line">f.close()     <span class="comment"># 关文件</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'filename.txt'</span>,<span class="string">'a'</span>) <span class="keyword">as</span> f:   <span class="comment"># with语句可以在使用完文件时关闭</span></div><div class="line">  f.read()</div></pre></td></tr></table></figure><h3 id="json操作"><a href="#json操作" class="headerlink" title="json操作"></a>json操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line">str = json.dumps(&#123;<span class="string">"key1"</span>:<span class="number">1</span>&#125;)  <span class="comment"># 内置类型转json字符串</span></div><div class="line">di  = json.loads(str)         <span class="comment"># json字符串转内置类型</span></div></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">  <span class="keyword">raise</span> NameError(<span class="string">'abc'</span>,<span class="string">'bcd'</span>)</div><div class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</div><div class="line">  <span class="keyword">print</span> e.args</div><div class="line"><span class="keyword">except</span> (xxError,xxxError):</div><div class="line">  <span class="keyword">pass</span></div><div class="line"><span class="keyword">else</span>:      <span class="comment"># 在try语句中灭有抛出异常后则执行else操作</span></div><div class="line">  <span class="keyword">pass</span></div><div class="line"><span class="keyword">finally</span>:   <span class="comment"># finally语句总会执行</span></div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure><h3 id="被捕获的异常重新抛出"><a href="#被捕获的异常重新抛出" class="headerlink" title="被捕获的异常重新抛出"></a>被捕获的异常重新抛出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">  <span class="keyword">raise</span> MyError()</div><div class="line"><span class="keyword">except</span> MyError:</div><div class="line">  <span class="keyword">raise</span></div></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义的异常只需直接或间接继承Exception即可:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></div><div class="line">    self.value = value</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> repr(self.value)</div></pre></td></tr></table></figure></p><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><table><thead><tr><th style="text-align:center">异常名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">AssertionError</td><td>assert（断言）语句失败</td></tr><tr><td style="text-align:center">AttributeError</td><td>试图访问一个对象没有的属性</td></tr><tr><td style="text-align:center">IOError</td><td>输入/输出异常,文件无法打开等</td></tr><tr><td style="text-align:center">ImportError</td><td>无法引入模块或者包,导入路径可能出现问题</td></tr><tr><td style="text-align:center">IndentationError</td><td>语法错误,缩进问题</td></tr><tr><td style="text-align:center">IndexError</td><td>下标越界</td></tr><tr><td style="text-align:center">KeyError</td><td>试图访问字典里不存在的键</td></tr><tr><td style="text-align:center">KerboardInterrupt</td><td>键盘中断</td></tr><tr><td style="text-align:center">NameError</td><td>使用一个还未被赋值予对象的变量</td></tr><tr><td style="text-align:center">SyntaxError</td><td>Python代码非法</td></tr><tr><td style="text-align:center">TypeError</td><td>传入对象类型与要求的不符</td></tr><tr><td style="text-align:center">UnboundLocalError</td><td>全局变量与局部变量同名，并且局部变量还没赋值</td></tr><tr><td style="text-align:center">ValueError</td><td>传入一个调用者不期望的值，即使值的类型是正确的</td></tr></tbody></table><p>针对UnboundLocalError,全局变量在内部的作用域是 <strong>只读的</strong> ，若进行赋值操作的话，解析器会认为在局部创建了同名的局部变量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">value = <span class="number">10</span>    <span class="comment">#全局变量</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">  <span class="keyword">print</span> value <span class="comment"># 此时局部还没有value变量,因此输出全局的value变量</span></div><div class="line">  value = <span class="number">20</span>  <span class="comment"># 创建了"value"同名局部变量</span></div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">value = <span class="number">10</span></div><div class="line"><span class="comment"># 以下会引发UnboundLocalError错误:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">  value = value + <span class="number">10</span></div><div class="line"></div><div class="line"><span class="comment"># 若想在内部作用域改变全局变量:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></div><div class="line">  <span class="keyword">global</span> value</div><div class="line">  value = value + <span class="number">10</span></div></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></div><div class="line">  data = <span class="number">1</span>                     <span class="comment"># 类变量,所有实例都共享</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span>     <span class="comment"># 构造函数</span></div><div class="line">    self.name = name           <span class="comment"># 实例变量,实例间不共享</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span>              <span class="comment"># 成员方法,因语法需要self必加,调用时无需关注self</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="meta">  @classmethod</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(cls)</span>:</span>                <span class="comment"># 类方法,因语法需要cls必加,调用时无需关注cls</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">obj = Myclass(<span class="number">1</span>)               <span class="comment"># 实例化</span></div><div class="line">obj.func()</div></pre></td></tr></table></figure><p>若成员变量与成员方法同名时,会覆盖成员方法</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 如果与父类在同一个全局域</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(FatherClass)</span>:</span></div><div class="line">  <span class="keyword">pass</span></div><div class="line"><span class="comment"># 如果与父类不在同个全局域</span></div><div class="line"><span class="keyword">import</span> OtherMod</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(OtherMod.Father)</span>:</span></div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure><p>子类可以重写父类方法,只需同名覆盖即可</p><p>继承相关的方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>isinstance(obj,class)</td><td>检查obj是不是class的实例</td></tr><tr><td>issubclass(SonClass,FatherClass)</td><td>判断是否是子类</td></tr></tbody></table><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span><span class="params">(F1,F2,F3)</span>:</span></div><div class="line">  <span class="keyword">pass</span></div></pre></td></tr></table></figure><p>对于调用父类成员,按照顺序先搜索F1,再搜索F2</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">    self.__age = <span class="number">10</span>      <span class="comment"># 私有实例成员变量</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__func</span><span class="params">(self)</span>:</span>      <span class="comment"># 私有成员方法</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="comment"># obj.__func()           # 不能成功调用</span></div><div class="line">obj._A__func()           <span class="comment"># 可以成功调用</span></div></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>若类实现了<strong>iter</strong>和<strong>next</strong>方法,则可以使用迭代器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span>:</span></div><div class="line">    <span class="string">"""Iterator for looping over a sequence backwards."""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.index = len(data)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</div><div class="line">            <span class="keyword">raise</span> StopIteration</div><div class="line">        self.index = self.index - <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> self.data[self.index]</div><div class="line"></div><div class="line">rev = Reverse(<span class="string">'test'</span>)</div><div class="line">it = iter(rev)</div><div class="line">it.next() <span class="comment"># 若下一个元素为空时则抛出StopIteration异常</span></div></pre></td></tr></table></figure></p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>带有yield的函数都是生成器.<br>yield与return一样,可以返回一个值,不过当返回了一个值后,会接着执行yield下一行的语句.<br>生成器也是可以迭代的,常用的就是循环里面使用yield,这样可以节省内存.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(data)</span>:</span></div><div class="line">  <span class="keyword">for</span> index <span class="keyword">in</span> range(len(data)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</div><div class="line">    <span class="keyword">yield</span> data[index]</div></pre></td></tr></table></figure></p><h2 id="常用的标准库"><a href="#常用的标准库" class="headerlink" title="常用的标准库"></a>常用的标准库</h2><table><thead><tr><th>模块名</th><th>描述</th></tr></thead><tbody><tr><td>os模块</td><td>可以与操作系统交互的模块,如执行系统命令</td></tr><tr><td>glob模块</td><td>通配符搜索指定路径的文件 glob.glob(pathname)</td></tr><tr><td>sys模块</td><td>常用于与命令行执行脚本时,获取命令行参数,标准输入输出错误输出. sys.exit()/sys.stderr.write()</td></tr><tr><td>re模块</td><td>正则表达式匹配字符串</td></tr><tr><td>math模块</td><td>提供数学运算</td></tr><tr><td>random模块</td><td>提供随机选择</td></tr><tr><td>urllib2,smtplib模块</td><td>访问网络和发送邮件</td></tr><tr><td>datetime模块</td><td>处理日期时间</td></tr><tr><td>zlib模块</td><td>数据压缩</td></tr><tr><td>threading模块</td><td>多线程相关</td></tr><tr><td>logging模块</td><td>日志系统</td></tr><tr><td>decimal模块</td><td>十进制浮点数,用于财务等精度需求</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python笔记&quot;&gt;&lt;a href=&quot;#Python笔记&quot; class=&quot;headerlink&quot; title=&quot;Python笔记&quot;&gt;&lt;/a&gt;Python笔记&lt;/h1&gt;&lt;h2 id=&quot;版本&quot;&gt;&lt;a href=&quot;#版本&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Python" scheme="https://dawnki.github.io/categories/Python/"/>
    
    
      <category term="Python基础" scheme="https://dawnki.github.io/tags/Python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>星期压缩</title>
    <link href="https://dawnki.github.io/2018/03/28/%E6%98%9F%E6%9C%9F%E5%8E%8B%E7%BC%A9/"/>
    <id>https://dawnki.github.io/2018/03/28/星期压缩/</id>
    <published>2018-03-28T07:32:31.000Z</published>
    <updated>2018-03-28T07:44:33.708Z</updated>
    
    <content type="html"><![CDATA[<p>百词斩的第二道编程题，题目不难，事后码出来了，留个档。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h3><p>给定一组1~7组成(包含1和7)的有序且非重复数字数组, 每个数字的字面值n表示一周里面的第n天, 要求按照如下规则压缩后, 输出压缩以后的描述:</p><p>1) 对于三个及三个以上的连续数字, 需要压缩成”起始-结束”的格式;</p><p>2) 对于三个以下的连续或不连续数字, 不需要压缩, 按照原样输出;</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入:"></a>输入:</h3><p>第一行输入n，为数组的长度，比如5天的话，n=5，接下几行为具体的星期</p><p>如：</p><p>3   (3天)<br>1   (星期一)<br>2   (星期二)<br>4   (星期四)</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>压缩后的数字序列，序列的每一段之间使用英文逗号分隔。</p><p>如输入：</p><p>5<br>1<br>2<br>4<br>5<br>6</p><p>则输出：</p><p>1，2，4-6</p><h3 id="具体Java代码实现"><a href="#具体Java代码实现" class="headerlink" title="具体Java代码实现:"></a>具体Java代码实现:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> n = in.nextInt();</div><div class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            array[i] = in.nextInt();</div><div class="line">        &#125;</div><div class="line">        check(array);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="comment">//记录连续数的开头值</span></div><div class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</div><div class="line">        <span class="comment">//标记当前数是否与前一个连续</span></div><div class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line">        <span class="comment">//连续数的个数 题目要求超过3个才用 "-" 连接</span></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="comment">//记录结果</span></div><div class="line">        String result = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="comment">//遍历到最后一个数的情况</span></div><div class="line">            <span class="keyword">if</span> (i == array.length - <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;   <span class="comment">//与前面的数不连续</span></div><div class="line">                    result += array[i];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;   <span class="comment">//与前面的数连续</span></div><div class="line">                    <span class="keyword">if</span> (count &gt;= <span class="number">2</span>) &#123;   <span class="comment">//超过3个连续数 用 - 连接</span></div><div class="line">                        result += min + <span class="string">"-"</span> + array[i];</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        result += min + <span class="string">","</span> + array[i];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//非最后一个数</span></div><div class="line">            <span class="keyword">if</span> (array[i] + <span class="number">1</span> != array[i + <span class="number">1</span>]) &#123;</div><div class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;  <span class="comment">//当前数前后都不连续</span></div><div class="line">                    result += array[i] + <span class="string">","</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//当前数与前一个连续但与后一个不连续的情况</span></div><div class="line">                    <span class="keyword">if</span> (count &gt;= <span class="number">2</span>) &#123;</div><div class="line">                        result += min + <span class="string">"-"</span> + array[i] + <span class="string">","</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        result += min + <span class="string">","</span> + array[i] + <span class="string">","</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//重置计算</span></div><div class="line">                    min = <span class="number">0</span>;</div><div class="line">                    count = <span class="number">0</span>;</div><div class="line">                    flag = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;  <span class="comment">//当前数与前一个不连续与后一个连续</span></div><div class="line">                    min = array[i];</div><div class="line">                    count = <span class="number">1</span>;</div><div class="line">                    flag = <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;   <span class="comment">//当前数前后都连续</span></div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;百词斩的第二道编程题，题目不难，事后码出来了，留个档。&lt;/p&gt;
&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目:&quot;&gt;&lt;/a&gt;题目:&lt;/h3&gt;&lt;p&gt;给定一组1~7组成(包含1和7)的有序且非重复数字数组, 每个数字
      
    
    </summary>
    
      <category term="算法" scheme="https://dawnki.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://dawnki.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程题" scheme="https://dawnki.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>docker实践</title>
    <link href="https://dawnki.github.io/2017/10/09/docker%E5%AE%9E%E8%B7%B5/"/>
    <id>https://dawnki.github.io/2017/10/09/docker实践/</id>
    <published>2017-10-09T05:20:45.000Z</published>
    <updated>2018-03-28T08:38:16.019Z</updated>
    
    <content type="html"><![CDATA[<p>最近忙于工作，荒废了博客，在此反省一波～～好了，今天聊聊docker。docker作为一种快速部署生产环境的工具，利用了其自动化的优点，减少在部署中人为繁琐操作，从而提高了部署环境的速度以及准确度，在部署服务器集群中尤为便利，今天就简单入门一下docker吧！</p><h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><p>  入门Docker的初心者来说肯定要面对这三个名词，镜像(Image)，容器(Container)，仓库(Repository)。</p><p>  镜像就好比我们装系统时的镜像，包含着原始系统，镜像一般要求比较干净，比如一个nginx镜像，一个php-fpm容器这样子，负责不同共功能的要将镜像划分开。容器则是我们实际的操作环境，容器是基于镜像构建，容器是镜像的示例，就如对象是类的实例一样。而仓库的话是用来存放镜像的，仓库有分私人仓库与公有仓库，公有仓库中有许多官方镜像，比如redis，nginx等等。</p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="镜像类-Image"><a href="#镜像类-Image" class="headerlink" title="镜像类 Image"></a>镜像类 Image</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull &lt;image&gt;</div></pre></td></tr></table></figure><p>用于从网络拉取镜像，比如想要拉取nginx镜像时，就打docker pull nginx，默认拉取最新版本，如需拉取其他版本，可使用docker pull nginx:xxxx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search 关键字</div></pre></td></tr></table></figure><p>去网络仓库中查找镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images</div></pre></td></tr></table></figure><p>用于列出本地已拉取的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker history 仓库:标签</div></pre></td></tr></table></figure><p>显示某个仓库对于标签镜像的历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi 仓库:标签</div></pre></td></tr></table></figure><p>删除本地指定仓库标签的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</div></pre></td></tr></table></figure><p>以某个镜像按照设置创建并运行一个容器</p><p>eg.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>将nginx镜像的一个容器起名为webserver，并把本机9999端口映射到docker容器的80端口</div><div class="line">docker run --name webserver -d -p 9999:80 nginx</div></pre></td></tr></table></figure><h3 id="容器类-Container"><a href="#容器类-Container" class="headerlink" title="容器类 Container"></a>容器类 Container</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>查看运行中的容器</div><div class="line">docker ps</div><div class="line"><span class="meta">#</span>查看所有容器，包括停止的</div><div class="line">docker ps -a</div><div class="line"><span class="meta">#</span> 查看全部容器的id</div><div class="line">docker ps -a -q</div><div class="line"><span class="meta">#</span>查看运行中的容器进程</div><div class="line">docker top 容器名</div><div class="line"><span class="meta">#</span>删除一个容器</div><div class="line">docker rm [容器id]</div><div class="line"><span class="meta">#</span>删除所有容器</div><div class="line">docker rm `docker ps -a -q`</div><div class="line"><span class="meta">#</span>将一个容器保存为镜像</div><div class="line">docker commit &lt;CONTAIN-ID&gt; &lt;IMAGE-NAME&gt;</div><div class="line"><span class="meta">#</span>启动一个已经存在的镜像</div><div class="line">docker start 容器id</div></pre></td></tr></table></figure><h3 id="Docker-run"><a href="#Docker-run" class="headerlink" title="Docker run"></a>Docker run</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it(命令后交互) --rm(停止后删除) -p 0.0.0.0:8080:9999(端口映射) -v /宿主目录:/容器目录 xxx:xxx(镜像) bash</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">-a, --attach=[]            Attach to STDIN, STDOUT or STDERR 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项</div><div class="line">--add-host=[]              Add a custom host-to-IP mapping (host:ip)</div><div class="line">--blkio-weight=0            Block IO (relative weight), between 10 and 1000</div><div class="line">-c, --cpu-shares=0          CPU shares (relative weight)</div><div class="line">--cap-add=[]                Add Linux capabilities</div><div class="line">--cap-drop=[]              Drop Linux capabilities</div><div class="line">--cgroup-parent=            Optional parent cgroup for the container</div><div class="line">--cidfile=                  Write the container ID to the file</div><div class="line">--cpu-period=0              Limit CPU CFS (Completely Fair Scheduler) period</div><div class="line">--cpu-quota=0              Limit the CPU CFS quota</div><div class="line">--cpuset-cpus=              CPUs in which to allow execution (0-3, 0,1) 绑定容器到指定CPU运行</div><div class="line">--cpuset-mems=              MEMs in which to allow execution (0-3, 0,1) 绑定容器到指定MEM运行</div><div class="line">-d, --detach=false          Run container in background and print container ID 后台运行容器，并返回容器ID</div><div class="line">--device=[]                Add a host device to the container</div><div class="line">--dns=[]                    Set custom DNS servers 指定容器使用的DNS服务器，默认和宿主一致</div><div class="line">--dns-search=[]            Set custom DNS search domains 指定容器DNS搜索域名，默认和宿主一致</div><div class="line">-e, --env=[]                Set environment variables 设置环境变量</div><div class="line">--entrypoint=              Overwrite the default ENTRYPOINT of the image</div><div class="line">--env-file=[]              Read in a file of environment variables 从指定文件读入环境变量</div><div class="line">--expose=[]                Expose a port or a range of ports</div><div class="line">-h, --hostname=            Container host name 指定容器的hostname</div><div class="line">--help=false                Print usage</div><div class="line">-i, --interactive=false    Keep STDIN open even if not attached 以交互模式运行容器，通常与 -t 同时使用</div><div class="line">--ipc=                      IPC namespace to use</div><div class="line">-l, --label=[]              Set meta data on a container</div><div class="line">--label-file=[]            Read in a line delimited file of labels</div><div class="line">--link=[]                  Add link to another container</div><div class="line">--log-driver=              Logging driver for container</div><div class="line">--log-opt=[]                Log driver options</div><div class="line">--lxc-conf=[]              Add custom lxc options</div><div class="line">-m, --memory=              Memory limit</div><div class="line">--mac-address=              Container MAC address (e.g. 92:d0:c6:0a:29:33)</div><div class="line">--memory-swap=              Total memory (memory + swap), &apos;-1&apos; to disable swap</div><div class="line">--name=                    Assign a name to the container 为容器指定一个名称</div><div class="line">--net=bridge                Set the Network mode for the container  指定容器的网络连接类型，支持 bridge/host/none/container:&lt;name|id&gt; 四种类型</div><div class="line">--oom-kill-disable=false    Disable OOM Killer</div><div class="line">-P, --publish-all=false    Publish all exposed ports to random ports</div><div class="line">-p, --publish=[]            Publish a container&apos;s port(s) to the host  端口映射 宿主：容器</div><div class="line">--pid=                      PID namespace to use</div><div class="line">--privileged=false          Give extended privileges to this container</div><div class="line">--read-only=false          Mount the container&apos;s root filesystem as read only</div><div class="line">--restart=no                Restart policy to apply when a container exits</div><div class="line">--rm=false                  Automatically remove the container when it exits</div><div class="line">--security-opt=[]          Security Options</div><div class="line">--sig-proxy=true            Proxy received signals to the process</div><div class="line">-t, --tty=false            Allocate a pseudo-TTY 为容器重新分配一个伪输入终端，通常与 -i 同时使用</div><div class="line">-u, --user=                Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</div><div class="line">--ulimit=[]                Ulimit options</div><div class="line">--uts=                      UTS namespace to use</div><div class="line">-v, --volume=[]            Bind mount a volume   挂载宿主文件夹 宿主:容器</div><div class="line">--volumes-from=[]          Mount volumes from the specified container(s)</div><div class="line">-w, --workdir=              Working directory inside the container</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近忙于工作，荒废了博客，在此反省一波～～好了，今天聊聊docker。docker作为一种快速部署生产环境的工具，利用了其自动化的优点，减少在部署中人为繁琐操作，从而提高了部署环境的速度以及准确度，在部署服务器集群中尤为便利，今天就简单入门一下docker吧！&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="系统部署" scheme="https://dawnki.github.io/categories/%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="docker" scheme="https://dawnki.github.io/tags/docker/"/>
    
      <category term="部署技术" scheme="https://dawnki.github.io/tags/%E9%83%A8%E7%BD%B2%E6%8A%80%E6%9C%AF/"/>
    
      <category term="docker-composer" scheme="https://dawnki.github.io/tags/docker-composer/"/>
    
  </entry>
  
  <entry>
    <title>C++:变量篇</title>
    <link href="https://dawnki.github.io/2017/08/28/c++%E5%8F%98%E9%87%8F%E7%AF%87/"/>
    <id>https://dawnki.github.io/2017/08/28/c++变量篇/</id>
    <published>2017-08-28T01:36:38.000Z</published>
    <updated>2017-08-29T05:21:58.100Z</updated>
    
    <content type="html"><![CDATA[<p>今天来讲讲C++的变量知识。C++的基础类型与C一样，都有int，char，float，double,pointer,下面是未初始化时，各个基础类型的初始值。</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">初始化默认值</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">‘\0’</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">pointer</td><td style="text-align:center">NULL</td></tr></tbody></table><p>C++没有字符串基础类型，字符串则是由字符数组表示，这点跟C一致。不过C++标准库有String类的实现。另外C++不适合做web开发很大一部分与其比较弱的字符串处理有关，毕竟web开发很大一部分都是跟字符串打交道比如最好的语言PHP(滑稽)。</p><h2 id="全局变量与局部变量"><a href="#全局变量与局部变量" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h2><p>简单的理解就是写在所有函数外部的就是全局变量，写在函数内部的就是局部变量，包括main函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a;   <span class="comment">//全局变量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> c;  <span class="comment">//局部变量</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> b;  <span class="comment">//局部变量</span></div><div class="line">    call();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>全局变量，一般情况下在被其他源文件include之后，可以直接使用，但前提是没有static关键字修饰。全局变量在本文件的哪个地方都能使用。</p><p>局部变量，通常包括被调用函数内部声明定义的变量以及形参，其声明周期在被调用函数结束后销毁。</p><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>C++静态变量通常是指被static修饰的变量，这种变量在 <strong>程序运行之前就已经分配好内存</strong>，在程序结束时才释放。这中变量的内存被分配到全局静态区，由系统进行管控。除此之外，static关键字还有以下几种功能。</p><ul><li><p>static修饰全局变量，会使得该全局变量 <strong>只能在本文件中使用</strong> ，当其他源文件include了此文件后，不能使用该static修饰的全局变量。</p></li><li><p>static修饰局部变量，会使该局部变量只能限定在自己所在的作用域(即所在函数)，这和其他局部变量一样，但是唯一不同的是由于静态变量是 <strong>程序结束时才会进行回收</strong>，因此回收阶段不在所在函数退出调用时，即 <strong>一次分配全程有效</strong>，所以下次调用该静态变量所在函数时，该变量的值不会重新申请内存以及重新初始化。</p></li><li><p>static修饰的类成员变量，能在该类 <strong>所有所属的对象中共享</strong>。static修饰的类成员方法，<strong>不需该类实例化</strong> 就才能使用，直接 类::静态方法 即可使用。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> a ;   <span class="comment">//静态全局变量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span> ;   <span class="comment">//静态局部变量</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    b++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c ;  <span class="comment">//静态局部变量</span></div><div class="line">    call();         <span class="comment">//输出0</span></div><div class="line">    call();         <span class="comment">//输出1</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="const修饰的变量"><a href="#const修饰的变量" class="headerlink" title="const修饰的变量"></a>const修饰的变量</h2><p>const原义是constant，意为永恒的，不变的。一看就觉得这个修饰词很强壮<del>Rua!</del>,这个const作用很大，可以修饰变量，修饰返回值，修饰参数，修饰函数。通常被它修饰过的多多少少代表着不会变化，不过具体情况具体分析。</p><h3 id="修饰普通变量"><a href="#修饰普通变量" class="headerlink" title="修饰普通变量"></a>修饰普通变量</h3><p>被const修饰的普通变量就成为了C++中的常量，在声明一定要初始化。在代码里一旦修改了const修饰的变量会出现编译错误。另外，<strong>const修饰的位置可以在类型前面，也可以在类型后面，意义一致</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> a =<span class="number">3</span>;</div><div class="line"><span class="comment">//等同于 int const a=3；</span></div></pre></td></tr></table></figure><h3 id="修饰返回值"><a href="#修饰返回值" class="headerlink" title="修饰返回值"></a>修饰返回值</h3><p>被const修饰的函数返回值，要分两种情况讨论。第一种是，如果返回值是非指针应用类型,那么它跟没有const修饰的函数返回值一样，没有特别的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">call</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种情况是，如果返回值时指针类型，那么如果函数返回值（即指针）的内容不能被修改，<strong>该返回值只能被赋给加const修饰的同类型指针</strong>，否则会出现编译错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">call</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// .....</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str= call();  <span class="comment">//str指针务必是const修饰的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h3><p>对于非基础数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是 <strong>提高效率</strong>。例如将void Func(A a) 改为void Func(const A &amp;a)。这样既免去了对象的复制(临时对象的构造、复制、析构消耗时间)，又可以不改变原引用内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">const</span> A &amp;a)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// your code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于基础数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为void Func(const int &amp;x)。基础数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p><h3 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h3><p>在一个类成员函数中，如果被const修饰后，该成员函数 <strong>不能改变成员变量的内容</strong>，除非成员变量带有 <strong>mutable修饰符</strong>，否则会提示编译错误。另外，const修饰的位置在函数名(含参数)后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> b;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">this</span>-&gt;b = <span class="number">3</span>;    <span class="comment">//可以修改</span></div><div class="line">        <span class="comment">// this-&gt;a =4;  不能修改</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="const-char-char-const-char-const-傻傻分不清"><a href="#const-char-char-const-char-const-傻傻分不清" class="headerlink" title="const char* , char const* , char* const 傻傻分不清"></a>const char* , char const* , char* const 傻傻分不清</h3><p>相信刚入门的小朋友肯定会对这几个变量的声明形式搞得头晕脑胀，下面就顺便说一下吧。</p><p>在此之前，先介绍一个声明指针变量的读法，有助于大家记忆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * p;</div></pre></td></tr></table></figure><p>从右往做读，* 读作pointer to意为指向。即变量p为指向char类型的指针(p is a pointer to char)</p><h4 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p = <span class="string">"123"</span>;</div><div class="line"><span class="comment">//char const * p = "123";</span></div><div class="line"></div><div class="line">p = &amp;test ; <span class="comment">//p仍能指向别的 假设&amp;test为字符串的首地址</span></div><div class="line">*p = <span class="string">"111"</span> ; <span class="comment">//编译错误 不能改变指向的内容</span></div></pre></td></tr></table></figure><p>因为const可以放在类型的前面或者后面，所以上面两个意思等价。同为 p is a pointer to const char，即变量p是一个 指向const的char 指针。等号右边的内容为const不能改变。</p><h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = <span class="string">"123"</span>;</div><div class="line"><span class="comment">//char * p const = "123";</span></div><div class="line"></div><div class="line">p = &amp;test ;  <span class="comment">//编译错误 p不能再指向别的 假设&amp;test为字符串的首地址</span></div><div class="line">*p = <span class="string">"111"</span> ;  <span class="comment">//无编译错误 可以改变指向的内容</span></div></pre></td></tr></table></figure><p>上面两种等价，const修饰的是p变量而不是char，所以p is a const pointer to char，即为p是指向char的const指针。等号左边的变量p一旦指向了，就不能更改。</p><p><strong>简单来理解就是const 修饰的对象不同，一个是修饰左值，一个修饰右值，* 就如一座大山，若const在 * 的左边，则修饰等号右边的值，若在 * 的右边，则修饰变量p，一旦初始化了就不能更改的指针。</strong></p><h4 id="指向常量的常量指针"><a href="#指向常量的常量指针" class="headerlink" title="指向常量的常量指针"></a>指向常量的常量指针</h4><p>看了我上面的解释，应该知道这个怎么写了吧？没错就是下面那样:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p =<span class="string">"123"</span>;</div><div class="line"><span class="comment">//char const * const p ="123";  //同上 等价</span></div></pre></td></tr></table></figure><p>港真，这种变量真的没什么用….p因为常量指针，所以自身不能改变指向。p指向的内容是常量，所以p不能改变内容，所以感觉实用性不大，仅供学习参考。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上知识不是光看就能明白，还需要动手打一下验证一下！编程是一门实践性极强的技术。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/lz20120808/article/details/46662569" target="_blank" rel="external">const 修饰函数参数，返回值，函数体</a></p><p><a href="http://blog.csdn.net/yingxunren/article/details/3968800" target="_blank" rel="external">const char *, char const *, char * const的区别</a></p><p><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777441.html" target="_blank" rel="external">C/C++中static关键字详解</a></p><p><a href="http://blog.csdn.net/melody_fhm/article/details/6683504" target="_blank" rel="external">指针常量与常量指针</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天来讲讲C++的变量知识。C++的基础类型与C一样，都有int，char，float，double,pointer,下面是未初始化时，各个基础类型的初始值。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;数据
      
    
    </summary>
    
      <category term="C++" scheme="https://dawnki.github.io/categories/C/"/>
    
    
      <category term="cpp" scheme="https://dawnki.github.io/tags/cpp/"/>
    
      <category term="全局变量" scheme="https://dawnki.github.io/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
      <category term="静态变量" scheme="https://dawnki.github.io/tags/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    
      <category term="常量指针" scheme="https://dawnki.github.io/tags/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++:内存篇</title>
    <link href="https://dawnki.github.io/2017/08/26/c++:%E5%86%85%E5%AD%98%E7%AF%87/"/>
    <id>https://dawnki.github.io/2017/08/26/c++:内存篇/</id>
    <published>2017-08-26T02:14:18.000Z</published>
    <updated>2017-08-28T02:50:02.697Z</updated>
    
    <content type="html"><![CDATA[<p>C++的内存知识是关键中的关键，有一些C++的内存坑点，因为C++没有垃圾回收机制(Garbage Collection),因此稍不注意容易发生内存泄露等问题。接下来就说说内存的各种要点。</p><h2 id="五种内存分配类型"><a href="#五种内存分配类型" class="headerlink" title="五种内存分配类型"></a>五种内存分配类型</h2><h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>栈(stack)内存，编译根据代码来分配并释放，通常为代码的局部变量，函数形参等，其结构类型与数据结构的栈相似，先进后出。这种内存 <strong>由系统分配并且进行回收</strong>，效率较高但最大栈内存受到编译器限制，程序猿不用担心其内存泄露，即使出错，编译器也能发现错误。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line"><span class="keyword">char</span> b[] = <span class="string">"abc"</span>;</div><div class="line"><span class="keyword">char</span> c = <span class="string">'k'</span>;</div></pre></td></tr></table></figure><p>这些内存在退出调用时系统就会自动回收。只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示 <strong>栈溢出</strong>。因此如果递归函数，但是边界设置不正确时，会因超出栈所能申请的内存空间发生栈溢出。</p><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>堆(heap)内存,通常由程序猿来申请分配，C/C++中的malloc以及new，就是分配这种堆内存。堆内存分配的效率没有栈内存的高，不过可分配的空间一般只受限于系统的有效的内存。通常这种堆内存用来存储对象或者结构体等。这种内存只有在程序猿 <strong>主动释放</strong> 或者 <strong>程序结束时</strong> 系统自动释放。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">int</span> b = (<span class="keyword">int</span>) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</div></pre></td></tr></table></figure><p>这种内存需要程序猿手动释放，不然会造成许多内存碎片(无法再度使用的)，即内存泄露，<strong>而且编译器很难检查得到</strong>。</p><h3 id="全局-amp-静态区"><a href="#全局-amp-静态区" class="headerlink" title="全局&amp;静态区"></a>全局&amp;静态区</h3><p>这部分的内存通常用来存放全局变量以及静态变量(static),这一大部分叫做全局区，全局区也分两个小部分，一部分存放已初始化的全局变量和静态变量，另一部分存放未初始化的全局变量和静态变量，并且向这部分申请内存时 <strong>只申请一次</strong> ,内存在结束时由系统自动释放。</p><p>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a;           <span class="comment">//全局变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;    <span class="comment">//全局静态变量</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">static</span> c;    <span class="comment">//局部静态变量</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种变量只会申请一次，比如在函数A里申请了局部静态变量b，当下次再次调用A时，b仍是那个内存块。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">0</span>;  <span class="comment">// 程序运行前以及申请内存并初始化</span></div><div class="line">    a++;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; A();   <span class="comment">// 输出 1</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; A();   <span class="comment">// 输出 2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="文字常量区"><a href="#文字常量区" class="headerlink" title="文字常量区"></a>文字常量区</h3><p>常量字符串存放的地方，由系统自行释放。有点像java中的字符串常量，因为同一段文字分配的是同一个内存区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *p = <span class="string">"hello,world!"</span>;  <span class="comment">//字符指针p在栈区 “hello,world!\0”在文字常量区</span></div></pre></td></tr></table></figure><h3 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h3><p>用于存放函数体的而二进制代码。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>C++的内存管理完全交给程序猿来处理，这是一把双刃剑。好处是GC部分由程序猿自己实现或者有些地方不需垃圾回收，以提高性能效率。坏处是若程序猿不自行管理的话，容易造成内存泄露，造成内存碎片化，严重的会不停的申请内存，直至系统内存无法申请为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> \*a = <span class="keyword">new</span> <span class="keyword">int</span>();   <span class="comment">//因为没有进行堆内存回收造成泄露(反斜杠由于md的问题自行忽略掉吧)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        call();    <span class="comment">//会循环申请堆内存</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>以上代码慎重运行，严重点会卡死系统(别问我怎么知道的/(ㄒoㄒ)/)</strong></p><p>为了不造成内存泄露，<strong>每次new/malloc了内存之后使用完毕务必delete/free掉刚申请的内存</strong> ,另外还可以使用c++11的智能指针，省去手动delete。智能指针自动释放内存的原理是：<strong>智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。</strong> 常用的智能指针有 shared_ptr,unique_ptr,weak_ptr具体更细致的解释(<del>挖坑</del>)将放到面向对象篇进行说明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A()&#123;&#125;;</div><div class="line">    ~A()&#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; ptr(<span class="keyword">new</span> A());    <span class="comment">//使用了智能指针后 指针超出作用域就会自动销毁所申请的内存</span></div><div class="line">    <span class="built_in">unique_ptr</span>&lt;A&gt; ptr1(<span class="keyword">new</span> A());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>安利：另外Linux下的Valgrind是检测C++内存泄露好工具哦！</strong></p><h2 id="delete-与-delete"><a href="#delete-与-delete" class="headerlink" title="delete 与 delete []"></a>delete 与 delete []</h2><p>delete 与 delete [] 经常用作回收堆内存，两者有差别，delete用来回收单个对象，delete []用来回收对象数组，下面分两种情形讨论：</p><p>(1) 当对象为基础数据类型,如int,char,double时，回收数组可以用delete []和delete</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line"><span class="keyword">delete</span> p;  <span class="comment">// or delete [] p;</span></div></pre></td></tr></table></figure><p>(2) 当对象为自定义的类对象时，回收数组必须使用delete [] ,因为使用delete [] 时 <strong>会主动调用每个对象数组元素(即单个对象)的析构函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">class <span class="title">A</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ~A()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    A* p = <span class="keyword">new</span> A[<span class="number">5</span>];</div><div class="line">    <span class="keyword">delete</span> [] p; <span class="comment">//使用delete会发生内存泄露</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以delete的实质其实是调用对象的析构函数，只是当对象为基础数据类型就简便了而已。不过为了方便记忆，建议凡是回收数组都用delete[],回收单体就用delete。<strong>即new 对应 delete , new [] 对应 delete []</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>With great power comes great responsibility is big</p></blockquote><p>性能与易用两者不可兼得也，只能苦学而取性能也！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++的内存知识是关键中的关键，有一些C++的内存坑点，因为C++没有垃圾回收机制(Garbage Collection),因此稍不注意容易发生内存泄露等问题。接下来就说说内存的各种要点。&lt;/p&gt;
&lt;h2 id=&quot;五种内存分配类型&quot;&gt;&lt;a href=&quot;#五种内存分配类型&quot; 
      
    
    </summary>
    
      <category term="C++" scheme="https://dawnki.github.io/categories/C/"/>
    
    
      <category term="cpp" scheme="https://dawnki.github.io/tags/cpp/"/>
    
      <category term="内存分配" scheme="https://dawnki.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="内存泄露" scheme="https://dawnki.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>CMakeList批量导入源文件和头文件</title>
    <link href="https://dawnki.github.io/2017/08/25/goodCMake/"/>
    <id>https://dawnki.github.io/2017/08/25/goodCMake/</id>
    <published>2017-08-25T09:51:43.000Z</published>
    <updated>2017-08-25T10:08:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享一套 <strong>提高寿命</strong> 的CMakelist写法，仅供简单项目使用O(∩_∩)O哈哈~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cmake_minimum_required(VERSION 3.8)</div><div class="line"></div><div class="line">project(your_project_name)</div><div class="line"></div><div class="line">set(CMAKE_CXX_STANDARD 11)</div><div class="line"></div><div class="line">file(GLOB SOURCE_FILES &quot;*.h&quot; &quot;*.cpp&quot;)</div><div class="line"></div><div class="line">add_executable(your_project_name $&#123;SOURCE_FILES&#125;)</div></pre></td></tr></table></figure><p>简单粗暴利用 <strong>通配符</strong> 直接把目录下的所有头文件，源文件直接导入，包括二级，三级…..N级目录。</p><p>妈妈再也不用担心我xxxx未定义使用~\(≧▽≦)/~啦啦啦</p><p>弱鸡写法，仅供简单项目使用233333333</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天分享一套 &lt;strong&gt;提高寿命&lt;/strong&gt; 的CMakelist写法，仅供简单项目使用O(∩_∩)O哈哈~&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div 
      
    
    </summary>
    
      <category term="C++" scheme="https://dawnki.github.io/categories/C/"/>
    
    
      <category term="CMakeList" scheme="https://dawnki.github.io/tags/CMakeList/"/>
    
      <category term="C++" scheme="https://dawnki.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++:头文件篇</title>
    <link href="https://dawnki.github.io/2017/08/25/cpp%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>https://dawnki.github.io/2017/08/25/cpp头文件/</id>
    <published>2017-08-25T06:03:52.000Z</published>
    <updated>2017-08-26T09:45:15.492Z</updated>
    
    <content type="html"><![CDATA[<p>在学习c++，被头文件搞得一头包，时常出现重定义的错误，今天就理一下c++的头文件，彻底把它搞懂。C++与C一样，所有变量都需要先声明才能使用，这种”啥都别说，先报名字”的做法，不仅应用在了变量身上，一个函数也需要先声明后使用，并且这个函数只能定义一次。</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    B();     <span class="comment">// 未声明调用</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// your code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的例子中，由于B出现的顺序在A之后，但是A先调用未声明B，因此会报错。解决办法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">()</span></span>;   <span class="comment">//此处声明</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    B();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">()</span>    <span class="comment">//此处定义(实现)</span></span></div><div class="line"><span class="function"></span>&#123;   </div><div class="line">    <span class="comment">// your code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的知识很简单，学过c基础的同学都知道，上面的例子是说明，声明与定义不一样，调用函数前，这个函数一定是要 <strong>先声明</strong> (可以声明无数次) ，其函数的定义可以延后，并且 <strong>只能定义一次</strong> 。明白了要点之后回到正题。</p><p>C++和其他语言一样可以分别编译，用于将代码分成若干个cpp，每个cpp负责不同的功能。如果但是几个cpp文件相互依赖的话，我们直接include cpp源文件 <strong>容易出现重复定义的错误</strong>。至于为什么会重复定义呢？这是因为include的时候，相当于把目标文件的内容包含进来，比如A包含了B，因为B里面的某个函数有具体的定义(实现)，所以A里面就相当定义了一次B里面的函数，但是等到编译B的时候，B也定义了一次函数，导致重复定义的错误。</p><p>不犯重复定义的函数也很简单，不需要include源文件，直接在依赖者中(a.cpp)先声明然后使用即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//a.cpp</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    test();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//b.cpp</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// your code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在弄出个头文件的目的就是，比如A要使用B的函数f(),A肯定不能包含具体定义的文件(重复定义)，A就包含具有B文件里所有函数声明的头文件B.h,要知道多次定义会报错但是多次声明不会报错。因此，C++推荐的写法是定义与声明分开，头文件写声明，源文件写定义，源文件之间依赖通过包含源文件的头文件来实现。同时，头文件时一个存着一堆声明文件，因此就不用像上面的代码那样，在依赖者中写入被依赖者的声明(解耦)。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>现在存在的一个场景是，源文件A依赖源文件B的f(),源文件A叫做A.cpp,源文件B叫做B.cpp,源文件B的头文件叫做B.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* A.cpp */</span></div><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"B.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    f();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* B.h */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> project_B_H  <span class="comment">//头文件保护措施</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> project_B_H</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;  <span class="comment">//声明</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">/* B.cpp */</span></div><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"B.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span>   <span class="comment">// 实现</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// your code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上述例子中，B的头文件里面由一些宏定义，这些是为了防止重复定义，具体的场景是，两个源文件include了同一个头文件。而编译时，这两个源文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突，因此需要加上#ifndef和#endif，当中ifndef和define后面跟是一个唯一标识，通常规范的格式为项目名_类名_H(H代表头)</p><p>如果换成类的写法就是这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* A.cpp */</span></div><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"B.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    f();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* B.h */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> project_B_H  <span class="comment">//头文件保护措施</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> project_B_H</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">/* B.cpp */</span></div><div class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"B.h"</span></span></div><div class="line"></div><div class="line">B::f()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// your code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>当然具体的实现也可直接写在头文件里，完全没有问题。</strong></p><h2 id="include-“”-与-include-lt-gt"><a href="#include-“”-与-include-lt-gt" class="headerlink" title="include “” 与 include &lt;&gt;"></a>include “” 与 include &lt;&gt;</h2><p>#include &lt; file &gt; 编译程序会先到 <strong>标准函数库</strong> 中找文件</p><p>#include “file” 编译程序会先从 <strong>当前目录</strong> 中找文件</p><h2 id="头文件中可能会出现的extern关键字"><a href="#头文件中可能会出现的extern关键字" class="headerlink" title="头文件中可能会出现的extern关键字"></a>头文件中可能会出现的extern关键字</h2><p>在C语言中，修饰符extern用在变量或者函数的声明前，用来说明此变量/函数是在别处定义的，要在此处引用。</p><p>在C++中extern还有另外一种作用，用于指示C或者C++函数的调用规范。比如在C++中调用C库函数，就需要在C++程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>老实说，这种定义与声明分开的写法还真有点蛋疼，如果一改就要改两处，所以感觉如果定义与声明都写在头文件里，然后一个include就完事了,这种做法比较方便点。当中应该考虑到兼容c等各种历史原因吧～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习c++，被头文件搞得一头包，时常出现重定义的错误，今天就理一下c++的头文件，彻底把它搞懂。C++与C一样，所有变量都需要先声明才能使用，这种”啥都别说，先报名字”的做法，不仅应用在了变量身上，一个函数也需要先声明后使用，并且这个函数只能定义一次。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="C++" scheme="https://dawnki.github.io/categories/C/"/>
    
    
      <category term="cpp" scheme="https://dawnki.github.io/tags/cpp/"/>
    
      <category term="头文件" scheme="https://dawnki.github.io/tags/%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    
      <category term="编译" scheme="https://dawnki.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>浅析IO模型</title>
    <link href="https://dawnki.github.io/2017/08/12/%E6%B5%85%E6%9E%90IO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://dawnki.github.io/2017/08/12/浅析IO模型/</id>
    <published>2017-08-12T06:13:15.000Z</published>
    <updated>2017-08-24T08:54:58.519Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的同步异步文章中埋了个坑，今天就来填一下吧。当CPU发起IO调用，需要读取文件里的东西时，由于IO处理的速度没有CPU那么快，因此，通常都是CPU在等待IO处理完毕返回数据。当IO处理中到CPU拿到文件数据，这里存在几种IO模型，分别是read，select，poll，epoll，kqueue。在此先说一下fd，系统在读写文件的时候，需要文件描述符(file descriptor简称fd)，当调用系统内核来进行文件操作时，内核会返回一个文件描述符，若要知道IO是否处理完毕，只需查看fd中的事件状态即可，即程序调用内核时就是查看这个状态，来判断是否完成操作的。下面就简单介绍下这几种IO模型。</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>这是原始的轮询模式，当CPU发起IO调用时，处于等待状态，然后IO就去处理，然后就重复的检查fd的事件状态，当事件状态为处理完毕后，读出完整数据。这种做法比较原始以及性能较差。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select是在read上的改进，有一个数组负责存着一堆文件描述符，然后遍历数组中的文件描述符来检查当中的事件状态，当某个文件已经处理完毕之后，就进行一次read操作来读取完整数据，然后交给应用。</p><p>select的缺点有两个。①是存放文件描述符的数组大小有限，一个进程处理的文件描述符(fd)数有限(cat /proc/sys/fs/file-max).32位机默认是1024个。64位机默认是2048.②随着fd的增多，会造成性能线性下降的问题(主因线性遍历)。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll则是在select的基础上进行改良，采用链表的数据结构来存储文件描述符，以解决select的数组大小限制问题。但是还是需要线性遍历，因此select的第二个缺点还是无法避免。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll只能在Linux使用。epoll是目前性能强劲的io复用模型，epoll的原理是每当操作文件时，都有一个回调函数与fd相对应，当io操作完毕后，就会调用这个回调函数来通知应用获取数据。</p><p>epoll中由三个函数，分别是epoll_create,epoll_ctl,epoll_wait。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure><p>epoll_create用于创建epoll句柄，然后epoll来监听管理一定量的文件描述符。当然这个句柄本身就占一个fd。</p><p>epoll_ctl用于控制管理一个epoll句柄下面N个的fd，比如可以对一个epoll句柄下的某个fd进行增删该事件监听，这里监听的事件指的是epoll观察指定fd的状态，比如某个fd需要读写数据等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct epoll_event</div><div class="line">&#123;  </div><div class="line">    __uint32_t events;   </div><div class="line">    epoll_data_t data;  </div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef union epoll_data</div><div class="line">&#123;  </div><div class="line">    void *ptr;  </div><div class="line">    int fd;  </div><div class="line">    __uint32_t u32;  </div><div class="line">    __uint64_t u64;  </div><div class="line">&#125; epoll_data_t;</div></pre></td></tr></table></figure><p>epoll_wait,根据触发方式(水平触发或者边缘触发)，来收集刚刚epoll_ctl中已注册并且触发的事件(就绪链表)，比如收集了fd为2,3的已经触发的事件，然后把这些事件赋值给一个数组(参数二中的events数组)，如果没有超时(timeout)，epoll_wait就会返回 <strong>触发事件的数目</strong> ,然后去指定事件数组里拿相应数目的文件描述符(epoll_event储存了许多信息，里面的data就包含文件描述符)即可，这样就可以达到不复制文件描述符省去巨大的开销。<strong>同时也epoll只需拿到触发事件的文件描述符及其结果，而不像select和poll一样把不活跃的fd都一同获取了。</strong></p><p>虽然说epoll_wait也是像select和poll一样需要轮询，不过它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空。<strong>另外epoll使用了mmap(内存映射技术)，加速与内核与用户空间的消息传递，避免不必要的内存拷贝。</strong></p><h2 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h2><p>kqueue与epoll一样都是基于事件的方式来处理IO复用的问题，只是kqueue是应用在BSD系统上，在此就不在赘述。</p><h2 id="水平触发-amp-边缘触发"><a href="#水平触发-amp-边缘触发" class="headerlink" title="水平触发 &amp; 边缘触发"></a>水平触发 &amp; 边缘触发</h2><p>LT：水平触发，支持阻塞和非阻塞io，效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，<strong>会再次响应应用程序并通知此事件</strong>。select和poll只支持水平触发。</p><p>ET：边缘触发，仅支持非阻塞io，<strong>效率非常高</strong>，在并发，大流量的情况下，<strong>会比LT少很多epoll的系统调用</strong>，当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。epoll支持边缘触发。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>read属于原始的IO模型，而select，poll，epoll，kqueue都是属于IO复用模型，可以管理一定量的文件描述符。epoll基于事件的处理方式在处理大量的连接时仍保持这不错的性能，有效的提高了IO效率。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/yusiguyuan/article/details/15027821" target="_blank" rel="external">http://blog.csdn.net/yusiguyuan/article/details/15027821</a></p><p><a href="http://blog.csdn.net/xiajun07061225/article/details/9250579" target="_blank" rel="external">http://blog.csdn.net/xiajun07061225/article/details/9250579</a></p><p><a href="http://www.hulkdev.com/posts/epoll-io" target="_blank" rel="external">http://www.hulkdev.com/posts/epoll-io</a></p><p><a href="http://blog.csdn.net/jay900323/article/details/18141217/" target="_blank" rel="external">http://blog.csdn.net/jay900323/article/details/18141217/</a></p><p><a href="http://blog.csdn.net/tianmohust/article/details/6677985/" target="_blank" rel="external">http://blog.csdn.net/tianmohust/article/details/6677985/</a></p><p><a href="http://www.cnblogs.com/Anker/p/3263780.html" target="_blank" rel="external">http://www.cnblogs.com/Anker/p/3263780.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前的同步异步文章中埋了个坑，今天就来填一下吧。当CPU发起IO调用，需要读取文件里的东西时，由于IO处理的速度没有CPU那么快，因此，通常都是CPU在等待IO处理完毕返回数据。当IO处理中到CPU拿到文件数据，这里存在几种IO模型，分别是read，select，poll
      
    
    </summary>
    
      <category term="操作系统" scheme="https://dawnki.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="IO复用" scheme="https://dawnki.github.io/tags/IO%E5%A4%8D%E7%94%A8/"/>
    
      <category term="轮询" scheme="https://dawnki.github.io/tags/%E8%BD%AE%E8%AF%A2/"/>
    
      <category term="非阻塞" scheme="https://dawnki.github.io/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    
      <category term="epoll" scheme="https://dawnki.github.io/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>玩转SSH</title>
    <link href="https://dawnki.github.io/2017/08/12/%E7%8E%A9%E8%BD%ACSSH/"/>
    <id>https://dawnki.github.io/2017/08/12/玩转SSH/</id>
    <published>2017-08-12T04:30:03.000Z</published>
    <updated>2017-08-12T05:59:52.565Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，连接linux服务器最好用的是ssh，linux机器连接linux机器，直接使用ssh命令即可，不过每次都要一堆登录参数，也是十分麻烦，最重要的是ssh连接时需要填写要登录服务器的ip，ip什么的又难记，难免会影响到工作效率，那有没有办法像window上的xshell一样，免登陆密码，并且登录时命令不用这么复杂呢？</p><p>  <strong>答案是有的！今天就讲讲SSH免登录密码+Bash里的alias配置</strong></p><h2 id="主体思路"><a href="#主体思路" class="headerlink" title="主体思路"></a>主体思路</h2><ol><li>登录方先生成SSH密钥和公钥</li><li>将公钥内容添加到被被登录方的authorized_keys中</li><li>先登录一波，记录下。此时以后登录就能免密码了</li><li>修改bashrc，自定义自己的 <del>骚操作</del> 命令，简化命令</li></ol><h2 id="开工"><a href="#开工" class="headerlink" title="开工"></a>开工</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>老套路</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa</span></div></pre></td></tr></table></figure><p>三个回车，ssh公钥私钥就搞到手了。</p><p>此时，公私钥存放的位置时用户目录的.ssh文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh</span></div></pre></td></tr></table></figure><p>私钥存着不管，把公钥内容拿了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> cat id_rsa.pub</span></div></pre></td></tr></table></figure><h3 id="设置被登录服务器的授权key"><a href="#设置被登录服务器的授权key" class="headerlink" title="设置被登录服务器的授权key"></a>设置被登录服务器的授权key</h3><p>登录服务器，并且找到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh</span></div><div class="line"><span class="meta">$</span><span class="bash"> vim authorized_keys</span></div></pre></td></tr></table></figure><p>此时将你的ssh公钥添加到授权key文件中</p><p>然后回到本机，先ssh登录一波机器，然后之后就能免密码登录了。</p><blockquote><p>也可以用scp直接传公钥到服务器,具体命令 scp ~/.ssh/id_rsa.pub server_user_name@server_ip:server_targer_path ,具体内容根据自己实际情况填写</p></blockquote><h3 id="设置命令别名，简化命令"><a href="#设置命令别名，简化命令" class="headerlink" title="设置命令别名，简化命令"></a>设置命令别名，简化命令</h3><p>设置命令别名(alias)，能够有效减少命令的长度，提高工作效率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> vim ~/.bashrc</span></div></pre></td></tr></table></figure><p>在里面找个空白位置添加上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> My aliases</span></div><div class="line">alias your_command='ssh server_user_name@server_ip' #里面的内容根据自己实际情况填写</div><div class="line"><span class="meta">#</span><span class="bash"> eg  <span class="built_in">alias</span> dawnki=<span class="string">'ssh root@123.123.123.123'</span></span></div></pre></td></tr></table></figure><p>然后保存并退出，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source .bashrc</div></pre></td></tr></table></figure><p>接下来你就可以用到别名命令了</p><p>就上面那个例子，免登陆+别名，我直接打短命令就能直接ssh登录到服务器了，大大提高工作效率</p><p>如果你想要原始命令只需在命令前加反斜杠</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\ls</div></pre></td></tr></table></figure><blockquote><p>若要每次登入就自动生效别名，则把别名加在/etc/profile或~/.bashrc中。然后# source ~/.bashrc。若要让每一位用户都生效别名，则把别名加在/etc/bashrc最后面，然后# source /etc/bashrc。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  还有其他短命令就自己自定义吧！！不过 <strong>刚入门linux</strong> 的小伙伴还是先熟悉命令在偷懒，不然连原始命令都忘了( ⊙ o ⊙ )啊！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道，连接linux服务器最好用的是ssh，linux机器连接linux机器，直接使用ssh命令即可，不过每次都要一堆登录参数，也是十分麻烦，最重要的是ssh连接时需要填写要登录服务器的ip，ip什么的又难记，难免会影响到工作效率，那有没有办法像window上的xshe
      
    
    </summary>
    
      <category term="系统部署" scheme="https://dawnki.github.io/categories/%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="Linux" scheme="https://dawnki.github.io/tags/Linux/"/>
    
      <category term="SSH" scheme="https://dawnki.github.io/tags/SSH/"/>
    
      <category term="Bash" scheme="https://dawnki.github.io/tags/Bash/"/>
    
      <category term="alias" scheme="https://dawnki.github.io/tags/alias/"/>
    
  </entry>
  
  <entry>
    <title>Linux下go1.8安装方法</title>
    <link href="https://dawnki.github.io/2017/08/12/Linux%E4%B8%8Bgo1-8%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/"/>
    <id>https://dawnki.github.io/2017/08/12/Linux下go1-8安装方法/</id>
    <published>2017-08-11T17:23:44.000Z</published>
    <updated>2017-08-12T04:28:53.504Z</updated>
    
    <content type="html"><![CDATA[<p>之前迷上了神奇的Go语言，就在windows上装上了Go1.8，挺顺风顺水的，不过最近换上了Linux时，编译安装就炸了，各种报错。今天就留个记录，备个份！</p><p>编译安装Go1.8的主体思路:</p><ol><li>从<a href="https://github.com/golang/go" target="_blank" rel="external">github</a>中clone下来</li><li>确保linux系统安装较新的libc,gcc(apt,yum随便搞上)</li><li>切换库分支至1.4(刚clone下来的库)，去到src目录，执行all.bash</li><li>把编译安装完的1.4目录cp到/root/，并更名为go1.4</li><li>将刚刚的编译安装的仓库恢复原状(git clean -dfx),在切换到1.8，同样刚刚的操作，执行all.bash,安装1.8</li><li>然后1.8安装完后，配置profile</li></ol><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>  1.由于Go1.8的安装需要go1.4的二进制，所以，如果没安装go1.4的小伙伴，直接安装1.8估计会这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4.</div></pre></td></tr></table></figure><p>  这个GOROOT_BOOTSTRAP地址默认在/root/go1.4(~/go1.4)</p><p>  2.用all.bash安装1.4时炸了</p><p>  报错如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># cmd/pprof</div><div class="line">.../go1.4/pkg/linux_amd64/runtime/cgo.a(_all.o): unknown relocation type 42; compiled without -fpic?</div><div class="line">.../go1.4/pkg/linux_amd64/runtime/cgo.a(_all.o): unknown relocation type 42; compiled without -fpic?</div><div class="line">runtime/cgo(.text): unexpected relocation type 298</div><div class="line">runtime/cgo(.text): unexpected relocation type 298</div></pre></td></tr></table></figure><p> <a href="https://stackoverflow.com/questions/37192696/error-building-go-compiler-from-source" target="_blank" rel="external">拿去不用谢我.jpg</a></p><p> 所以解决方案是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cd ~/go1.4/src</div><div class="line"><span class="meta">$</span> CGO_ENABLED=0 ./make.bash</div></pre></td></tr></table></figure><blockquote><p>导致的原因是:CGO_ENABLED: Controls cgo usage during the build. Set it to 1 to include all cgo related files, .c and .go file with “cgo” build directive, in the build. Set it to 0 to ignore them.在构建过程中控制cgo的使用。当设置为1，在构建时，会包含所有cgo相关的文件，如带有”cgo”编译指令的.c和.go文件。当设置为0，则忽略它们（即禁用CGO）</p></blockquote><p>  3.在顺利的安装完1.4后再安装1.8，应该也没问题了，最后设置一下环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /ect/profile</div></pre></td></tr></table></figure><p>在里面加上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Golang Env</div><div class="line">export PATH=$PATH:/home/xx/go/bin  //xx根据实际情况填写</div><div class="line">export GOPATH=/home/xx/go-projects  //xx根据实际情况填写</div></pre></td></tr></table></figure><p>然后重启电脑，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go version</div></pre></td></tr></table></figure><p>显示到版本号的话就可以愉快的玩耍了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然安装的历程有点坎坷，不过看在go编程这么<del>奇葩</del>有趣的份上，忍了吧！O(∩_∩)O哈哈~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/northbright/Notes/blob/master/Golang/china/install-go1.6-from-source-on-centos7-in-china.md" target="_blank" rel="external">中国网络环境下源码编译安装Go1.6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前迷上了神奇的Go语言，就在windows上装上了Go1.8，挺顺风顺水的，不过最近换上了Linux时，编译安装就炸了，各种报错。今天就留个记录，备个份！&lt;/p&gt;
&lt;p&gt;编译安装Go1.8的主体思路:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从&lt;a href=&quot;https://gith
      
    
    </summary>
    
      <category term="系统部署" scheme="https://dawnki.github.io/categories/%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="Go1.8" scheme="https://dawnki.github.io/tags/Go1-8/"/>
    
      <category term="Linux" scheme="https://dawnki.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql锁机制知识整理</title>
    <link href="https://dawnki.github.io/2017/08/08/%E6%B5%85%E8%B0%88mysql%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://dawnki.github.io/2017/08/08/浅谈mysql锁机制/</id>
    <published>2017-08-08T08:56:20.000Z</published>
    <updated>2017-08-11T16:08:15.145Z</updated>
    
    <content type="html"><![CDATA[<p>并发处理时我们经常谈到的问题。在数据库操作中，有时候需要考虑并发的问题，比如我们常见的库存管理系统以及银行转账等问题，这些场景都需要用到数据库的锁机制以及事务，不然很容易造成”脏数据”等常见的在并发中遇到的问题。今天浅谈一下mysql锁机制。</p><h2 id="表级锁与行级锁"><a href="#表级锁与行级锁" class="headerlink" title="表级锁与行级锁"></a>表级锁与行级锁</h2><p>Mysql的锁机制大概分为两种，一种是表级锁，一种是行级锁。顾名思义，表级锁就是在进行读写操作时，把涉及到的目标表锁住，阻塞其他连接对相关表的操作。行级锁就是粒度更细了，精确到了表里的某条纪录。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">表级锁</th><th style="text-align:center">行级锁</th></tr></thead><tbody><tr><td style="text-align:center">开销</td><td style="text-align:center">少</td><td style="text-align:center">大</td></tr><tr><td style="text-align:center">冲突</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">是否可能死锁</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">并发度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr></tbody></table><p>Mysql中的Innodb引擎支持行级锁以及表级锁，MyIsam只支持表级锁。表级锁中，当一个连接给一个加锁后，只能访问或者修改加锁的表，而不能再访问其他表了，除非解锁，这就破坏了死锁中的占有且等待条件，因而不用担心造成死锁的问题。</p><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>  更新丢失(Lost Update):简单来说就是两个连接(事务)同时对一行进行更新，最后导致了晚一点点更新的会覆盖掉之前更新的。解决办法就是在一个连接进行更改操作时，不允许其他连接访问就可以避免更新丢失的问题。</p><p>  脏读(Dirty Reads):一个事务对一条记录进行修改时(未提交)，此时其他事务对这条记录进行读操作，导致读取的是旧数据，非最新的修改数据，因而数据脏读。</p><p>  不可重复读(Non-Repeatable Reads):一个事务在读取某些数据后的某个时间，再次读取之前读过的数据，但是数据可能已经发生更改，之前读到的数据不一致。</p><p>  幻读(Phantom Reads):一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。</p><h2 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h2><p>  共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p><p>  排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p><p>  意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p><p>  意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p><p>  InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过 <strong>索引</strong> 条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁.</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ol><li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li><li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。</li><li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="http://www.2cto.com/database/201508/429967.html" target="_blank" rel="external">Mysql中那些锁机制之InnoDB</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;并发处理时我们经常谈到的问题。在数据库操作中，有时候需要考虑并发的问题，比如我们常见的库存管理系统以及银行转账等问题，这些场景都需要用到数据库的锁机制以及事务，不然很容易造成”脏数据”等常见的在并发中遇到的问题。今天浅谈一下mysql锁机制。&lt;/p&gt;
&lt;h2 id=&quot;表级锁
      
    
    </summary>
    
      <category term="数据库" scheme="https://dawnki.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://dawnki.github.io/tags/mysql/"/>
    
      <category term="并发" scheme="https://dawnki.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="锁机制" scheme="https://dawnki.github.io/tags/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>SOLID原则</title>
    <link href="https://dawnki.github.io/2017/08/08/solid/"/>
    <id>https://dawnki.github.io/2017/08/08/solid/</id>
    <published>2017-08-08T06:44:49.000Z</published>
    <updated>2017-08-08T08:49:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>SOLID原则其实是由面向对象的五大设计原则组成，也是各种设计模式的基础理论。适当遵守SOLID原则，能写出高内聚，松耦合的代码，便于当需求变动能更快的拓展。废话不多说，下面立即正片。</p><table><thead><tr><th style="text-align:center">原则名称</th><th style="text-align:center">英文原义</th><th>中文含义</th></tr></thead><tbody><tr><td style="text-align:center">Single Responsibility Principle</td><td style="text-align:center">A class should have one, and only one, reason to change.</td><td>单一责任原则</td></tr><tr><td style="text-align:center">Open Closed Principle</td><td style="text-align:center">You should be able to extend a classes behavior, without modifying it.</td><td>开放封闭原则</td></tr><tr><td style="text-align:center">Liskov Substitution Principle</td><td style="text-align:center">Derived classes must be substitutable for their base classes.</td><td>里氏替换原则</td></tr><tr><td style="text-align:center">Interface Segregation Principle</td><td style="text-align:center">Make fine grained interfaces that are client specific.</td><td>接口分离原则</td></tr><tr><td style="text-align:center">Dependency Inversion Principle</td><td style="text-align:center">Depend on abstractions, not on concretions.</td><td>依赖倒置原则</td></tr></tbody></table><p>  没错，S.O.L.I.D原则就是这五个原则的首字母简称，从气势来看就觉得很“结实”，下面就简单介绍各个原则的含义。</p><h2 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h2><p>  当需要修改某个类的时候原因有且只有一个。原义就是这样，简单来说就是一个类只尽自己所责，不瞎掺和其他功能，因此只会因为 <strong>一个功能</strong> 的问题而修改一个类。这样做的好处是一个功能出问题了，调试或者更改时可以完全不会影响到另外有一个功能的执行。</p><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><p>  当系统需要增加新功能的时候，我们应该在原基础上进行拓展，而不是从零开始把之前的代码都修改了。其实这个原则在继承中得到体现，比如由抽象的鸟类，下面的蜂鸟，金丝雀等都继承鸟类这个类，当出现新的鸟物种时，应当在由鸟类的基础上进行继承然后在子类进行拓展的，而不是因为新物种的特性而修改父类。总而言之，<strong>对拓展是开放的，对修改是封闭的</strong> 。这样做的好处是完全不用担心影响之前运行良好的代码，放心拓展！</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>  用到父类实例的地方，把父类实例替换成子类实例应当时 <strong>无缝替换</strong> ，照样能跑通的。之后的依赖倒置原则会告诉我们具体的东西应该依赖抽象，具体的东西(如客户端，展现层)在使用具体服务时，应当时使用父类实例，然后根据多态来真实用到子类的功能，如果不按里氏替换原则来的话，当客户端用到服务时，还要根据子类的具体情况进行调整，这样子类需要修改时，就要改两处(子类和客户端)，不便修改。因此需要做到用到父类的地方，换成子类照样无缝替换，这样如果功能出问题了，我们第一反应是只要修改子类即可！</p><h2 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h2><p>  接口分离原则就是当一个类实现了一个接口后，接口里面的方法都是对这个类有用的，不存在方法体为空来实现(强迫实现)。就是说，<strong>一个接口不要太过臃肿，应该粒度更细</strong> ，因为如果接口太过臃肿，可能导致实现类实现了不属于它自己责任的方法从而违反了单一责任原则。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>  具体类应该依赖抽象类，高级代码 <strong>应当也依赖抽象类</strong> ，而不是依赖低级代码。首先先来说下，高级代码和低级代码都是具体类，其中低级代码指提供基础实现的代码，比如读写文件类，图片上传类，但是他们是具体，比如这个图片上传类是将图片上传到七牛的。其中高级代码是涉及到业务逻辑的代码，如需要用到图片上传用作头像的业务代码。这样就有个问题了，明显高级代码依赖低级代码嘛，不依赖低级代码似不似傻？但是假如有一天七牛上传图片崩了，你需要换其他图片上传服务，但是由之前高级代码依赖低级代码，所以高级类里面全tm都是低级类的片段，想想改起来就觉得可啪！！因此假如一开就依赖抽象，那样就能利用多态灵活更改了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  遵守好的设计理念，不一定做出好的产品。但是用不好的设计，肯定做不出好东西！</p><p>  <strong>设计模式以及理念这东西，应该是理解本质后灵活使用的，而不是死记硬背，不然死记硬背的东西，到时候实操起来也不会第一时间想到使用！！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SOLID原则其实是由面向对象的五大设计原则组成，也是各种设计模式的基础理论。适当遵守SOLID原则，能写出高内聚，松耦合的代码，便于当需求变动能更快的拓展。废话不多说，下面立即正片。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-ali
      
    
    </summary>
    
      <category term="编程规范" scheme="https://dawnki.github.io/categories/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="设计模式" scheme="https://dawnki.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="SOLID原则" scheme="https://dawnki.github.io/tags/SOLID%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>异步同步阻塞非阻塞详解</title>
    <link href="https://dawnki.github.io/2017/07/31/async/"/>
    <id>https://dawnki.github.io/2017/07/31/async/</id>
    <published>2017-07-31T14:39:10.000Z</published>
    <updated>2017-07-31T17:32:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信刚入门计算机科学的小伙伴们来说，这四个词–异步，同步，阻塞，非阻塞，直接搞晕，因为单单理解四个词就算了，他们还能组合，同步阻塞，同步非阻塞，异步阻塞，异步非阻塞+_+。因此今天就主要谈谈这几个词，顺便备个份，怕是我哪一天忘记了回来看看2333333</p><p>首先，这些概念出现的场景发生在应用程序调用系统内核之间。我们知道例如十分耗时的IO操作就是由内核完成的，由于应用程序（cpu）处理的速度十分快，而IO处理很慢，所以就有了等待与不等待的问题，因此就有了以上各个词的出现。</p><h2 id="单个解析"><a href="#单个解析" class="headerlink" title="单个解析"></a>单个解析</h2><p>  1.同步，在调用方层面（上文中的应用程序）上，当应用程序发起同步调用时，这个应用程序脑袋很倔，一心只想把眼前的事做完（获取处理结果才算做完）在做其它的，因此他需要被调方（IO）返回到了处理结果时才会结束</p><p>  2.异步，在调用方层面上，当应用程序发起异步调用时，这个应用程序就很机灵了，当它发起调用后，不需被调方返回处理结果，直接去干别的事，如果被调方（IO）处理完了事情后，通过通知的方式通知它就好</p><p>  3.阻塞，在被调用方层面上，当被调方（IO）接收到调用通知之后，会把调用方（应用程序）挂着，不会跟调用方说一句话，直到自己处理完数据后，把数据复制到内存，然后再把结果返回给应用程序。这就像不解风情的程序猿与测试妹子，妹子告诉程序猿:”你这里有bug！” 然后程序猿一句话也不理妹子，埋头去debug，直到修复了，才告诉妹子说bug修复了/(ㄒoㄒ)/ （注孤生啊！）</p><p>  4.非阻塞，在被调用方层面上，当被调方接受到调用通知之后，会先返回信息告诉调用方:”我知道了，你先去忙别的吧”。注意这里返回的信息与完成处理任务返回的信息时两码事，事情还没做完（处理IO任务）！！所以说这个程序猿就很有情商了，可以可以O(∩_∩)O</p><h2 id="组合解析"><a href="#组合解析" class="headerlink" title="组合解析"></a>组合解析</h2><h3 id="同步阻塞：一个很倔的测试妹子与一个注孤生的程序猿"><a href="#同步阻塞：一个很倔的测试妹子与一个注孤生的程序猿" class="headerlink" title="同步阻塞：一个很倔的测试妹子与一个注孤生的程序猿"></a>同步阻塞：一个很倔的测试妹子与一个注孤生的程序猿</h3><p>  过程：当调用方发起调用时，调用者一直等待处理的结果才结束，而被调者在发生调用后，也不会立即返回，而是处理完一系列流程（如磁盘寻道-&gt;读取数据-&gt;复制数据到内存）时，才返回处理结果给调用者，其间把调用方挂起。</p><p>  例子：<strong>一个等着bug修复完做其他事的妹子去找（调用）注孤生的程序猿，程序猿知道后，一声不吭就debug，直到修复完bug，返回处理结果给妹子，妹子收到结果后，就去做其他事了</strong>。</p><p>  <img src="http://opobbao46.bkt.clouddn.com/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E.jpg"></p><hr><h3 id="同步非阻塞：一个很倔的测试妹子与一个很机灵的程序猿"><a href="#同步非阻塞：一个很倔的测试妹子与一个很机灵的程序猿" class="headerlink" title="同步非阻塞：一个很倔的测试妹子与一个很机灵的程序猿"></a>同步非阻塞：一个很倔的测试妹子与一个很机灵的程序猿</h3><p>  过程：当调用方发起调用时，调用者需要被调方得到处理结果才结束，而被调者在发生调用后，立即返回信息给调用者，不过还没得到处理内容，当调用者发现得到的不是处理结果，继续发起调用，而被调者依然立即返回，如此反复，直到被调者在过程中处理完信息，然后返回给处理结果给调用者，调用者得到处理结果后，结束调用。</p><p>  例子：<strong>一个很倔的测试妹子去找一个机灵的程序猿，程序猿告诉她先去干别的事，妹子收到信息后，回到自己的座位上，想了想我还要等到那个bug修复完，因此继续找程序猿，程序猿又告诉她回去等，如此反复，程序猿在一边被骚扰一边修复bug直到修复完毕后，把结果告诉妹子，妹子得到结果开心的做其他事了</strong>。</p><p>  <img src="http://opobbao46.bkt.clouddn.com/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.jpg"></p><hr><h3 id="异步阻塞：一个机灵的测试妹子与一个注孤生的程序猿"><a href="#异步阻塞：一个机灵的测试妹子与一个注孤生的程序猿" class="headerlink" title="异步阻塞：一个机灵的测试妹子与一个注孤生的程序猿"></a>异步阻塞：一个机灵的测试妹子与一个注孤生的程序猿</h3><p>  过程：当调用者发起调用时，被调者收到调用通知后，把调用者挂起，而自己就去处理数据，直到处理完毕后，把挂起的调用者拉回来，把结果返回给它，然后结束调用。</p><p>  例子：<strong>一个很机灵的妹子，在发现了bug后，本来想先通知（调用）一下程序猿，然后自己就去干别的事，结果在她找到程序猿后，这个不识趣情商低的程序猿，直接不理妹子，让妹子在那儿干等（挂起），直到自己把bug修复完之后，就告诉一直站在那儿的妹子说，bug修复完了，你可以走了（妹子拿到了结果）</strong>。</p><p>  由于太过奇葩，概念图片不予展示2333333</p><hr><h3 id="异步非阻塞：一个很机灵的测试妹子与一个很机灵的程序猿"><a href="#异步非阻塞：一个很机灵的测试妹子与一个很机灵的程序猿" class="headerlink" title="异步非阻塞：一个很机灵的测试妹子与一个很机灵的程序猿"></a>异步非阻塞：一个很机灵的测试妹子与一个很机灵的程序猿</h3><p>  过程：当调用方发起调用时，被调者收到调用通知后，立即返回给调用者，告诉它可以接到调用通知了，然后调用者去开始其他任务（<strong>注意：调用在这里已经结束了</strong>），而被调用者在完成调用任务得到处理结果后，通过通知的形式告诉调用方。</p><p>  例子：<strong>一个很机灵的妹子，在发现了bug后，找到了机灵的程序猿，说：”帅哥，你这里有bug”，程序猿知道后说：“好的，这里交给我，你先去忙别的吧！”。然后妹子就去忙别的事了，程序猿就开始debug，在修复完bug后，发了封邮件通知测试妹子</strong>。（于是他们两个就在一起了O(∩_∩)O）</p><p>  <img src="http://opobbao46.bkt.clouddn.com/%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.jpg"></p><h2 id="撒花w-w"><a href="#撒花w-w" class="headerlink" title="撒花w_w"></a>撒花w_w</h2><p>  通过我上面的举例，大家应该知道哪对会修成正果吧？没错就是异步非阻塞，还有同步阻塞。<strong>异步非阻塞合理的利用了cpu的空闲时间，不让干等，大大提高了工作效率，在处理并行中十分常用</strong>。而同步阻塞，虽然这两个都奇葩，但是这两个奇葩在一起也好过剩下更加两对搭配，算是中规中矩吧。所以目前大多的应用要么就采用异步非阻塞，要么就采用同步阻塞，剩下两对因为不太科学，所以少人用～</p><p>  通过这样搞笑的解析，大家应该都明白了吧？不明白的话，多看几次例子以及概念图！！过几天我发一篇关于机智程序猿如何发邮件给测试妹子(被调用者通知调用者)的博客</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>  <a href="http://blog.csdn.net/xxxxxx91116/article/details/51233785" target="_blank" rel="external">概念图来源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信刚入门计算机科学的小伙伴们来说，这四个词–异步，同步，阻塞，非阻塞，直接搞晕，因为单单理解四个词就算了，他们还能组合，同步阻塞，同步非阻塞，异步阻塞，异步非阻塞+_+。因此今天就主要谈谈这几个词，顺便备个份，怕是我哪一天忘记了回来看看2333333&lt;/p&gt;
&lt;p&gt;首先，
      
    
    </summary>
    
      <category term="操作系统" scheme="https://dawnki.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="同步阻塞" scheme="https://dawnki.github.io/tags/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E/"/>
    
      <category term="异步非阻塞" scheme="https://dawnki.github.io/tags/%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    
      <category term="并行技术" scheme="https://dawnki.github.io/tags/%E5%B9%B6%E8%A1%8C%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>JWT-Auth&amp;Laravel-Auth源码浅读</title>
    <link href="https://dawnki.github.io/2017/07/29/JWT-Auth&amp;Laravel-Auth%E6%BA%90%E7%A0%81%E6%B5%85%E8%AF%BB/"/>
    <id>https://dawnki.github.io/2017/07/29/JWT-Auth&amp;Laravel-Auth源码浅读/</id>
    <published>2017-07-28T17:04:12.000Z</published>
    <updated>2017-07-31T17:32:08.443Z</updated>
    
    <content type="html"><![CDATA[<p>故事发生月黑风高的…..啊呸，扯题了。简单来说前几天在配置JWT-Auth的时候，因为自己建的用户表没有用国际标准的’password’字段，而是自己随便起了个userPassword，导致不是在挖坑就是在挖坑的路上.不得不阅读其源码解决问题。</p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>不过结构复杂的Laravel，里面运用了许多魔术方法及其核心的Ioc容器，阅读前拿到以下几种工具才好动手:</p><ul><li>读一下Laravel作者的<a href="https://my.oschina.net/zgldh/blog/389246" target="_blank" rel="external">From Apprentice To Artisan(感谢中文翻译者)</a> ，宛如laravel中的<strong>行动纲领</strong></li><li>Laravel自带helper函数dd(),用于单步调试，运行完立即退出脚本，方便知道某个方法究竟有没有执行或者取值是什么</li><li>phpstorm ，虽然遇到Laravel一片黄，不过能查到追踪到多少代码算多少，O(∩_∩)O哈哈~</li><li>遇到某个类中有依赖注入的，二话不说先找其服务提供者，看看服务提供者的注册方法中将注入的接口(Contract)绑定的是哪个类,为了方便解释，先来个例子~</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> $test;</div><div class="line"></div><div class="line">    <span class="comment">// 这个Test不是一个接口算我输</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Test $test)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;test=$test;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上文注入的Test，用phpstorm的ctrl+b追踪到的肯定是个接口.那么实际传给这个构造方法的实例是什么呢？在这个类附近找找provider字眼的类不会太远(看起来不太靠谱但是却有效,哈哈哈)，或者去/config/app.php里面找找</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//假装我找到了对应的provider</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestServiceProvider</span> <span class="keyword">extends</span> <span class="title">ServiceProvider</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">//关键是找register的内容</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;app-&gt;bind(<span class="string">'Test'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="comment">// 假装有个叫做TestImplemet的类实现了上文的Test接口</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TestImplement();</div><div class="line">            &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>上文register方法里的bind,都是Laravel的Ioc容器(控制反转容器)的骚操作,简单地理解是Laravel帮你管理类实例,管理他们的生命周期,不用你到处new来new去,耦合代码,<strong>目的是彻底模块化,一个类只负责自己的东西,自己类里尽量不new别模块的类。</strong> 就是作者所说的严守类的边界(<strong>Respect Boundaries</strong>)</p></blockquote><p>回归正题原来往A类里注入的是TestImplement类的实例,原来似李啊TestImplement,赶紧给我负责吖混蛋！(感觉污污的..Orz)</p><p>所以基本方针就这样，掌握了工具之后，就开始填坑吧！</p><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>  环境：Laravel5.2<br>  依赖: JWT-Auth 1.0.0-beta.3</p><p>  当我使用了JWT-Auth之后，由于模型里的密码字段是adminPass，在注册好服务提供者，做好各种配置之后，使用JWTAuth::attempt()方法验证账号密码时，我填入的数组是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &quot;phone&quot; =&gt; &apos;xxxxxx&apos;,     // 此处充当账号</div><div class="line">    &quot;adminPass&quot; =&gt; &apos;xxxxxx&apos;</div><div class="line">]</div></pre></td></tr></table></figure><p>  然后attempt方法一直返回false，按照常理账号密码没有错的话，jwt会自动生成token返回，在确认其他配置没问题的情况下，只能硬着头皮去翻源码，逐步测试。</p><h2 id="一步一步溯源"><a href="#一步一步溯源" class="headerlink" title="一步一步溯源"></a>一步一步溯源</h2><h3 id="根据attempt线索追踪根源"><a href="#根据attempt线索追踪根源" class="headerlink" title="根据attempt线索追踪根源"></a>根据attempt线索追踪根源</h3><p>  因为使用了先找出JWTAuth::attempt()所在的类.由于此处使用了JWTAuth的门面，我们先去JWTAuth里面看看它要拿的是哪个类</p><blockquote><p>Laravel的门面其实就是为服务类提供”静态”接口，看似我们不需要实例化对象，然后再用A::method()这样的类似静态方法的方式调用服务类的方法。其实质是laravel从用户的门面调用方法中，拿到用户的要调用的方法以及参数，然后从Ioc容器里拿到对应的服务类实例，然后使用php灵活的回调函数，让这个实例执行用户填入的方法及其参数，具体的源码分析会在之后浅读一蛤然后再写篇博客(挖坑)</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JWTAuth</span> <span class="keyword">extends</span> <span class="title">Facade</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Get the registered name of the component.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getFacadeAccessor</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">//经过Facade(门面)一系列操作，向Ioc容器中拿出注册名叫tymon.jwt.auth的实例</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'tymon.jwt.auth'</span>;   </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>耐心地找到Tymon\JWTAuth\Providers\AbstractServiceProvider，找到以下注册信息</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Register the bindings for the main JWTAuth class.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerJWTAuth</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'tymon.jwt.auth'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($app)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JWTAuth(</div><div class="line">            $app[<span class="string">'tymon.jwt.manager'</span>],</div><div class="line">            $app[<span class="string">'tymon.jwt.provider.auth'</span>],</div><div class="line">            $app[<span class="string">'tymon.jwt.parser'</span>]</div><div class="line">        );</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>翻翻Tymon\JWTAuth的目录，所以门面拿到的实例就是Tymon\JWTAuth\JWTAuth.php</p><p>诚不欺我，果然JWTAuth.php 有attempt方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Attempt to authenticate the user and return the token.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  array  $credentials</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> false|string</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attempt</span><span class="params">(array $credentials)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (! <span class="keyword">$this</span>-&gt;auth-&gt;byCredentials($credentials)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;fromUser(<span class="keyword">$this</span>-&gt;user());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="侦查手段（套路）"><a href="#侦查手段（套路）" class="headerlink" title="侦查手段（套路）"></a>侦查手段（套路）</h3><p>$credentials数组就是我们问题里传入验证数组，验证数组又传给了$this-&gt;auth-&gt;byCredentials($credentials)，这个方法，相信大家已经知道套路了吧？没错他这个JWTAuth又注入了一个类实例来执行byCredentials方法，所以执行我们的套路</p><ol><li>先翻一下构造器，注入的是什么接口</li><li>然后找找附近的provider，给这个接口绑定的是什么类实例</li><li><p>找到类实例，就是实际注入JWTAuth类的实例</p><p>所以通过一顿操作,JWTAuth.php的构造器如下</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@var</span> \Tymon\JWTAuth\Contracts\Providers\Auth</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">protected</span> $auth;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  \Tymon\JWTAuth\Manager  $manager</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  \Tymon\JWTAuth\Contracts\Providers\Auth  $auth</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  \Tymon\JWTAuth\Http\Parser\Parser  $parser</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Manager $manager, Auth $auth, Parser $parser)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">parent</span>::__construct($manager, $parser);</div><div class="line">    <span class="keyword">$this</span>-&gt;auth = $auth;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以锁定\Tymon\JWTAuth\Contracts\Providers\Auth，继续翻AbstractServiceProvider</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerAliases</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;alias(<span class="string">'tymon.jwt'</span>, JWT::class);</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;alias(<span class="string">'tymon.jwt.auth'</span>, JWTAuth::class);</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;alias(<span class="string">'tymon.jwt.provider.jwt'</span>, JWTContract::class);</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;alias(<span class="string">'tymon.jwt.provider.auth'</span>, Auth::class);</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;alias(<span class="string">'tymon.jwt.provider.storage'</span>, Storage::class);</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;alias(<span class="string">'tymon.jwt.manager'</span>, Manager::class);</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;alias(<span class="string">'tymon.jwt.blacklist'</span>, Blacklist::class);</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;alias(<span class="string">'tymon.jwt.payload.factory'</span>, Factory::class);</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;alias(<span class="string">'tymon.jwt.validators.payload'</span>, PayloadValidator::class);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerAuthProvider</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'tymon.jwt.provider.auth'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getConfigInstance(<span class="string">'providers.auth'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getConfigInstance</span><span class="params">($key)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    $instance = <span class="keyword">$this</span>-&gt;config($key);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (is_string($instance)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;app-&gt;make($instance);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> $instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">config</span><span class="params">($key, $default = null)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> config(<span class="string">"jwt.$key"</span>, $default);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 此方法在helper中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">config</span><span class="params">($key = null, $default = null)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (is_null($key)) &#123;</div><div class="line">        <span class="keyword">return</span> app(<span class="string">'config'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (is_array($key)) &#123;</div><div class="line">        <span class="keyword">return</span> app(<span class="string">'config'</span>)-&gt;set($key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> app(<span class="string">'config'</span>)-&gt;get($key, $default);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面一连串貌似很复杂，其实就是\Tymon\JWTAuth\Contracts\Providers\Auth::class起个别名叫做tymon.jwt.provider.auth，然后registerAuthProvider方法就是正式的绑定方法，通过一连串操作，最终是从/config/jwt.php(如果没用publish命令的，则访问tymon目录里的config) 拿出providers键名里，auth键名的东西</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//就是Tymon\JWTAuth\Providers\Auth\Illuminate::class</span></div><div class="line"><span class="string">'providers'</span> =&gt; [</div><div class="line"></div><div class="line">        <span class="string">'jwt'</span> =&gt; Tymon\JWTAuth\Providers\JWT\Namshi::class,</div><div class="line"></div><div class="line">        <span class="string">'auth'</span> =&gt; Tymon\JWTAuth\Providers\Auth\Illuminate::class,</div><div class="line"></div><div class="line">        <span class="string">'storage'</span> =&gt; Tymon\JWTAuth\Providers\Storage\Illuminate::class,</div><div class="line"></div><div class="line">    ]</div></pre></td></tr></table></figure><blockquote><p>laravel自带的helper中的config十分实用，一般我们开发是都是把配置数据以数组形式存入/config/脚本里，然后用config函数来通过键名(通常写法是xxxx.xxx.xx)读取对应的值</p></blockquote><p>所以回到我们的目的attempt需要注入的auth，而注入的auth实际是Tymon\JWTAuth\Providers\Auth\Illuminate::class，同样的套路，里面的byCredentials方法里面注入了\Illuminate\Contracts\Auth\Guard，这个接口是属于Laravel的，而不是JWT内部的，这就是为什么JWT-auth切合了Laravel自带的Auth的原因，然后通过AbstractServiceProvider，我们可以知道，<strong>Laravel注册了自己的Auth时会翻一下配置文件/config/auth.php，然后根据guard里的driver来选择验证驱动，这就是为什么配置JWT-auth时需要配置/config/auth.php的原因</strong></p><h3 id="举一反三，找出罪魁祸首"><a href="#举一反三，找出罪魁祸首" class="headerlink" title="举一反三，找出罪魁祸首"></a>举一反三，找出罪魁祸首</h3><p>选择jwt作为guard驱动时，根据上面一流程的套路，就可以发现JWTAuth里面用到的byCredentials方法来自于JWTGuard，然后JWTGuard属于Laravel的拓展Guard，也是使用Laravel的一些功能，例如EloquentUserProvider,这个就是将我们的传入的数组与数据作对比的服务提供类,用到这两个方法retrieveByCredentials,validateCredentials</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//EloquentUserProvider.php</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">retrieveByCredentials</span><span class="params">(array $credentials)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($credentials)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        $query = <span class="keyword">$this</span>-&gt;createModel()-&gt;newQuery();</div><div class="line"></div><div class="line">        <span class="keyword">foreach</span> ($credentials <span class="keyword">as</span> $key =&gt; $value) &#123;</div><div class="line">            <span class="keyword">if</span> (! Str::contains($key, <span class="string">'password'</span>)) &#123;</div><div class="line">                $query-&gt;where($key, $value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> $query-&gt;first();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validateCredentials</span><span class="params">(UserContract $user, array $credentials)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        $plain = $credentials[<span class="string">'password'</span>];</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasher-&gt;check($plain, $user-&gt;getAuthPassword());</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>介绍下这两个方法的作用:</p><ul><li>retrieveByCredentials,通过验证数组，查询数据库(查询条件除去password)</li><li>validateCredentials,拿到的数据与验证数组作对比，包括密码，当然密码是使用hash的check方法来检查的</li></ul><h3 id="结案陈词"><a href="#结案陈词" class="headerlink" title="结案陈词"></a>结案陈词</h3><p>可见validateCredentials方法里$credentials[‘password’]这里就是限定我们attempt一定填入password字段名的原因，不填入这个字段名会报password index not found的异常，至于我传入的[‘phone’=&gt;’xxx’,’adminPass’=&gt;’xxxx’],没有报异常，是因为上面的retrieveByCredentials方法，正常会把非’password’字段纳入查询，所以把adminPass，导致方法返回false，导致于下面的validateCredentials方法因主调方(没记错的话主调方是JWTGuard里的attempt方法)的条件控制而进入不了，因而不报异常，直接返回false</p><h2 id="总结-amp-收获"><a href="#总结-amp-收获" class="headerlink" title="总结&amp;收获"></a>总结&amp;收获</h2><p>通过这次阅读，让我接触到了laravel的核心部分，服务提供者，依赖注入等等，以及大概了解了laravel自带的权限认证时怎样的。其内部十分复杂，突出的一点是子模块特别的多！其实这体现了Laravel作者Taylor Otwell的设计理念，严守边界，一个类只实现自己的东西，绝不干涉其他类，以及利用了大量的面向接口编程，这种松耦合在开发拓展(遵循开放封闭原则)的时候，也能易于维护。唯一的缺点感觉就是不易于快速入门了，需要慢慢翻看。<strong>总的来说耐心是第一要务，没有耐心研究，什么都白谈~</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;故事发生月黑风高的…..啊呸，扯题了。简单来说前几天在配置JWT-Auth的时候，因为自己建的用户表没有用国际标准的’password’字段，而是自己随便起了个userPassword，导致不是在挖坑就是在挖坑的路上.不得不阅读其源码解决问题。&lt;/p&gt;
&lt;h2 id=&quot;前置
      
    
    </summary>
    
      <category term="PHP" scheme="https://dawnki.github.io/categories/PHP/"/>
    
    
      <category term="Laravel" scheme="https://dawnki.github.io/tags/Laravel/"/>
    
      <category term="JWT-Auth" scheme="https://dawnki.github.io/tags/JWT-Auth/"/>
    
      <category term="源码阅读" scheme="https://dawnki.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Laravel中应用JWT</title>
    <link href="https://dawnki.github.io/2017/07/27/JWT/"/>
    <id>https://dawnki.github.io/2017/07/27/JWT/</id>
    <published>2017-07-26T16:15:22.000Z</published>
    <updated>2017-07-29T16:50:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>JWT-Json Web Token，一种基于json格式的开放标准，常常被用作替代cookie的认证方式，特别适合前后端分离的WEB应用，以及api接口。今天就讲讲如何在Laravel应用中使用JWT，虽然网上找到的Laravel集成JWT的方法，不过要么就坑点太多，要么就有诸多限制（比如要验证的模型有多个怎么配置）。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>Laravel 5.2+</li><li>PHP 5.5+</li><li>tymon/jwt-auth 1.0.0-beta.3  (十分重要)</li></ul><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><h3 id="利用composer安装jwt-atuh"><a href="#利用composer安装jwt-atuh" class="headerlink" title="利用composer安装jwt-atuh"></a>利用composer安装jwt-atuh</h3><p>  在你的Laravel项目目录里composer.json补充上以下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"required"</span> : &#123;</div><div class="line">    <span class="attr">"tymon/jwt-auth"</span> : <span class="string">"1.0.0-beta.3"</span>  # 这个版本很急很关键，我用这个版本才能跑通..Orz</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  然后安装一下依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> composer update</div></pre></td></tr></table></figure><hr><h3 id="配置Laravel的服务提供者及其门面"><a href="#配置Laravel的服务提供者及其门面" class="headerlink" title="配置Laravel的服务提供者及其门面"></a>配置Laravel的服务提供者及其门面</h3><p>  在/config/app.php里找到对应的数组，补充以下东西</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">'providers'</span> =&gt; [</div><div class="line">  Tymon\JWTAuth\Providers\LaravelServiceProvider::class,</div><div class="line">]</div><div class="line"></div><div class="line"><span class="string">'aliases'</span> =&gt; [</div><div class="line">  <span class="string">'JWTAuth'</span>   =&gt; Tymon\JWTAuth\Facades\JWTFactory::class,</div><div class="line">]</div></pre></td></tr></table></figure><hr><h3 id="配置你的用户表（用户模型）"><a href="#配置你的用户表（用户模型）" class="headerlink" title="配置你的用户表（用户模型）"></a>配置你的用户表（用户模型）</h3><p>  因为Jwt-auth默认用的是Laravel的auth权限管理，Laravel 的权限管理默认用的是项目一开始就有的User模型(/app/User.php)，下面姑且先用着Laravel的User模型为例，至于如何自定义用户模型使用其他表，我待会再讲</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">App</span>;</div><div class="line"></div><div class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Auth</span>\<span class="title">User</span> <span class="title">as</span> <span class="title">Authenticatable</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Contracts</span>\<span class="title">JWTSubject</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Authenticatable</span> <span class="keyword">implements</span> <span class="title">JWTSubject</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">protected</span> $fillable = [</div><div class="line"><span class="string">'name'</span>, <span class="string">'email'</span>, <span class="string">'password'</span>,</div><div class="line">];</div><div class="line"></div><div class="line"><span class="keyword">protected</span> $hidden = [</div><div class="line"><span class="string">'password'</span>, <span class="string">'remember_token'</span>,</div><div class="line">];</div><div class="line"></div><div class="line">  <span class="comment">//  JWT-Auth默认要实现的方法</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTIdentifier</span><span class="params">()</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getKey();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// JWT-Auth默认要实现的方法</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTCustomClaims</span><span class="params">()</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">  <span class="keyword">return</span> [];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  可见，配置用户表只需继承Illuminate\Foundation\Auth\User这个类，实现JWTSubject这个接口的两个方法即可。<strong>不过这个表必须要有password这个字段，必须有主键,</strong> 至于如果你的用户表不用password而是用userPass等等自己自定义的字段名怎么办，这个我待会再讲~</p><hr><h3 id="配置Laravel的auth"><a href="#配置Laravel的auth" class="headerlink" title="配置Laravel的auth"></a>配置Laravel的auth</h3><p>  /config/auth.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="string">'defaults'</span> =&gt; [</div><div class="line">  <span class="string">'guard'</span> =&gt; <span class="string">'api'</span>,    <span class="comment">// 此处改成api</span></div><div class="line">  <span class="string">'passwords'</span> =&gt; <span class="string">'users'</span>,</div><div class="line">],</div><div class="line"></div><div class="line"><span class="string">'guards'</span> =&gt; [</div><div class="line">  <span class="string">'web'</span> =&gt; [</div><div class="line">    <span class="string">'driver'</span> =&gt; <span class="string">'session'</span>,</div><div class="line">    <span class="string">'provider'</span> =&gt; <span class="string">'users'</span>,</div><div class="line">  ],</div><div class="line">  <span class="string">'api'</span> =&gt; [</div><div class="line">    <span class="string">'driver'</span> =&gt; <span class="string">'jwt'</span>,  <span class="comment">// 此处改成jwt</span></div><div class="line">    <span class="string">'provider'</span> =&gt; <span class="string">'users'</span>,</div><div class="line">  ],</div><div class="line">],</div><div class="line"></div><div class="line"><span class="string">'providers'</span> =&gt; [</div><div class="line">  <span class="string">'users'</span> =&gt; [</div><div class="line">    <span class="string">'driver'</span> =&gt; <span class="string">'eloquent'</span>,</div><div class="line">    <span class="string">'model'</span> =&gt; App\User::class,  <span class="comment">//你实际用到的用户表(用户模型)</span></div><div class="line">],</div><div class="line"></div><div class="line"><span class="comment">// 'users' =&gt; [</span></div><div class="line"><span class="comment">//     'driver' =&gt; 'database',</span></div><div class="line"><span class="comment">//     'table' =&gt; 'users',</span></div><div class="line"><span class="comment">// ],</span></div><div class="line">],</div></pre></td></tr></table></figure><hr><h3 id="生成JWT密钥"><a href="#生成JWT密钥" class="headerlink" title="生成JWT密钥"></a>生成JWT密钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> php artisan vendor:publish  # 将jwt的配置文件自动拉到/config目录</div><div class="line"><span class="meta">$</span> php artisan jwt:secret  # 自动生成JWT密钥，具体可看.env文件</div></pre></td></tr></table></figure><hr><h3 id="实际业务逻辑"><a href="#实际业务逻辑" class="headerlink" title="实际业务逻辑"></a>实际业务逻辑</h3><p>  可以直接在你的控制器里进行调试</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>;</div><div class="line"></div><div class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Auth</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Facades</span>\<span class="title">JWTAuth</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line"><span class="comment">     *  注册</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        User::create([</div><div class="line">            <span class="string">'name'</span> =&gt; <span class="string">'Dawnki'</span>,</div><div class="line">            <span class="string">'phone'</span> =&gt; <span class="string">'188xxxxxx'</span>,        <span class="comment">//此处例子假设以手机为账号</span></div><div class="line">            <span class="string">'password'</span> =&gt; bcrypt(<span class="string">'123456'</span>)  <span class="comment">//加密务必用Laravel中hepler提供的bcrypt</span></div><div class="line">        ]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  登录</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> Request $request</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(Request $request)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">//attempt方法用于验证帐号信息 成功则生成token值</span></div><div class="line">        <span class="comment">//attempt必须有"password"字段，无论你是自定义密码字段</span></div><div class="line">        $token = JWTAuth::attempt([<span class="string">'phone'</span>=&gt;<span class="string">'188xxxxxx'</span>,<span class="string">'password'</span>=&gt;<span class="number">123456</span>]);</div><div class="line">        <span class="keyword">return</span> response(json_encode([<span class="string">'token'</span>=&gt;$token]),<span class="number">200</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 访问内部页面</span></div><div class="line"><span class="comment">     * 附上Header "Authorization" : "Bearer token值" 注意Bearer与token值间的空格</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> Request $request</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">(Request $request)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="comment">//return Auth::id();  //直接获取用户id</span></div><div class="line">        <span class="keyword">return</span> Auth::guard(<span class="string">'api'</span>)-&gt;user();  <span class="comment">//直接获取用户model</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h3 id="给index方法（即实际业务里的内部需要登陆后才能访问的接口）编写一个中间件"><a href="#给index方法（即实际业务里的内部需要登陆后才能访问的接口）编写一个中间件" class="headerlink" title="给index方法（即实际业务里的内部需要登陆后才能访问的接口）编写一个中间件"></a>给index方法（即实际业务里的内部需要登陆后才能访问的接口）编写一个中间件</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Middleware</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Closure</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Auth</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Class UserMiddleware 用户中间件</span></div><div class="line"><span class="comment"> * <span class="doctag">@package</span> App\Http\Middleware</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserMiddleware</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">protected</span> $auth;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Auth $auth)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;auth = $auth;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Handle an incoming request.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span>  \Illuminate\Http\Request $request</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span>  \Closure $next</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($request, Closure $next, $guard = <span class="string">'api'</span>)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!($user = Auth::guard($guard)-&gt;user())) &#123;</div><div class="line">            <span class="comment">// token值不对 根据实际情况编写返回错误信息,此处返回只作样例</span></div><div class="line">            <span class="keyword">return</span> response(<span class="string">'token'</span>,<span class="number">403</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> $next($request);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  此处只显示中间件的关键方法，至于如何给内部接口（如上例中的index方法）配置中间件自行解决，关键的验证即是 Auth::guard(‘api’)-&gt;user();<br>  当前端把Token值放入Header中， 即 “Authorization” : “Bearer token值”（<strong>注意Bearer与token值中的空格</strong>）. Jwt-Auth结合了Laravel的Auth就会通过user()方法<strong>自动从Header中取出token值</strong>，并且从中解密找出隐含在其中的用户摘要(id).</p><blockquote><p>注意坑点:用户表的加密方式 <strong>务必使用bcrypt(即哈希加密)</strong>,不要使用Crypt门面提供的加密，不要使用Crypt门面提供的加密，不要使用Crypt门面提供的加密!Crypt的加密不适合数据库迁移!</p></blockquote><h2 id="自定义你的用户模型"><a href="#自定义你的用户模型" class="headerlink" title="自定义你的用户模型"></a>自定义你的用户模型</h2><h3 id="首先自定义用户模型，不使用自带的User模型"><a href="#首先自定义用户模型，不使用自带的User模型" class="headerlink" title="首先自定义用户模型，不使用自带的User模型"></a>首先自定义用户模型，不使用自带的User模型</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">App</span>;</div><div class="line"></div><div class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Auth</span>\<span class="title">User</span>;</div><div class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Contracts</span>\<span class="title">JWTSubject</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">JWTSubject</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">protected</span> $table=<span class="string">"admin"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> $primaryKey=<span class="string">"admin_id"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> $fillable=[<span class="string">"admin_name"</span>,<span class="string">"adminPass"</span>];</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> $guarded=<span class="string">''</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> $hidden=[<span class="string">"adminPass"</span>];</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTIdentifier</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getKey();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTCustomClaims</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> [];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    *  重写的方法</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAuthPassword</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getAttribute(<span class="string">'adminPass'</span>);  <span class="comment"># 表中密码字段是adminPass</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  如上，只需继承User,实现JWTSubject。另外如果你表密码字段不是password，而是其他（如上的adminPass）,只需重写getAuthPassword方法(来自于Illuminate\Foundation\Auth\User中用到的trait)即可</p><p>  然后在/config/auth.php中修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">    &apos;providers&apos; =&gt; [</div><div class="line">    &apos;users&apos; =&gt; [</div><div class="line">    &apos;driver&apos; =&gt; &apos;eloquent&apos;,</div><div class="line">    &apos;model&apos; =&gt; App\Admin::class,  //你需要的类</div><div class="line">    ]</div></pre></td></tr></table></figure><p>  然后你就可以使用自己编写的用户模型,又能搭配上JWT了!</p><p>  另外此处有一个坑点就是你自定义的密码字段， <strong>在attempt验证账号登陆时是要注意一些细节</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     *  登录</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> Request $request</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(Request $request)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        $token = JWTAuth::attempt([<span class="string">'phone'</span>=&gt;<span class="string">'188xxxxxx'</span>,<span class="string">'password'</span>=&gt;<span class="number">123456</span>]);</div><div class="line">        <span class="keyword">return</span> response(json_encode([<span class="string">'token'</span>=&gt;$token]),<span class="number">200</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><blockquote><p>上例，我自定义的密码字段为adminPass，在调用attempt时，不要顺理成章的在验证数组里使用adminPass，<strong>依然是使用’password’</strong>，这是由于attempt方法内部的限定，在下一篇博客将详细介绍为何要这样~~如果你表里的字段是password的那就没你的事啦，此处只针对自定义的密码字段名</p></blockquote><hr><h3 id="使用两个以上需要权限认证的表"><a href="#使用两个以上需要权限认证的表" class="headerlink" title="使用两个以上需要权限认证的表"></a>使用两个以上需要权限认证的表</h3><p>  比如一个系统中，有管理员和普通用户，他们分别存在两张不同的表(模型)</p><p>  只需使用上 <strong>Config方法动态修改auth.php的model</strong> 即可</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">adminLogin</span><span class="params">(Request $request)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    Config::set(<span class="string">'auth.providers.users.model'</span>,\App\Admin::class); <span class="comment">#对应管理员表</span></div><div class="line">    <span class="comment">// Todo your admin login method</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">userLogin</span><span class="params">(Request $request)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    Config::set(<span class="string">'auth.providers.users.model'</span>,\App\User::class);  <span class="comment">#对应用户表</span></div><div class="line">    <span class="comment">// Todo your user login method</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  刚开始没看Jwt-auth的源码时，配置起来真的很累，用了各种版本都不，最终发现1.0.0-beta.3可以，又根据github里面的issue，找遍了各种自定义方法加上自己琢磨了一下，才能使得根据自己项目的业务需求尽心修改，当中算是了解了jwt-auth是如何跟laravel自带的auth结合在一起的，收获还算可以。</p><p>  最后附上<a href="https://github.com/tymondesigns/jwt-auth" target="_blank" rel="external">tymon大大的github</a>,虽然被他的拓展折磨的很惨，不过十分感谢大大的贡献.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JWT-Json Web Token，一种基于json格式的开放标准，常常被用作替代cookie的认证方式，特别适合前后端分离的WEB应用，以及api接口。今天就讲讲如何在Laravel应用中使用JWT，虽然网上找到的Laravel集成JWT的方法，不过要么就坑点太多，要么
      
    
    </summary>
    
      <category term="PHP" scheme="https://dawnki.github.io/categories/PHP/"/>
    
    
      <category term="Laravel" scheme="https://dawnki.github.io/tags/Laravel/"/>
    
      <category term="JWT" scheme="https://dawnki.github.io/tags/JWT/"/>
    
      <category term="Tymon/jwt-auth" scheme="https://dawnki.github.io/tags/Tymon-jwt-auth/"/>
    
  </entry>
  
  <entry>
    <title>Laravel的数据填充Seeder食用方法</title>
    <link href="https://dawnki.github.io/2017/07/19/Seeder/"/>
    <id>https://dawnki.github.io/2017/07/19/Seeder/</id>
    <published>2017-07-18T17:49:47.000Z</published>
    <updated>2017-09-14T13:02:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，经常需要往数据库里填充数据，以便调试接口<del>发现bug</del>。Laravel自带的数据填充器seeder也十分好用，纯自动化填充，还支持一键回滚，只需在使用之前定义些方法即可，下面就介绍一下seeder普遍的用法。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>  Laravel 5.2</p><h2 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h2><ol><li>生成Seeder填充类</li><li>按实际情况定义模型工厂</li><li>执行artisan命令自动化填充数据到数据库</li><li>回滚，恢复到实际生产环境</li></ol><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>首先利用artisan命令创建一个seeder类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> php artisan make:seeder TestSeeder</div></pre></td></tr></table></figure><p>在/database/seeds/中，编写run方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSeeder</span> <span class="keyword">extends</span> <span class="title">Seeder</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        DB::table(<span class="string">'YourTable'</span>)-&gt;insert([</div><div class="line">            <span class="string">'name'</span> =&gt; str_random(<span class="number">10</span>)</div><div class="line">        ]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上，只需把插入语句写进seeder类的run方法即可。上面的例子是往YourTable表里插入一条记录，但是这是我们日常都是大批量填充数据的，此时就需要用到模型工厂。</p><h3 id="一个模型单角色定义"><a href="#一个模型单角色定义" class="headerlink" title="一个模型单角色定义"></a>一个模型单角色定义</h3><p>模型工厂的定义脚本在/database/factories/ModelFactory.php，我们只需脚本里定义好模型，然后就可以在seeder类里使用了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$factory-&gt;define(App\YourModel::class,<span class="function"><span class="keyword">function</span> <span class="params">(Faker\Generator $faker)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> [</div><div class="line">        <span class="string">'name'</span> =&gt; $faker-&gt;name,</div><div class="line">        <span class="string">'email'</span> =&gt; $faker-&gt;email,</div><div class="line">        <span class="string">'password'</span> =&gt; str_random(<span class="number">10</span>),</div><div class="line">        <span class="string">'remember_token'</span> =&gt; str_random(<span class="number">10</span>),</div><div class="line">        <span class="string">'admin'</span> =&gt; <span class="keyword">true</span>,</div><div class="line">    ];</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>Faker是专门生成假数据的包(<a href="https://github.com/fzaninotto/Faker" target="_blank" rel="external">GITHUB地址</a>),这样至少生成的假数据也好看点而不是一堆乱码数字对吧。</p><h3 id="一个模型多角色定义"><a href="#一个模型多角色定义" class="headerlink" title="一个模型多角色定义"></a>一个模型多角色定义</h3><p>除了用define字段定义模型外，我们常常还用到defineAs，因为通常一个模型(表)里面，存在这不同角色，比如User表里可以存在普通用户或者管理员两种角色，这时可以用defineAs</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$factory-&gt;defineAs(App\YourModel::class,<span class="string">'admin'</span>,<span class="function"><span class="keyword">function</span> <span class="params">(Faker\Generator $faker)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> [</div><div class="line">        <span class="comment">// blabla 按实际情况编写</span></div><div class="line">        <span class="string">'name'</span> =&gt; $faker-&gt;name,</div><div class="line">        <span class="string">'email'</span> =&gt; $faker-&gt;email,</div><div class="line">        <span class="string">'password'</span> =&gt; str_random(<span class="number">10</span>),</div><div class="line">        <span class="string">'remember_token'</span> =&gt; str_random(<span class="number">10</span>),</div><div class="line">        <span class="string">'is_admin'</span> =&gt; <span class="keyword">true</span>,</div><div class="line">    ];</div><div class="line">&#125;);</div></pre></td></tr></table></figure><hr><h2 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h2><p>这样我们就定义好了一个模型工厂，要工厂生产产品就需要用到Laravel的全局函数factory.生产产品的工厂一定要是定义过的才能用factory函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以下写在seeder类的run方法里</span></div><div class="line"><span class="comment">// 生产1个模型实例</span></div><div class="line">$obj=$factory-&gt;(App\YourModel::class)-&gt;make();</div><div class="line"><span class="comment">// 生产5个模型实例 返回类型为collection</span></div><div class="line">$collection=$factory-&gt;(App\YourModel::class,<span class="number">5</span>)-&gt;make();</div><div class="line"><span class="comment">// 生产5个admin身份的模型实例</span></div><div class="line">$collection=$factory-&gt;(App\YourModel::class,<span class="string">'admin'</span>,<span class="number">5</span>)-&gt;make();</div></pre></td></tr></table></figure><hr><h2 id="处理关联"><a href="#处理关联" class="headerlink" title="处理关联"></a>处理关联</h2><p>数据库插入时也经常涉及关联，比如有两张表父表与子表，由于存在关联关系，设置了外键约束时，填充数据会很蛋疼，不过利用Laravel的eloquent使得填充数据十分方便，下面就讲一下如何操作</p><p>首先假设有两张表father和son，其中son的主键参照father表中的一个字段id</p><p>father的模型：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span> <span class="keyword">extends</span> <span class="title">Model</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="comment">// Laravel 的模型关联方法 不清楚的可以补一下文档</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasMany(\App\son:<span class="class"><span class="keyword">class</span>,'<span class="title">id</span>');</span></div><div class="line"><span class="class">  &#125;</span></div><div class="line"><span class="class">&#125;</span></div></pre></td></tr></table></figure><p>son的模型细节我就忽略了，因为不是重点。接下来就要定义两个表的模型工厂</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$factory-&gt;define(App\father::class,<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> [</div><div class="line">      <span class="comment">//blabla</span></div><div class="line">   ] ;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$factory-&gt;define(App\father::class,<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> [</div><div class="line">      <span class="comment">//blabla</span></div><div class="line">   ] ;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>然后就可以在seeder类的run方法里使用了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">factory(App\father::class,<span class="number">3</span>)</div><div class="line">    -&gt;create()</div><div class="line">    -&gt;each(<span class="function"><span class="keyword">function</span> <span class="params">($obj)</span></span>&#123;</div><div class="line">       $obj-&gt;test()-&gt;save(factory(App\son::class,<span class="number">2</span>)-&gt;make());</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><p>就可以在你填充3个父亲的数据的同时，也为每个父亲填充2个与之关联的儿子</p><hr><h2 id="填充器模块化"><a href="#填充器模块化" class="headerlink" title="填充器模块化"></a>填充器模块化</h2><p>一个填充器写N多个factory来填充数据，难免会看晕，因此我们需要将负责不同模型的生产分模块，划分成N多个子填充器</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">  Model::unguard();</div><div class="line">  <span class="keyword">$this</span>-&gt;call(Test1Seeder::class);</div><div class="line">  <span class="keyword">$this</span>-&gt;call(Test2Seeder::class);</div><div class="line">  <span class="comment">// .......</span></div><div class="line">  Model::reguard();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>unguard函数貌似是关闭自动填充的限制，reguard是恢复限制.还有一个函数<br>Model::truncate();用于放在成员函数里可以清空成员表数据，用来初始化填充还可以，不过有重要数据请备份。</p><hr><h2 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h2><p>在编写好seeder之后，运行artisan即可进行填充</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">php artisan db:seed</div><div class="line">php artisan db:seed --class=xxxxxSeeder // 你的填充类</div></pre></td></tr></table></figure><p>一键回滚，重建数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php artisan migrate:refresh --seed</div></pre></td></tr></table></figure><hr><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>因为运行artisan命令时本质上是用CLI，因此请开启proc_open,proc_get_status等系统调用函数，留意你的CLI所用的拓展是否有对应数据库的拓展，如果遇到CLI的坑可以去翻一些我前几天些的关于CLI的坑，遇到什么permission denied的给对应文件加上权限就好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在日常开发中，经常需要往数据库里填充数据，以便调试接口&lt;del&gt;发现bug&lt;/del&gt;。Laravel自带的数据填充器seeder也十分好用，纯自动化填充，还支持一键回滚，只需在使用之前定义些方法即可，下面就介绍一下seeder普遍的用法。&lt;/p&gt;
&lt;h2 id=&quot;版本&quot;&gt;
      
    
    </summary>
    
      <category term="PHP" scheme="https://dawnki.github.io/categories/PHP/"/>
    
    
      <category term="Laravel" scheme="https://dawnki.github.io/tags/Laravel/"/>
    
      <category term="Seeder" scheme="https://dawnki.github.io/tags/Seeder/"/>
    
      <category term="数据填充" scheme="https://dawnki.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85/"/>
    
  </entry>
  
  <entry>
    <title>Redis报错:MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk</title>
    <link href="https://dawnki.github.io/2017/07/16/Redis%E6%8A%A5%E9%94%99/"/>
    <id>https://dawnki.github.io/2017/07/16/Redis报错/</id>
    <published>2017-07-16T09:06:53.000Z</published>
    <updated>2017-07-16T09:11:54.554Z</updated>
    
    <content type="html"><![CDATA[<p>在捣鼓redis时，一次不小心关闭了强制关闭了redis-cli，导致下次启动cli,进行数据插入操作时报错了，具体错误如下:</p><pre><code>(error) MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.</code></pre><p>  在网上查了较多的资料最好的解决方式是启动redis-cli,然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> 127.0.0.1:6379&gt; config set stop-writes-on-bgsave-error no</div></pre></td></tr></table></figure><p>  然后就OK了~老哥这方法贼稳，哈哈哈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在捣鼓redis时，一次不小心关闭了强制关闭了redis-cli，导致下次启动cli,进行数据插入操作时报错了，具体错误如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(error) MISCONF Redis is configured to save RDB snapshots,
      
    
    </summary>
    
      <category term="服务器部署" scheme="https://dawnki.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="linux" scheme="https://dawnki.github.io/tags/linux/"/>
    
      <category term="Redis" scheme="https://dawnki.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境下Redis安装并配置PHP</title>
    <link href="https://dawnki.github.io/2017/07/16/redis%E5%AE%89%E8%A3%85/"/>
    <id>https://dawnki.github.io/2017/07/16/redis安装/</id>
    <published>2017-07-16T07:16:24.000Z</published>
    <updated>2017-07-16T09:03:22.306Z</updated>
    
    <content type="html"><![CDATA[<p>Redis作为一种高效的nosql数据库，常常被用作为缓存，本篇就讲一下关于Redis的安装配置，以及怎么应用到PHP项目当中。</p><h2 id="安装并配置Redis"><a href="#安装并配置Redis" class="headerlink" title="安装并配置Redis"></a>安装并配置Redis</h2><ul><li><p>下载官网<strong>最新且稳定</strong>的redis版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-4.0.0.tar.gz  # 此处安装的是redis4.0</div><div class="line">tar xzf redis-4.0.0.tar.gz # 解压下载完的压缩包</div><div class="line">cd redis-4.0.0 </div><div class="line">make  # 编译安装</div></pre></td></tr></table></figure><p>编译安装完之后，redis目录里会生成/src目录</p></li><li><p>下面是几个重要的文件路径</p><p>redis配置文件 /path/to/redis-xxx/redis.conf<br>redis服务端   /path/to/redis-xxx/src/redis-server<br>redis客户端   /path/to/redis-xxx/src/redis-cli</p></li><li><p>配置redis服务器守护进程</p><p>有时我们通过shell开启了redis-server之后，如果不把他放进守护进程就会一直占用我们的shell，因此需要把redis的服务端进程放进守护进程</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /path/to/redis-xxx/redis.conf</div></pre></td></tr></table></figure><p>  通过vi的/daemonize，找到守护进程的配置，把yes改为no保存退出即可.</p><p>  下次开启redis-server时需要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./redis-server ./../redis.conf # 即参数为配置文件的路径</div></pre></td></tr></table></figure><ul><li>也可以编写shell脚本redis-server,不用输入配置文件路径,随便找个地方放，不要放到src就行,具体如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">`/path/to/redis-xxx/src/redis-server /path/to/redis-xxx/redis.conf`</div></pre></td></tr></table></figure><p>  然后加上执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod +x redis-server  # 此处的redis-server为刚刚编写的脚本</div></pre></td></tr></table></figure><p>  为了方便shell里直接启动，把软连接放到/usr/local/bin里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln -s /path/to/your-script/redis-server /usr/local/bin # 刚写的脚本路径</div><div class="line">ln -s /path/to/redis-xxx/src/redis-cli /usr/local/bin  # 实际客户端的路径</div></pre></td></tr></table></figure><p> 这样即可在shell里开启带有守护的redis-server了，而不用输入配置文件路径参数，如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server</div></pre></td></tr></table></figure><h2 id="把Redis应用到PHP中"><a href="#把Redis应用到PHP中" class="headerlink" title="把Redis应用到PHP中"></a>把Redis应用到PHP中</h2><p>  PHP连接redis有两种途径，一种是用phpredis拓展，由c编写的php拓展，因此处理效率较高，不过不支持PHP5.2以下的版本。第二种是用predis，是一个php包，可以理解为PHP应用来连接redis，效率没有phpredis不过适应高，容易部署。由于我在踩phpredis的坑时中招了，下面就用predis吧，毕竟简单易用。</p><p>  我采用composer安装方式，在composer.json里附上</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"require"</span>: &#123;</div><div class="line">      <span class="attr">"predis/predis"</span>: <span class="string">"~1.1@dev"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  然后就可以用predis连接redis进行各种操作了,具体函数跟redis原生指令相差不大，在这就不多赘述</p><p>  可以安装<a href="https://github.com/ErikDubbelboer/phpRedisAdmin" target="_blank" rel="external">phpredisadmin</a>管理你的redis，开发环境可以用，生产的话还是算了吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis作为一种高效的nosql数据库，常常被用作为缓存，本篇就讲一下关于Redis的安装配置，以及怎么应用到PHP项目当中。&lt;/p&gt;
&lt;h2 id=&quot;安装并配置Redis&quot;&gt;&lt;a href=&quot;#安装并配置Redis&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="PHP" scheme="https://dawnki.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://dawnki.github.io/tags/PHP/"/>
    
      <category term="Laravel" scheme="https://dawnki.github.io/tags/Laravel/"/>
    
      <category term="Linux" scheme="https://dawnki.github.io/tags/Linux/"/>
    
      <category term="Redis" scheme="https://dawnki.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>那些年PHP-CLI踩过的坑</title>
    <link href="https://dawnki.github.io/2017/07/14/cli%E7%9A%84%E5%9D%91/"/>
    <id>https://dawnki.github.io/2017/07/14/cli的坑/</id>
    <published>2017-07-14T11:32:54.000Z</published>
    <updated>2017-07-14T17:20:32.722Z</updated>
    
    <content type="html"><![CDATA[<p>最近在捣鼓swoole以及phpunit时，需要用到PHP-CLI（PHP的命令行模式），可是却中途却一直出现问题，就以phpunit为例，在用到调试数据库的断言时，出现could not find driver，以及在捣鼓swoole时，使用了swoole的定义类缺找不到，最终原来发现PHP-CLI模式的拓展与PHP-FPM那边的拓展配置不一致导致的。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>  在填坑前先介绍下几个路径以及命令：</p><p>  /usr/local/php   通常是通过网页调用PHP脚本(FastCGI,FPM)时，php配置以及拓展放置的目录</p><p>  /usr/bin/  用户命令放置的地方，也是PHP-CLI调用php命令放置的地方</p><p>  php -m 查看CLI模式下加载的拓展以及模块</p><p>  在脚本中编写phpinfo();然后网页访问，可以查看网络调用脚本时加载的拓展和模块</p><p>  /etc/php 在某些情况下，PHP-CLI调用PHP脚本时，php配置以及拓展放置的目录，也是本文的<strong>罪魁祸首</strong></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>  在linux里安装多个PHP版本或者，安装过PHP7时有可能会出现CLI模式与普通模式(网页调用PHP脚本)配置以及模块不一致的情况，由于我是用LNMP安装的PHP7，之后有安装了PHPStorm，不知是不是乱搞的关系，导致CLI与普通模式加载配置不一致了，在折腾Swoole时就明显发现了这个问题。</p><p>  要知道模块是否加载一致，普通模式用phpinfo() ，命令行模式直接用php -m就可以查到模块是否一致了。</p><p>  若不一致时，绝大多是/usr/bin/php(大多是软连接)指向/etc/php/bin目录里的php</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -li 软链接文件  # 这样既可找到链接指向的源文件</div></pre></td></tr></table></figure><p>  要解决也是十分简单，只需把/usr/local/php/bin里面的php的软连接放到/usr/bin/里即可，注意要把之前/usr/bin/里的php删掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rm -rf /usr/bin/php</div><div class="line">ln -s /usr/lcoal/php/bin/php /usr/bin/php  # 软连接的两个参数都需写绝对路径</div></pre></td></tr></table></figure><p>  接着在命令行里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -m</div></pre></td></tr></table></figure><p>  即可发现CLI模式加载的模块就与普通模式保持一致了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在捣鼓swoole以及phpunit时，需要用到PHP-CLI（PHP的命令行模式），可是却中途却一直出现问题，就以phpunit为例，在用到调试数据库的断言时，出现could not find driver，以及在捣鼓swoole时，使用了swoole的定义类缺找不到
      
    
    </summary>
    
      <category term="PHP" scheme="https://dawnki.github.io/categories/PHP/"/>
    
    
      <category term="Linux" scheme="https://dawnki.github.io/tags/Linux/"/>
    
      <category term="PHP CLI" scheme="https://dawnki.github.io/tags/PHP-CLI/"/>
    
      <category term="Swoole" scheme="https://dawnki.github.io/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>PHP实现链式操作</title>
    <link href="https://dawnki.github.io/2017/07/06/%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C/"/>
    <id>https://dawnki.github.io/2017/07/06/链式操作/</id>
    <published>2017-07-06T13:11:32.000Z</published>
    <updated>2017-07-06T16:43:11.260Z</updated>
    
    <content type="html"><![CDATA[<p>玩耍过jQuery的朋友们应该对链式操作不陌生，链式操作在实际应用上不仅美观，并且代码容易阅读，下面用PHP简单实现下链式操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#Test"</span>).css(<span class="string">'color'</span>,<span class="string">'red'</span>).show(<span class="number">200</span>).removeClass(<span class="string">'style'</span>);  <span class="comment">//jquery中的链式操作</span></div></pre></td></tr></table></figure><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>  先贴一波代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> $name;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> $age;   <span class="comment"># 要改变的属性聚合在类中成为类属性</span></div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">cname</span><span class="params">($name)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;name=$name;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>;          <span class="comment"># 链式操作的关键 方法中返回对象自身</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">cage</span><span class="params">($age)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;age=$age;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'name:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' age:'</span>.<span class="keyword">$this</span>-&gt;age;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>  实际调用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$instance = <span class="keyword">new</span> A();</div><div class="line">$instance-&gt;cage(<span class="number">111</span>)-&gt;cname(<span class="string">"Dawnki"</span>);</div><div class="line"><span class="keyword">echo</span> $instance;        <span class="comment">// name:Dawnki age:111</span></div></pre></td></tr></table></figure><p>  简单吧？如果是改变的属性为对象，即可进行更多的操作，这个代码风格使用起来也是十分顺手易读性强。</p><h2 id="Laravel-使用的链式操作"><a href="#Laravel-使用的链式操作" class="headerlink" title="Laravel 使用的链式操作"></a>Laravel 使用的链式操作</h2><p>  Laravel在对数据库增删查询也是采用链式操作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Model::where(<span class="string">'xxx'</span>,<span class="string">'xxx'</span>)-&gt;where(<span class="string">'xxxxxx'</span>,<span class="string">'xxxx'</span>)-&gt;get();</div></pre></td></tr></table></figure><p> 这里就会有个小问题，上面的链式操作明明都是return $this , 这里Model上来就搞了个where的静态方法，不会炸开锅吗？</p><p> 实际上，阅读下Laravel的源码，里面采用了许多魔术方法，下面就看看源码的实现(好像有点偏题，哈哈)</p><p> 在/vendor/laravel/illuminate/Database/Eloquent/Model.php中找到他们的两个魔术方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Handle dynamic method calls into the model.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $method</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  array  $parameters</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($method, $parameters)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (in_array($method, [<span class="string">'increment'</span>, <span class="string">'decrement'</span>])) &#123;</div><div class="line">        <span class="keyword">return</span> call_user_func_array([<span class="keyword">$this</span>, $method], $parameters);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $query = <span class="keyword">$this</span>-&gt;newQuery();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> call_user_func_array([$query, $method], $parameters);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Handle dynamic static method calls into the method.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $method</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  array  $parameters</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">($method, $parameters)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    $instance = <span class="keyword">new</span> <span class="keyword">static</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> call_user_func_array([$instance, $method], $parameters);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  可见,当 Model:where(xxxx) 时，会先生成一个Model的实例(执行__callStatic)，然后再用回调函数,让这个刚生成的实例去执行where，由于模型里面本来是没有涉及sql查询的方法，正在执行sql语句的是同目录下面的Builder.php,即SQL构造器，这个builder里面才负责处理SQL.因此Model的实例因为没有where方法而执行魔术方法__call来生成一个构造器(builder)去执行where方法。所以 <strong>真正执行where方法的是Builder.php</strong></p><p>  下面是/vendor/laravel/illuminate/Database/Eloquent/Builder中的where方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Add a basic where clause to the query.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $column</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $operator</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  mixed   $value</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $boolean</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> $this</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">where</span><span class="params">($column, $operator = null, $value = null, $boolean = </span></span></div><div class="line"><span class="function"><span class="params">    <span class="string">'and'</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> ($column <span class="keyword">instanceof</span> Closure) &#123;</div><div class="line">        $query = <span class="keyword">$this</span>-&gt;model-&gt;newQueryWithoutScopes();</div><div class="line"></div><div class="line">        call_user_func($column, $query);</div><div class="line"></div><div class="line">        <span class="keyword">$this</span>-&gt;query-&gt;addNestedWhereQuery($query-&gt;getQuery(), $boolean);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        call_user_func_array([<span class="keyword">$this</span>-&gt;query, <span class="string">'where'</span>], func_get_args());  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>;    <span class="comment"># 链式操作关键</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="用链式操作改造CURL"><a href="#用链式操作改造CURL" class="headerlink" title="用链式操作改造CURL"></a>用链式操作改造CURL</h2><p>  <a href="https://github.com/Dawnki/mycurl" target="_blank" rel="external">附带一个利用链式操作的封装curl类</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  所以不妨改良一下自己的代码吧！~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;玩耍过jQuery的朋友们应该对链式操作不陌生，链式操作在实际应用上不仅美观，并且代码容易阅读，下面用PHP简单实现下链式操作。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="PHP" scheme="https://dawnki.github.io/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://dawnki.github.io/tags/PHP/"/>
    
      <category term="Laravel" scheme="https://dawnki.github.io/tags/Laravel/"/>
    
      <category term="链式操作" scheme="https://dawnki.github.io/tags/%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
</feed>

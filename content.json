[{"title":"Ubuntu完全卸载mysql","date":"2017-05-10T04:45:44.000Z","path":"2017/05/10/删除mysql/","text":"我们安装了mysql之后想卸载mysql时，往往是卸载不完全，导致下次安装又有问题，下面就提供ubuntu完全卸载mysql的方法. 实验环境 Linux: Ubuntu 16:04 Mysql 5.7 步骤 温馨提示:执行之前务必确认是否备份了数据库的数据,数据无价! 先在shell里执行以下指令 12345sudo apt-get autoremove --purge mysql-server*sudo apt-get remove mysql-server*sudo apt-get autoremove mysql-server*sudo apt-get remove mysql-commonsudo rm -rf /etc/my.cnf 建一个shell脚本(文件)叫deleteMysql.sh,内容如下: 1234567#!/bin/bashlist=`sudo find / -name mysql*`for i in $list do sudo rm -rf $idoneexit 0 给这个脚本加上执行权限后执行 12sudo chmod u+x deleteMysql.shsudo ./deleteMysql.sh 小结这下子mysql应该算是完全卸载了，然后就可以跑路(误)了!!!∑(ﾟДﾟノ)ノ","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"ubunut","slug":"ubunut","permalink":"https://dawnki.github.io/tags/ubunut/"}]},{"title":"Laravel5.2消息队列实践","date":"2017-05-10T03:21:41.000Z","path":"2017/05/10/laravel-job/","text":"在后台开发中，很多情况需要用到队列来处理业务逻辑，前几天亲自实践了一下Laravel的队列功能，在此分享一蛤。 使用情景举几个使用到消息队列的栗子 在处理商城的库存问题，简单的实现是当用户的某件商品下单了，库存就相对应减少，但是当并发量一大时，比如A,B两个顾客同时下单，如果不使用队列可能会造成库存错误，使用队列了保证不同时执行两个减库存操作(一个阻塞掉了另外一个)。 当一个服务器要处理一个请求端发来的多组大量数据，而且每组数据处理起来的时间会很慢时，可以采取异步队列，就相当于请求端发过来的数据先存着，放进队列里，然后再异步处理数据(即处理数据的过程不在请求的生命周期里) 由于比如用户登陆了某网站之后，后台就过xx分钟给用户发延迟邮件来推送广告(怎么有点流氓(°Д°))，这里也可以用到异步队列，虽然可以用设计定时任务来轮询检查的笨方法，不过感觉用轮询来实现异步不是真正的异步 扯了这么多，刚回到正题了—实践 实验环境 Laravel 5.2 系统: Windows(wamp) or Linux(lnmp) 步骤起步laravel提供了多种消息队列驱动: sync(同步) database beanstalkd sqs redis默认是sync，不过实际上其他几种异步队列多点，本章先用database练练手，前几天刚服务器刚配好redis，迟点再补上redis的吧~ so,先到 /.env (默认根目录为你的项目目录) 中 填上 QUEUE_DRIVER=database ,当然你也可以到/config/queue.php的default中将sync修改，但是建议修改.env 建表修改完队列驱动后，就用Laravel的migration自动生成队列需要的表，到根目录执行artisan 123php artisan queue:tablephp artisan queue:failed-table #处理出错队列用的表php artisan migrate 此时，数据库中就会出现jobs表和failed_jobs表 创建任务类并编写任务类执行artisan命令快速生成任务类并在/app/jobs/ 目录下面找到刚创建的任务 1php artisan make:job yourJobName 刚自动生成的任务类包含了两个初始方法 12345678910111213141516171819/** * Create a new job instance. * * @return void */public function __construct()&#123; //&#125;/** * Execute the job. * * @return void */public function handle()&#123; //&#125; 构造方法__construct用于你给任务类传值or对象用，至于handle方法则是队列任务的处理(即给排在队列里的任务如何执行业务逻辑) 这时就有个问题了，排在队列里的任务如果处理时失败了，或者因不符合某些业务逻辑需要进行统一的失败操作，那该怎么办呢？ 此时可以在这个任务类中添加一个failed方法 1234public function failed()&#123; //&#125; 这样laravel就可以识别得到，当一个任务在执行handle方法时，遇到异常了(Throw Exception)，laravel就会自动执行failed方法，并在failed_job表中记录信息。这个用来管控你看不见摸不着的异步队列任务比较有用，你可以根据业务逻辑在failed方法里将错误信息输出到自己的日志或者其他操作。 任务类里自带的几个有用方法通过artisan生成的任务类里，由于使用(use)了InteractsWithQueue这个trait，所以可以使用到里面有几个自带的方法 attempts 作用:返回任务的已经执行次数(eg.可以用于在handle方法中判断任务执行超过n次时就抛出异常来执行failed方法等等) 食用方法:在任务类的handle方法或者failed方法中,无参 1$this-&gt;attempts() delete 作用:在队列中删除该任务(jobs表里删除) 食用方法:同上 1$this-&gt;delete() release 作用:将当前任务再次放进队列中，可传入参数，来控制同一个任务两次运行之间的等待时间 食用方法:同上，不过有参，参数为int类型 表示多少秒 1$this-&gt;release(10); // 同一个任务两次运行之间隔10秒执行 目前任务类里比较常用的就是这几个方法了。","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"异步消息队列","slug":"异步消息队列","permalink":"https://dawnki.github.io/tags/异步消息队列/"}]},{"title":"Sublime Text 安装Package Controller","date":"2017-05-10T00:38:46.000Z","path":"2017/05/10/sublimetextPC/","text":"前言众所周知，sublime是一款很好用的文本编辑器，其好用之处在于其背后强大的插件功能，但是刚安装的sublime是不能直接安装插件的，需要先安装Package Controller 才能通过Package Controller来安装插件，下面就介绍如何安装Package Controller. 安装方法安装方法分为简单安装和手动安装,自行选择即可. 简单的安装方法使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码： Sublime Text 3 1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 如果顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了。 Sublime Text 2 的如下: 1import urllib2,os; pf=&apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), &apos;wb&apos; ).write( urllib2.urlopen( &apos;http://sublime.wbond.net/&apos; +pf.replace( &apos; &apos;,&apos;%20&apos; )).read()); print( &apos;Please restart Sublime Text to finish installation&apos;) 手动安装可能由于各种原因，无法使用代码安装，那可以通过以下步骤手动安装Package Control： 点击Preferences &gt; Browse Packages菜单 进入打开的目录的上层目录，然后再进入Installed Packages/目录 下载Package Control.sublime-package并复制到Installed Packages/目录 重启Sublime Text。 如何使用Package Controller 安装插件 快捷键ctrl+shift+P，或者直接在Preferences &gt; Package Controller 来打开 在输入框中输入 install package 按回车 在新弹出的框中输入你要安装的插件即可 效果如下图:","tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://dawnki.github.io/tags/Sublime-Text/"}]},{"title":"LNMP坑点系列:\"mysql.serviceJob for mysql.service failed because the control process exited with error code.\"","date":"2017-05-09T13:02:09.000Z","path":"2017/05/09/mysql-question/","text":"一天舍友在lnmp下，动了一下/etc/my.cnf文件之后,重启lnmp是出现了”mysql.serviceJob for mysql.service failed because the control process exited with error code.”的问题。 寻找元凶经过几番询问后，发现原来舍友为了更改mysql密码动了一下/etc/my.cnf文件. 锁定/etc/my.cnf文件！！ 可以看到这个文件的初始权限是拥有者有读写功能，但同组或者其他人只有读的功能，由于舍友为了修改这个文件，帮这个文件加了所有身份都加了写的功能。 即：1sudo chmod go+w /etc/my.cnf 接着重启就炸了 1sudo lnmp restart 解决办法要解决很简单，只将这个文件的权限还原即可(只保留拥有者有写功能) 1sudo chmod go-w /etc/my.cnf 如图修改完之后，大功告成!lnmp能正常重启了! 小结这个坑告诉我们一定要有做事要有头有尾，文件由于一时特殊需要改了权限的，之后完事后记得改回权限!!","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"}]},{"title":"Hello World","date":"2017-05-09T10:51:21.767Z","path":"2017/05/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]
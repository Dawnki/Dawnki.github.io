[{"title":"星期压缩","date":"2018-03-28T07:32:31.000Z","path":"2018/03/28/星期压缩/","text":"百词斩的第二道编程题，题目不难，事后码出来了，留个档。 题目:给定一组1~7组成(包含1和7)的有序且非重复数字数组, 每个数字的字面值n表示一周里面的第n天, 要求按照如下规则压缩后, 输出压缩以后的描述: 1) 对于三个及三个以上的连续数字, 需要压缩成”起始-结束”的格式; 2) 对于三个以下的连续或不连续数字, 不需要压缩, 按照原样输出; 输入:第一行输入n，为数组的长度，比如5天的话，n=5，接下几行为具体的星期 如： 3 (3天)1 (星期一)2 (星期二)4 (星期四) 输出：压缩后的数字序列，序列的每一段之间使用英文逗号分隔。 如输入： 512456 则输出： 1，2，4-6 具体Java代码实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Test &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] array = new int[n]; for (int i = 0; i &lt; n; i++) &#123; array[i] = in.nextInt(); &#125; check(array); &#125; public static void check(int[] array) &#123; //记录连续数的开头值 int min = 0; //标记当前数是否与前一个连续 int flag = 0; //连续数的个数 题目要求超过3个才用 \"-\" 连接 int count = 0; //记录结果 String result = \"\"; for (int i = 0; i &lt; array.length; i++) &#123; //遍历到最后一个数的情况 if (i == array.length - 1) &#123; if (flag == 0) &#123; //与前面的数不连续 result += array[i]; &#125; else &#123; //与前面的数连续 if (count &gt;= 2) &#123; //超过3个连续数 用 - 连接 result += min + \"-\" + array[i]; &#125; else &#123; result += min + \",\" + array[i]; &#125; &#125; break; &#125; //非最后一个数 if (array[i] + 1 != array[i + 1]) &#123; if (flag == 0) &#123; //当前数前后都不连续 result += array[i] + \",\"; &#125; else &#123; //当前数与前一个连续但与后一个不连续的情况 if (count &gt;= 2) &#123; result += min + \"-\" + array[i] + \",\"; &#125; else &#123; result += min + \",\" + array[i] + \",\"; &#125; //重置计算 min = 0; count = 0; flag = 0; &#125; &#125; else &#123; if (flag == 0) &#123; //当前数与前一个不连续与后一个连续 min = array[i]; count = 1; flag = 1; &#125; else &#123; //当前数前后都连续 count++; &#125; &#125; &#125; System.out.println(result); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://dawnki.github.io/tags/算法/"},{"name":"编程题","slug":"编程题","permalink":"https://dawnki.github.io/tags/编程题/"}]},{"title":"docker实践","date":"2017-10-09T05:20:45.000Z","path":"2017/10/09/docker实践/","text":"最近忙于工作，荒废了博客，在此反省一波～～好了，今天聊聊docker。docker作为一种快速部署生产环境的工具，利用了其自动化的优点，减少在部署中人为繁琐操作，从而提高了部署环境的速度以及准确度，在部署服务器集群中尤为便利，今天就简单入门一下docker吧！ Docker基本概念 入门Docker的初心者来说肯定要面对这三个名词，镜像(Image)，容器(Container)，仓库(Repository)。 镜像就好比我们装系统时的镜像，包含着原始系统，镜像一般要求比较干净，比如一个nginx镜像，一个php-fpm容器这样子，负责不同共功能的要将镜像划分开。容器则是我们实际的操作环境，容器是基于镜像构建，容器是镜像的示例，就如对象是类的实例一样。而仓库的话是用来存放镜像的，仓库有分私人仓库与公有仓库，公有仓库中有许多官方镜像，比如redis，nginx等等。 常用指令镜像类 Image1docker pull &lt;image&gt; 用于从网络拉取镜像，比如想要拉取nginx镜像时，就打docker pull nginx，默认拉取最新版本，如需拉取其他版本，可使用docker pull nginx:xxxx 1docker search 关键字 去网络仓库中查找镜像 1docker images 用于列出本地已拉取的镜像 1docker history 仓库:标签 显示某个仓库对于标签镜像的历史 1docker rmi 仓库:标签 删除本地指定仓库标签的镜像 1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 以某个镜像按照设置创建并运行一个容器 eg. 12#将nginx镜像的一个容器起名为webserver，并把本机9999端口映射到docker容器的80端口docker run --name webserver -d -p 9999:80 nginx 容器类 Container12345678910111213141516#查看运行中的容器docker ps#查看所有容器，包括停止的docker ps -a# 查看全部容器的iddocker ps -a -q#查看运行中的容器进程docker top 容器名#删除一个容器docker rm [容器id]#删除所有容器docker rm `docker ps -a -q`#将一个容器保存为镜像docker commit &lt;CONTAIN-ID&gt; &lt;IMAGE-NAME&gt;#启动一个已经存在的镜像docker start 容器id Docker run1docker run -it(命令后交互) --rm(停止后删除) -p 0.0.0.0:8080:9999(端口映射) -v /宿主目录:/容器目录 xxx:xxx(镜像) bash 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-a, --attach=[] Attach to STDIN, STDOUT or STDERR 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项--add-host=[] Add a custom host-to-IP mapping (host:ip)--blkio-weight=0 Block IO (relative weight), between 10 and 1000-c, --cpu-shares=0 CPU shares (relative weight)--cap-add=[] Add Linux capabilities--cap-drop=[] Drop Linux capabilities--cgroup-parent= Optional parent cgroup for the container--cidfile= Write the container ID to the file--cpu-period=0 Limit CPU CFS (Completely Fair Scheduler) period--cpu-quota=0 Limit the CPU CFS quota--cpuset-cpus= CPUs in which to allow execution (0-3, 0,1) 绑定容器到指定CPU运行--cpuset-mems= MEMs in which to allow execution (0-3, 0,1) 绑定容器到指定MEM运行-d, --detach=false Run container in background and print container ID 后台运行容器，并返回容器ID--device=[] Add a host device to the container--dns=[] Set custom DNS servers 指定容器使用的DNS服务器，默认和宿主一致--dns-search=[] Set custom DNS search domains 指定容器DNS搜索域名，默认和宿主一致-e, --env=[] Set environment variables 设置环境变量--entrypoint= Overwrite the default ENTRYPOINT of the image--env-file=[] Read in a file of environment variables 从指定文件读入环境变量--expose=[] Expose a port or a range of ports-h, --hostname= Container host name 指定容器的hostname--help=false Print usage-i, --interactive=false Keep STDIN open even if not attached 以交互模式运行容器，通常与 -t 同时使用--ipc= IPC namespace to use-l, --label=[] Set meta data on a container--label-file=[] Read in a line delimited file of labels--link=[] Add link to another container--log-driver= Logging driver for container--log-opt=[] Log driver options--lxc-conf=[] Add custom lxc options-m, --memory= Memory limit--mac-address= Container MAC address (e.g. 92:d0:c6:0a:29:33)--memory-swap= Total memory (memory + swap), &apos;-1&apos; to disable swap--name= Assign a name to the container 为容器指定一个名称--net=bridge Set the Network mode for the container 指定容器的网络连接类型，支持 bridge/host/none/container:&lt;name|id&gt; 四种类型--oom-kill-disable=false Disable OOM Killer-P, --publish-all=false Publish all exposed ports to random ports-p, --publish=[] Publish a container&apos;s port(s) to the host 端口映射 宿主：容器--pid= PID namespace to use--privileged=false Give extended privileges to this container--read-only=false Mount the container&apos;s root filesystem as read only--restart=no Restart policy to apply when a container exits--rm=false Automatically remove the container when it exits--security-opt=[] Security Options--sig-proxy=true Proxy received signals to the process-t, --tty=false Allocate a pseudo-TTY 为容器重新分配一个伪输入终端，通常与 -i 同时使用-u, --user= Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])--ulimit=[] Ulimit options--uts= UTS namespace to use-v, --volume=[] Bind mount a volume 挂载宿主文件夹 宿主:容器--volumes-from=[] Mount volumes from the specified container(s)-w, --workdir= Working directory inside the container","tags":[{"name":"docker","slug":"docker","permalink":"https://dawnki.github.io/tags/docker/"},{"name":"部署技术","slug":"部署技术","permalink":"https://dawnki.github.io/tags/部署技术/"},{"name":"docker-composer","slug":"docker-composer","permalink":"https://dawnki.github.io/tags/docker-composer/"}]},{"title":"C++:变量篇","date":"2017-08-28T01:36:38.000Z","path":"2017/08/28/c++变量篇/","text":"今天来讲讲C++的变量知识。C++的基础类型与C一样，都有int，char，float，double,pointer,下面是未初始化时，各个基础类型的初始值。 数据类型 初始化默认值 int 0 char ‘\\0’ float 0 double 0 pointer NULL C++没有字符串基础类型，字符串则是由字符数组表示，这点跟C一致。不过C++标准库有String类的实现。另外C++不适合做web开发很大一部分与其比较弱的字符串处理有关，毕竟web开发很大一部分都是跟字符串打交道比如最好的语言PHP(滑稽)。 全局变量与局部变量简单的理解就是写在所有函数外部的就是全局变量，写在函数内部的就是局部变量，包括main函数。 12345678910111213int a; //全局变量void call()&#123; int c; //局部变量&#125;int main()&#123; int b; //局部变量 call(); return 0;&#125; 全局变量，一般情况下在被其他源文件include之后，可以直接使用，但前提是没有static关键字修饰。全局变量在本文件的哪个地方都能使用。 局部变量，通常包括被调用函数内部声明定义的变量以及形参，其声明周期在被调用函数结束后销毁。 静态变量C++静态变量通常是指被static修饰的变量，这种变量在 程序运行之前就已经分配好内存，在程序结束时才释放。这中变量的内存被分配到全局静态区，由系统进行管控。除此之外，static关键字还有以下几种功能。 static修饰全局变量，会使得该全局变量 只能在本文件中使用 ，当其他源文件include了此文件后，不能使用该static修饰的全局变量。 static修饰局部变量，会使该局部变量只能限定在自己所在的作用域(即所在函数)，这和其他局部变量一样，但是唯一不同的是由于静态变量是 程序结束时才会进行回收，因此回收阶段不在所在函数退出调用时，即 一次分配全程有效，所以下次调用该静态变量所在函数时，该变量的值不会重新申请内存以及重新初始化。 static修饰的类成员变量，能在该类 所有所属的对象中共享。static修饰的类成员方法，不需该类实例化 就才能使用，直接 类::静态方法 即可使用。 12345678910111213141516static int a ; //静态全局变量void call()&#123; static int b = 0 ; //静态局部变量 cout &lt;&lt; b &lt;&lt; endl; b++;&#125;int main()&#123; static int c ; //静态局部变量 call(); //输出0 call(); //输出1 return 0;&#125; const修饰的变量const原义是constant，意为永恒的，不变的。一看就觉得这个修饰词很强壮Rua!,这个const作用很大，可以修饰变量，修饰返回值，修饰参数，修饰函数。通常被它修饰过的多多少少代表着不会变化，不过具体情况具体分析。 修饰普通变量被const修饰的普通变量就成为了C++中的常量，在声明一定要初始化。在代码里一旦修改了const修饰的变量会出现编译错误。另外，const修饰的位置可以在类型前面，也可以在类型后面，意义一致。 12const int a =3;//等同于 int const a=3； 修饰返回值被const修饰的函数返回值，要分两种情况讨论。第一种是，如果返回值是非指针应用类型,那么它跟没有const修饰的函数返回值一样，没有特别的。 1234const int call()&#123; // ....&#125; 第二种情况是，如果返回值时指针类型，那么如果函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针，否则会出现编译错误。 123456789const char* call()&#123; // .....&#125;int main()&#123; const char* str= call(); //str指针务必是const修饰的&#125; 修饰参数对于非基础数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是 提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。这样既免去了对象的复制(临时对象的构造、复制、析构消耗时间)，又可以不改变原引用内容。 1234void call(const A &amp;a)&#123; // your code&#125; 对于基础数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为void Func(const int &amp;x)。基础数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。 修饰函数在一个类成员函数中，如果被const修饰后，该成员函数 不能改变成员变量的内容，除非成员变量带有 mutable修饰符，否则会提示编译错误。另外，const修饰的位置在函数名(含参数)后。 123456789101112class A&#123;private: int a; mutable int b;public: void test() const &#123; this-&gt;b = 3; //可以修改 // this-&gt;a =4; 不能修改 &#125;&#125; const char* , char const* , char* const 傻傻分不清相信刚入门的小朋友肯定会对这几个变量的声明形式搞得头晕脑胀，下面就顺便说一下吧。 在此之前，先介绍一个声明指针变量的读法，有助于大家记忆。 1char * p; 从右往做读，* 读作pointer to意为指向。即变量p为指向char类型的指针(p is a pointer to char) 指向常量的指针12345const char * p = \"123\";//char const * p = \"123\";p = &amp;test ; //p仍能指向别的 假设&amp;test为字符串的首地址*p = \"111\" ; //编译错误 不能改变指向的内容 因为const可以放在类型的前面或者后面，所以上面两个意思等价。同为 p is a pointer to const char，即变量p是一个 指向const的char 指针。等号右边的内容为const不能改变。 常量指针12345char * const p = \"123\";//char * p const = \"123\";p = &amp;test ; //编译错误 p不能再指向别的 假设&amp;test为字符串的首地址*p = \"111\" ; //无编译错误 可以改变指向的内容 上面两种等价，const修饰的是p变量而不是char，所以p is a const pointer to char，即为p是指向char的const指针。等号左边的变量p一旦指向了，就不能更改。 简单来理解就是const 修饰的对象不同，一个是修饰左值，一个修饰右值，* 就如一座大山，若const在 * 的左边，则修饰等号右边的值，若在 * 的右边，则修饰变量p，一旦初始化了就不能更改的指针。 指向常量的常量指针看了我上面的解释，应该知道这个怎么写了吧？没错就是下面那样: 12const char * const p =\"123\";//char const * const p =\"123\"; //同上 等价 港真，这种变量真的没什么用….p因为常量指针，所以自身不能改变指向。p指向的内容是常量，所以p不能改变内容，所以感觉实用性不大，仅供学习参考。 总结以上知识不是光看就能明白，还需要动手打一下验证一下！编程是一门实践性极强的技术。 参考const 修饰函数参数，返回值，函数体 const char *, char const *, char * const的区别 C/C++中static关键字详解 指针常量与常量指针","tags":[{"name":"cpp","slug":"cpp","permalink":"https://dawnki.github.io/tags/cpp/"},{"name":"全局变量","slug":"全局变量","permalink":"https://dawnki.github.io/tags/全局变量/"},{"name":"静态变量","slug":"静态变量","permalink":"https://dawnki.github.io/tags/静态变量/"},{"name":"常量指针","slug":"常量指针","permalink":"https://dawnki.github.io/tags/常量指针/"}]},{"title":"C++:内存篇","date":"2017-08-26T02:14:18.000Z","path":"2017/08/26/c++:内存篇/","text":"C++的内存知识是关键中的关键，有一些C++的内存坑点，因为C++没有垃圾回收机制(Garbage Collection),因此稍不注意容易发生内存泄露等问题。接下来就说说内存的各种要点。 五种内存分配类型栈内存栈(stack)内存，编译根据代码来分配并释放，通常为代码的局部变量，函数形参等，其结构类型与数据结构的栈相似，先进后出。这种内存 由系统分配并且进行回收，效率较高但最大栈内存受到编译器限制，程序猿不用担心其内存泄露，即使出错，编译器也能发现错误。 如： 123int a = 3;char b[] = \"abc\";char c = 'k'; 这些内存在退出调用时系统就会自动回收。只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示 栈溢出。因此如果递归函数，但是边界设置不正确时，会因超出栈所能申请的内存空间发生栈溢出。 堆内存堆(heap)内存,通常由程序猿来申请分配，C/C++中的malloc以及new，就是分配这种堆内存。堆内存分配的效率没有栈内存的高，不过可分配的空间一般只受限于系统的有效的内存。通常这种堆内存用来存储对象或者结构体等。这种内存只有在程序猿 主动释放 或者 程序结束时 系统自动释放。 如： 12int a = new int(10);int b = (int) malloc(sizeof(int)*10); 这种内存需要程序猿手动释放，不然会造成许多内存碎片(无法再度使用的)，即内存泄露，而且编译器很难检查得到。 全局&amp;静态区这部分的内存通常用来存放全局变量以及静态变量(static),这一大部分叫做全局区，全局区也分两个小部分，一部分存放已初始化的全局变量和静态变量，另一部分存放未初始化的全局变量和静态变量，并且向这部分申请内存时 只申请一次 ,内存在结束时由系统自动释放。 如： 1234567int a; //全局变量static int b; //全局静态变量int main()&#123; static c; //局部静态变量&#125; 这种变量只会申请一次，比如在函数A里申请了局部静态变量b，当下次再次调用A时，b仍是那个内存块。 123456789101112int A()&#123; static int a=0; // 程序运行前以及申请内存并初始化 a++; return a;&#125;int main()&#123; cout &lt;&lt; A(); // 输出 1 cout &lt;&lt; A(); // 输出 2&#125; 文字常量区常量字符串存放的地方，由系统自行释放。有点像java中的字符串常量，因为同一段文字分配的是同一个内存区。 1char *p = \"hello,world!\"; //字符指针p在栈区 “hello,world!\\0”在文字常量区 程序代码区用于存放函数体的而二进制代码。 内存管理C++的内存管理完全交给程序猿来处理，这是一把双刃剑。好处是GC部分由程序猿自己实现或者有些地方不需垃圾回收，以提高性能效率。坏处是若程序猿不自行管理的话，容易造成内存泄露，造成内存碎片化，严重的会不停的申请内存，直至系统内存无法申请为止。 123456789101112131415void call()&#123; int \\*a = new int(); //因为没有进行堆内存回收造成泄露(反斜杠由于md的问题自行忽略掉吧)&#125;int main()&#123; while(1) &#123; call(); //会循环申请堆内存 &#125; return 0;&#125; 以上代码慎重运行，严重点会卡死系统(别问我怎么知道的/(ㄒoㄒ)/) 为了不造成内存泄露，每次new/malloc了内存之后使用完毕务必delete/free掉刚申请的内存 ,另外还可以使用c++11的智能指针，省去手动delete。智能指针自动释放内存的原理是：智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。 常用的智能指针有 shared_ptr,unique_ptr,weak_ptr具体更细致的解释(挖坑)将放到面向对象篇进行说明。 12345678910111213class A&#123;public: A()&#123;&#125;; ~A()&#123;&#125;;&#125;;int main()&#123; shared_ptr&lt;A&gt; ptr(new A()); //使用了智能指针后 指针超出作用域就会自动销毁所申请的内存 unique_ptr&lt;A&gt; ptr1(new A());&#125; 安利：另外Linux下的Valgrind是检测C++内存泄露好工具哦！ delete 与 delete []delete 与 delete [] 经常用作回收堆内存，两者有差别，delete用来回收单个对象，delete []用来回收对象数组，下面分两种情形讨论： (1) 当对象为基础数据类型,如int,char,double时，回收数组可以用delete []和delete 12int *p =new int[5];delete p; // or delete [] p; (2) 当对象为自定义的类对象时，回收数组必须使用delete [] ,因为使用delete [] 时 会主动调用每个对象数组元素(即单个对象)的析构函数 1234567891011class A()&#123;public: ~A()&#123;&#125;&#125;int main()&#123; A* p = new A[5]; delete [] p; //使用delete会发生内存泄露&#125; 所以delete的实质其实是调用对象的析构函数，只是当对象为基础数据类型就简便了而已。不过为了方便记忆，建议凡是回收数组都用delete[],回收单体就用delete。即new 对应 delete , new [] 对应 delete [] 总结 With great power comes great responsibility is big 性能与易用两者不可兼得也，只能苦学而取性能也！","tags":[{"name":"cpp","slug":"cpp","permalink":"https://dawnki.github.io/tags/cpp/"},{"name":"内存分配","slug":"内存分配","permalink":"https://dawnki.github.io/tags/内存分配/"},{"name":"内存泄露","slug":"内存泄露","permalink":"https://dawnki.github.io/tags/内存泄露/"}]},{"title":"CMakeList批量导入源文件和头文件","date":"2017-08-25T09:51:43.000Z","path":"2017/08/25/goodCMake/","text":"今天分享一套 提高寿命 的CMakelist写法，仅供简单项目使用O(∩_∩)O哈哈~ 123456789cmake_minimum_required(VERSION 3.8)project(your_project_name)set(CMAKE_CXX_STANDARD 11)file(GLOB SOURCE_FILES &quot;*.h&quot; &quot;*.cpp&quot;)add_executable(your_project_name $&#123;SOURCE_FILES&#125;) 简单粗暴利用 通配符 直接把目录下的所有头文件，源文件直接导入，包括二级，三级…..N级目录。 妈妈再也不用担心我xxxx未定义使用~\\(≧▽≦)/~啦啦啦 弱鸡写法，仅供简单项目使用233333333","tags":[{"name":"CMakeList","slug":"CMakeList","permalink":"https://dawnki.github.io/tags/CMakeList/"},{"name":"C++","slug":"C","permalink":"https://dawnki.github.io/tags/C/"}]},{"title":"C++:头文件篇","date":"2017-08-25T06:03:52.000Z","path":"2017/08/25/cpp头文件/","text":"在学习c++，被头文件搞得一头包，时常出现重定义的错误，今天就理一下c++的头文件，彻底把它搞懂。C++与C一样，所有变量都需要先声明才能使用，这种”啥都别说，先报名字”的做法，不仅应用在了变量身上，一个函数也需要先声明后使用，并且这个函数只能定义一次。 起步比如： 123456789void A()&#123; B(); // 未声明调用&#125;void B()&#123; // your code&#125; 上面的例子中，由于B出现的顺序在A之后，但是A先调用未声明B，因此会报错。解决办法如下： 1234567891011void B(); //此处声明void A()&#123; B();&#125;void B() //此处定义(实现)&#123; // your code&#125; 上面的知识很简单，学过c基础的同学都知道，上面的例子是说明，声明与定义不一样，调用函数前，这个函数一定是要 先声明 (可以声明无数次) ，其函数的定义可以延后，并且 只能定义一次 。明白了要点之后回到正题。 C++和其他语言一样可以分别编译，用于将代码分成若干个cpp，每个cpp负责不同的功能。如果但是几个cpp文件相互依赖的话，我们直接include cpp源文件 容易出现重复定义的错误。至于为什么会重复定义呢？这是因为include的时候，相当于把目标文件的内容包含进来，比如A包含了B，因为B里面的某个函数有具体的定义(实现)，所以A里面就相当定义了一次B里面的函数，但是等到编译B的时候，B也定义了一次函数，导致重复定义的错误。 不犯重复定义的函数也很简单，不需要include源文件，直接在依赖者中(a.cpp)先声明然后使用即可。 12345678910111213//a.cppvoid test();int main()&#123; test();&#125;//b.cppvoid test()&#123; // your code&#125; 现在弄出个头文件的目的就是，比如A要使用B的函数f(),A肯定不能包含具体定义的文件(重复定义)，A就包含具有B文件里所有函数声明的头文件B.h,要知道多次定义会报错但是多次声明不会报错。因此，C++推荐的写法是定义与声明分开，头文件写声明，源文件写定义，源文件之间依赖通过包含源文件的头文件来实现。同时，头文件时一个存着一堆声明文件，因此就不用像上面的代码那样，在依赖者中写入被依赖者的声明(解耦)。 实例现在存在的一个场景是，源文件A依赖源文件B的f(),源文件A叫做A.cpp,源文件B叫做B.cpp,源文件B的头文件叫做B.h 123456789101112131415161718192021/* A.cpp */# include \"B.h\"int main()&#123; f();&#125;/* B.h */#ifndef project_B_H //头文件保护措施#define project_B_Hvoid f(); //声明#endif/* B.cpp */# include \"B.h\"void f() // 实现&#123; // your code&#125; 在上述例子中，B的头文件里面由一些宏定义，这些是为了防止重复定义，具体的场景是，两个源文件include了同一个头文件。而编译时，这两个源文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突，因此需要加上#ifndef和#endif，当中ifndef和define后面跟是一个唯一标识，通常规范的格式为项目名_类名_H(H代表头) 如果换成类的写法就是这样 123456789101112131415161718192021222324/* A.cpp */# include \"B.h\"int main()&#123; f();&#125;/* B.h */#ifndef project_B_H //头文件保护措施#define project_B_Hclass B &#123;public: void f();&#125;;#endif/* B.cpp */# include \"B.h\"B::f()&#123; // your code&#125; 当然具体的实现也可直接写在头文件里，完全没有问题。 include “” 与 include &lt;&gt;#include &lt; file &gt; 编译程序会先到 标准函数库 中找文件 #include “file” 编译程序会先从 当前目录 中找文件 头文件中可能会出现的extern关键字在C语言中，修饰符extern用在变量或者函数的声明前，用来说明此变量/函数是在别处定义的，要在此处引用。 在C++中extern还有另外一种作用，用于指示C或者C++函数的调用规范。比如在C++中调用C库函数，就需要在C++程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。 总结老实说，这种定义与声明分开的写法还真有点蛋疼，如果一改就要改两处，所以感觉如果定义与声明都写在头文件里，然后一个include就完事了,这种做法比较方便点。当中应该考虑到兼容c等各种历史原因吧～","tags":[{"name":"cpp","slug":"cpp","permalink":"https://dawnki.github.io/tags/cpp/"},{"name":"头文件","slug":"头文件","permalink":"https://dawnki.github.io/tags/头文件/"},{"name":"编译","slug":"编译","permalink":"https://dawnki.github.io/tags/编译/"}]},{"title":"浅析IO模型","date":"2017-08-12T06:13:15.000Z","path":"2017/08/12/浅析IO模型/","text":"在之前的同步异步文章中埋了个坑，今天就来填一下吧。当CPU发起IO调用，需要读取文件里的东西时，由于IO处理的速度没有CPU那么快，因此，通常都是CPU在等待IO处理完毕返回数据。当IO处理中到CPU拿到文件数据，这里存在几种IO模型，分别是read，select，poll，epoll，kqueue。在此先说一下fd，系统在读写文件的时候，需要文件描述符(file descriptor简称fd)，当调用系统内核来进行文件操作时，内核会返回一个文件描述符，若要知道IO是否处理完毕，只需查看fd中的事件状态即可，即程序调用内核时就是查看这个状态，来判断是否完成操作的。下面就简单介绍下这几种IO模型。 read这是原始的轮询模式，当CPU发起IO调用时，处于等待状态，然后IO就去处理，然后就重复的检查fd的事件状态，当事件状态为处理完毕后，读出完整数据。这种做法比较原始以及性能较差。 selectselect是在read上的改进，有一个数组负责存着一堆文件描述符，然后遍历数组中的文件描述符来检查当中的事件状态，当某个文件已经处理完毕之后，就进行一次read操作来读取完整数据，然后交给应用。 select的缺点有两个。①是存放文件描述符的数组大小有限，一个进程处理的文件描述符(fd)数有限(cat /proc/sys/fs/file-max).32位机默认是1024个。64位机默认是2048.②随着fd的增多，会造成性能线性下降的问题(主因线性遍历)。 pollpoll则是在select的基础上进行改良，采用链表的数据结构来存储文件描述符，以解决select的数组大小限制问题。但是还是需要线性遍历，因此select的第二个缺点还是无法避免。 epollepoll只能在Linux使用。epoll是目前性能强劲的io复用模型，epoll的原理是每当操作文件时，都有一个回调函数与fd相对应，当io操作完毕后，就会调用这个回调函数来通知应用获取数据。 epoll中由三个函数，分别是epoll_create,epoll_ctl,epoll_wait。 1234#include &lt;sys/epoll.h&gt;int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); epoll_create用于创建epoll句柄，然后epoll来监听管理一定量的文件描述符。当然这个句柄本身就占一个fd。 epoll_ctl用于控制管理一个epoll句柄下面N个的fd，比如可以对一个epoll句柄下的某个fd进行增删该事件监听，这里监听的事件指的是epoll观察指定fd的状态，比如某个fd需要读写数据等。 12345678910111213struct epoll_event&#123; __uint32_t events; epoll_data_t data; &#125;;typedef union epoll_data&#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64; &#125; epoll_data_t; epoll_wait,根据触发方式(水平触发或者边缘触发)，来收集刚刚epoll_ctl中已注册并且触发的事件(就绪链表)，比如收集了fd为2,3的已经触发的事件，然后把这些事件赋值给一个数组(参数二中的events数组)，如果没有超时(timeout)，epoll_wait就会返回 触发事件的数目 ,然后去指定事件数组里拿相应数目的文件描述符(epoll_event储存了许多信息，里面的data就包含文件描述符)即可，这样就可以达到不复制文件描述符省去巨大的开销。同时也epoll只需拿到触发事件的文件描述符及其结果，而不像select和poll一样把不活跃的fd都一同获取了。 虽然说epoll_wait也是像select和poll一样需要轮询，不过它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空。另外epoll使用了mmap(内存映射技术)，加速与内核与用户空间的消息传递，避免不必要的内存拷贝。 kqueuekqueue与epoll一样都是基于事件的方式来处理IO复用的问题，只是kqueue是应用在BSD系统上，在此就不在赘述。 水平触发 &amp; 边缘触发LT：水平触发，支持阻塞和非阻塞io，效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。select和poll只支持水平触发。 ET：边缘触发，仅支持非阻塞io，效率非常高，在并发，大流量的情况下，会比LT少很多epoll的系统调用，当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。epoll支持边缘触发。 总结read属于原始的IO模型，而select，poll，epoll，kqueue都是属于IO复用模型，可以管理一定量的文件描述符。epoll基于事件的处理方式在处理大量的连接时仍保持这不错的性能，有效的提高了IO效率。 参考http://blog.csdn.net/yusiguyuan/article/details/15027821 http://blog.csdn.net/xiajun07061225/article/details/9250579 http://www.hulkdev.com/posts/epoll-io http://blog.csdn.net/jay900323/article/details/18141217/ http://blog.csdn.net/tianmohust/article/details/6677985/ http://www.cnblogs.com/Anker/p/3263780.html","tags":[{"name":"IO复用","slug":"IO复用","permalink":"https://dawnki.github.io/tags/IO复用/"},{"name":"轮询","slug":"轮询","permalink":"https://dawnki.github.io/tags/轮询/"},{"name":"非阻塞","slug":"非阻塞","permalink":"https://dawnki.github.io/tags/非阻塞/"},{"name":"epoll","slug":"epoll","permalink":"https://dawnki.github.io/tags/epoll/"}]},{"title":"玩转SSH","date":"2017-08-12T04:30:03.000Z","path":"2017/08/12/玩转SSH/","text":"我们知道，连接linux服务器最好用的是ssh，linux机器连接linux机器，直接使用ssh命令即可，不过每次都要一堆登录参数，也是十分麻烦，最重要的是ssh连接时需要填写要登录服务器的ip，ip什么的又难记，难免会影响到工作效率，那有没有办法像window上的xshell一样，免登陆密码，并且登录时命令不用这么复杂呢？ 答案是有的！今天就讲讲SSH免登录密码+Bash里的alias配置 主体思路 登录方先生成SSH密钥和公钥 将公钥内容添加到被被登录方的authorized_keys中 先登录一波，记录下。此时以后登录就能免密码了 修改bashrc，自定义自己的 骚操作 命令，简化命令 开工生成密钥老套路 1$ ssh-keygen -t rsa 三个回车，ssh公钥私钥就搞到手了。 此时，公私钥存放的位置时用户目录的.ssh文件夹 1$ cd ~/.ssh 私钥存着不管，把公钥内容拿了 1$ cat id_rsa.pub 设置被登录服务器的授权key登录服务器，并且找到 12$ cd ~/.ssh$ vim authorized_keys 此时将你的ssh公钥添加到授权key文件中 然后回到本机，先ssh登录一波机器，然后之后就能免密码登录了。 也可以用scp直接传公钥到服务器,具体命令 scp ~/.ssh/id_rsa.pub server_user_name@server_ip:server_targer_path ,具体内容根据自己实际情况填写 设置命令别名，简化命令设置命令别名(alias)，能够有效减少命令的长度，提高工作效率 1$ vim ~/.bashrc 在里面找个空白位置添加上 123# My aliasesalias your_command='ssh server_user_name@server_ip' #里面的内容根据自己实际情况填写# eg alias dawnki='ssh root@123.123.123.123' 然后保存并退出，执行 1source .bashrc 接下来你就可以用到别名命令了 就上面那个例子，免登陆+别名，我直接打短命令就能直接ssh登录到服务器了，大大提高工作效率 如果你想要原始命令只需在命令前加反斜杠 1\\ls 若要每次登入就自动生效别名，则把别名加在/etc/profile或~/.bashrc中。然后# source ~/.bashrc。若要让每一位用户都生效别名，则把别名加在/etc/bashrc最后面，然后# source /etc/bashrc。 总结 还有其他短命令就自己自定义吧！！不过 刚入门linux 的小伙伴还是先熟悉命令在偷懒，不然连原始命令都忘了( ⊙ o ⊙ )啊！","tags":[{"name":"Linux","slug":"Linux","permalink":"https://dawnki.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://dawnki.github.io/tags/SSH/"},{"name":"Bash","slug":"Bash","permalink":"https://dawnki.github.io/tags/Bash/"},{"name":"alias","slug":"alias","permalink":"https://dawnki.github.io/tags/alias/"}]},{"title":"Linux下go1.8安装方法","date":"2017-08-11T17:23:44.000Z","path":"2017/08/12/Linux下go1-8安装方法/","text":"之前迷上了神奇的Go语言，就在windows上装上了Go1.8，挺顺风顺水的，不过最近换上了Linux时，编译安装就炸了，各种报错。今天就留个记录，备个份！ 编译安装Go1.8的主体思路: 从github中clone下来 确保linux系统安装较新的libc,gcc(apt,yum随便搞上) 切换库分支至1.4(刚clone下来的库)，去到src目录，执行all.bash 把编译安装完的1.4目录cp到/root/，并更名为go1.4 将刚刚的编译安装的仓库恢复原状(git clean -dfx),在切换到1.8，同样刚刚的操作，执行all.bash,安装1.8 然后1.8安装完后，配置profile 坑点 1.由于Go1.8的安装需要go1.4的二进制，所以，如果没安装go1.4的小伙伴，直接安装1.8估计会这样 1Set $GOROOT_BOOTSTRAP to a working Go tree &gt;= Go 1.4. 这个GOROOT_BOOTSTRAP地址默认在/root/go1.4(~/go1.4) 2.用all.bash安装1.4时炸了 报错如下 12345# cmd/pprof.../go1.4/pkg/linux_amd64/runtime/cgo.a(_all.o): unknown relocation type 42; compiled without -fpic?.../go1.4/pkg/linux_amd64/runtime/cgo.a(_all.o): unknown relocation type 42; compiled without -fpic?runtime/cgo(.text): unexpected relocation type 298runtime/cgo(.text): unexpected relocation type 298 拿去不用谢我.jpg 所以解决方案是 12$ cd ~/go1.4/src$ CGO_ENABLED=0 ./make.bash 导致的原因是:CGO_ENABLED: Controls cgo usage during the build. Set it to 1 to include all cgo related files, .c and .go file with “cgo” build directive, in the build. Set it to 0 to ignore them.在构建过程中控制cgo的使用。当设置为1，在构建时，会包含所有cgo相关的文件，如带有”cgo”编译指令的.c和.go文件。当设置为0，则忽略它们（即禁用CGO） 3.在顺利的安装完1.4后再安装1.8，应该也没问题了，最后设置一下环境变量 1vim /ect/profile 在里面加上: 123# Golang Envexport PATH=$PATH:/home/xx/go/bin //xx根据实际情况填写export GOPATH=/home/xx/go-projects //xx根据实际情况填写 然后重启电脑，执行 1go version 显示到版本号的话就可以愉快的玩耍了！ 总结虽然安装的历程有点坎坷，不过看在go编程这么奇葩有趣的份上，忍了吧！O(∩_∩)O哈哈~ 参考中国网络环境下源码编译安装Go1.6","tags":[{"name":"Go1.8","slug":"Go1-8","permalink":"https://dawnki.github.io/tags/Go1-8/"},{"name":"Linux","slug":"Linux","permalink":"https://dawnki.github.io/tags/Linux/"}]},{"title":"mysql锁机制知识整理","date":"2017-08-08T08:56:20.000Z","path":"2017/08/08/浅谈mysql锁机制/","text":"并发处理时我们经常谈到的问题。在数据库操作中，有时候需要考虑并发的问题，比如我们常见的库存管理系统以及银行转账等问题，这些场景都需要用到数据库的锁机制以及事务，不然很容易造成”脏数据”等常见的在并发中遇到的问题。今天浅谈一下mysql锁机制。 表级锁与行级锁Mysql的锁机制大概分为两种，一种是表级锁，一种是行级锁。顾名思义，表级锁就是在进行读写操作时，把涉及到的目标表锁住，阻塞其他连接对相关表的操作。行级锁就是粒度更细了，精确到了表里的某条纪录。 表级锁 行级锁 开销 少 大 冲突 高 低 是否可能死锁 否 是 并发度 低 高 Mysql中的Innodb引擎支持行级锁以及表级锁，MyIsam只支持表级锁。表级锁中，当一个连接给一个加锁后，只能访问或者修改加锁的表，而不能再访问其他表了，除非解锁，这就破坏了死锁中的占有且等待条件，因而不用担心造成死锁的问题。 并发问题 更新丢失(Lost Update):简单来说就是两个连接(事务)同时对一行进行更新，最后导致了晚一点点更新的会覆盖掉之前更新的。解决办法就是在一个连接进行更改操作时，不允许其他连接访问就可以避免更新丢失的问题。 脏读(Dirty Reads):一个事务对一条记录进行修改时(未提交)，此时其他事务对这条记录进行读操作，导致读取的是旧数据，非最新的修改数据，因而数据脏读。 不可重复读(Non-Repeatable Reads):一个事务在读取某些数据后的某个时间，再次读取之前读过的数据，但是数据可能已经发生更改，之前读到的数据不一致。 幻读(Phantom Reads):一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。 InnoDB的行锁模式及加锁方法 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。 InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过 索引 条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁. 避免死锁 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。 参考 Mysql中那些锁机制之InnoDB","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"并发","slug":"并发","permalink":"https://dawnki.github.io/tags/并发/"},{"name":"锁机制","slug":"锁机制","permalink":"https://dawnki.github.io/tags/锁机制/"}]},{"title":"SOLID原则","date":"2017-08-08T06:44:49.000Z","path":"2017/08/08/solid/","text":"SOLID原则其实是由面向对象的五大设计原则组成，也是各种设计模式的基础理论。适当遵守SOLID原则，能写出高内聚，松耦合的代码，便于当需求变动能更快的拓展。废话不多说，下面立即正片。 原则名称 英文原义 中文含义 Single Responsibility Principle A class should have one, and only one, reason to change. 单一责任原则 Open Closed Principle You should be able to extend a classes behavior, without modifying it. 开放封闭原则 Liskov Substitution Principle Derived classes must be substitutable for their base classes. 里氏替换原则 Interface Segregation Principle Make fine grained interfaces that are client specific. 接口分离原则 Dependency Inversion Principle Depend on abstractions, not on concretions. 依赖倒置原则 没错，S.O.L.I.D原则就是这五个原则的首字母简称，从气势来看就觉得很“结实”，下面就简单介绍各个原则的含义。 单一责任原则 当需要修改某个类的时候原因有且只有一个。原义就是这样，简单来说就是一个类只尽自己所责，不瞎掺和其他功能，因此只会因为 一个功能 的问题而修改一个类。这样做的好处是一个功能出问题了，调试或者更改时可以完全不会影响到另外有一个功能的执行。 开放封闭原则 当系统需要增加新功能的时候，我们应该在原基础上进行拓展，而不是从零开始把之前的代码都修改了。其实这个原则在继承中得到体现，比如由抽象的鸟类，下面的蜂鸟，金丝雀等都继承鸟类这个类，当出现新的鸟物种时，应当在由鸟类的基础上进行继承然后在子类进行拓展的，而不是因为新物种的特性而修改父类。总而言之，对拓展是开放的，对修改是封闭的 。这样做的好处是完全不用担心影响之前运行良好的代码，放心拓展！ 里氏替换原则 用到父类实例的地方，把父类实例替换成子类实例应当时 无缝替换 ，照样能跑通的。之后的依赖倒置原则会告诉我们具体的东西应该依赖抽象，具体的东西(如客户端，展现层)在使用具体服务时，应当时使用父类实例，然后根据多态来真实用到子类的功能，如果不按里氏替换原则来的话，当客户端用到服务时，还要根据子类的具体情况进行调整，这样子类需要修改时，就要改两处(子类和客户端)，不便修改。因此需要做到用到父类的地方，换成子类照样无缝替换，这样如果功能出问题了，我们第一反应是只要修改子类即可！ 接口分离原则 接口分离原则就是当一个类实现了一个接口后，接口里面的方法都是对这个类有用的，不存在方法体为空来实现(强迫实现)。就是说，一个接口不要太过臃肿，应该粒度更细 ，因为如果接口太过臃肿，可能导致实现类实现了不属于它自己责任的方法从而违反了单一责任原则。 依赖倒置原则 具体类应该依赖抽象类，高级代码 应当也依赖抽象类 ，而不是依赖低级代码。首先先来说下，高级代码和低级代码都是具体类，其中低级代码指提供基础实现的代码，比如读写文件类，图片上传类，但是他们是具体，比如这个图片上传类是将图片上传到七牛的。其中高级代码是涉及到业务逻辑的代码，如需要用到图片上传用作头像的业务代码。这样就有个问题了，明显高级代码依赖低级代码嘛，不依赖低级代码似不似傻？但是假如有一天七牛上传图片崩了，你需要换其他图片上传服务，但是由之前高级代码依赖低级代码，所以高级类里面全tm都是低级类的片段，想想改起来就觉得可啪！！因此假如一开就依赖抽象，那样就能利用多态灵活更改了。 总结 遵守好的设计理念，不一定做出好的产品。但是用不好的设计，肯定做不出好东西！ 设计模式以及理念这东西，应该是理解本质后灵活使用的，而不是死记硬背，不然死记硬背的东西，到时候实操起来也不会第一时间想到使用！！","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://dawnki.github.io/tags/设计模式/"},{"name":"SOLID原则","slug":"SOLID原则","permalink":"https://dawnki.github.io/tags/SOLID原则/"}]},{"title":"异步同步阻塞非阻塞详解","date":"2017-07-31T14:39:10.000Z","path":"2017/07/31/async/","text":"相信刚入门计算机科学的小伙伴们来说，这四个词–异步，同步，阻塞，非阻塞，直接搞晕，因为单单理解四个词就算了，他们还能组合，同步阻塞，同步非阻塞，异步阻塞，异步非阻塞+_+。因此今天就主要谈谈这几个词，顺便备个份，怕是我哪一天忘记了回来看看2333333 首先，这些概念出现的场景发生在应用程序调用系统内核之间。我们知道例如十分耗时的IO操作就是由内核完成的，由于应用程序（cpu）处理的速度十分快，而IO处理很慢，所以就有了等待与不等待的问题，因此就有了以上各个词的出现。 单个解析 1.同步，在调用方层面（上文中的应用程序）上，当应用程序发起同步调用时，这个应用程序脑袋很倔，一心只想把眼前的事做完（获取处理结果才算做完）在做其它的，因此他需要被调方（IO）返回到了处理结果时才会结束 2.异步，在调用方层面上，当应用程序发起异步调用时，这个应用程序就很机灵了，当它发起调用后，不需被调方返回处理结果，直接去干别的事，如果被调方（IO）处理完了事情后，通过通知的方式通知它就好 3.阻塞，在被调用方层面上，当被调方（IO）接收到调用通知之后，会把调用方（应用程序）挂着，不会跟调用方说一句话，直到自己处理完数据后，把数据复制到内存，然后再把结果返回给应用程序。这就像不解风情的程序猿与测试妹子，妹子告诉程序猿:”你这里有bug！” 然后程序猿一句话也不理妹子，埋头去debug，直到修复了，才告诉妹子说bug修复了/(ㄒoㄒ)/ （注孤生啊！） 4.非阻塞，在被调用方层面上，当被调方接受到调用通知之后，会先返回信息告诉调用方:”我知道了，你先去忙别的吧”。注意这里返回的信息与完成处理任务返回的信息时两码事，事情还没做完（处理IO任务）！！所以说这个程序猿就很有情商了，可以可以O(∩_∩)O 组合解析同步阻塞：一个很倔的测试妹子与一个注孤生的程序猿 过程：当调用方发起调用时，调用者一直等待处理的结果才结束，而被调者在发生调用后，也不会立即返回，而是处理完一系列流程（如磁盘寻道-&gt;读取数据-&gt;复制数据到内存）时，才返回处理结果给调用者，其间把调用方挂起。 例子：一个等着bug修复完做其他事的妹子去找（调用）注孤生的程序猿，程序猿知道后，一声不吭就debug，直到修复完bug，返回处理结果给妹子，妹子收到结果后，就去做其他事了。 同步非阻塞：一个很倔的测试妹子与一个很机灵的程序猿 过程：当调用方发起调用时，调用者需要被调方得到处理结果才结束，而被调者在发生调用后，立即返回信息给调用者，不过还没得到处理内容，当调用者发现得到的不是处理结果，继续发起调用，而被调者依然立即返回，如此反复，直到被调者在过程中处理完信息，然后返回给处理结果给调用者，调用者得到处理结果后，结束调用。 例子：一个很倔的测试妹子去找一个机灵的程序猿，程序猿告诉她先去干别的事，妹子收到信息后，回到自己的座位上，想了想我还要等到那个bug修复完，因此继续找程序猿，程序猿又告诉她回去等，如此反复，程序猿在一边被骚扰一边修复bug直到修复完毕后，把结果告诉妹子，妹子得到结果开心的做其他事了。 异步阻塞：一个机灵的测试妹子与一个注孤生的程序猿 过程：当调用者发起调用时，被调者收到调用通知后，把调用者挂起，而自己就去处理数据，直到处理完毕后，把挂起的调用者拉回来，把结果返回给它，然后结束调用。 例子：一个很机灵的妹子，在发现了bug后，本来想先通知（调用）一下程序猿，然后自己就去干别的事，结果在她找到程序猿后，这个不识趣情商低的程序猿，直接不理妹子，让妹子在那儿干等（挂起），直到自己把bug修复完之后，就告诉一直站在那儿的妹子说，bug修复完了，你可以走了（妹子拿到了结果）。 由于太过奇葩，概念图片不予展示2333333 异步非阻塞：一个很机灵的测试妹子与一个很机灵的程序猿 过程：当调用方发起调用时，被调者收到调用通知后，立即返回给调用者，告诉它可以接到调用通知了，然后调用者去开始其他任务（注意：调用在这里已经结束了），而被调用者在完成调用任务得到处理结果后，通过通知的形式告诉调用方。 例子：一个很机灵的妹子，在发现了bug后，找到了机灵的程序猿，说：”帅哥，你这里有bug”，程序猿知道后说：“好的，这里交给我，你先去忙别的吧！”。然后妹子就去忙别的事了，程序猿就开始debug，在修复完bug后，发了封邮件通知测试妹子。（于是他们两个就在一起了O(∩_∩)O） 撒花w_w 通过我上面的举例，大家应该知道哪对会修成正果吧？没错就是异步非阻塞，还有同步阻塞。异步非阻塞合理的利用了cpu的空闲时间，不让干等，大大提高了工作效率，在处理并行中十分常用。而同步阻塞，虽然这两个都奇葩，但是这两个奇葩在一起也好过剩下更加两对搭配，算是中规中矩吧。所以目前大多的应用要么就采用异步非阻塞，要么就采用同步阻塞，剩下两对因为不太科学，所以少人用～ 通过这样搞笑的解析，大家应该都明白了吧？不明白的话，多看几次例子以及概念图！！过几天我发一篇关于机智程序猿如何发邮件给测试妹子(被调用者通知调用者)的博客 感谢 概念图来源","tags":[{"name":"同步阻塞","slug":"同步阻塞","permalink":"https://dawnki.github.io/tags/同步阻塞/"},{"name":"异步非阻塞","slug":"异步非阻塞","permalink":"https://dawnki.github.io/tags/异步非阻塞/"},{"name":"并行技术","slug":"并行技术","permalink":"https://dawnki.github.io/tags/并行技术/"}]},{"title":"JWT-Auth&Laravel-Auth源码浅读","date":"2017-07-28T17:04:12.000Z","path":"2017/07/29/JWT-Auth&Laravel-Auth源码浅读/","text":"故事发生月黑风高的…..啊呸，扯题了。简单来说前几天在配置JWT-Auth的时候，因为自己建的用户表没有用国际标准的’password’字段，而是自己随便起了个userPassword，导致不是在挖坑就是在挖坑的路上.不得不阅读其源码解决问题。 前置条件不过结构复杂的Laravel，里面运用了许多魔术方法及其核心的Ioc容器，阅读前拿到以下几种工具才好动手: 读一下Laravel作者的From Apprentice To Artisan(感谢中文翻译者) ，宛如laravel中的行动纲领 Laravel自带helper函数dd(),用于单步调试，运行完立即退出脚本，方便知道某个方法究竟有没有执行或者取值是什么 phpstorm ，虽然遇到Laravel一片黄，不过能查到追踪到多少代码算多少，O(∩_∩)O哈哈~ 遇到某个类中有依赖注入的，二话不说先找其服务提供者，看看服务提供者的注册方法中将注入的接口(Contract)绑定的是哪个类,为了方便解释，先来个例子~ 123456789class A &#123; protected $test; // 这个Test不是一个接口算我输 public function __construct(Test $test) &#123; $this-&gt;test=$test; &#125;&#125; 上文注入的Test，用phpstorm的ctrl+b追踪到的肯定是个接口.那么实际传给这个构造方法的实例是什么呢？在这个类附近找找provider字眼的类不会太远(看起来不太靠谱但是却有效,哈哈哈)，或者去/config/app.php里面找找 123456789101112//假装我找到了对应的providerclass TestServiceProvider extends ServiceProvider&#123; //关键是找register的内容 public function register() &#123; $this-&gt;app-&gt;bind('Test',function()&#123; // 假装有个叫做TestImplemet的类实现了上文的Test接口 return new TestImplement(); &#125;); &#125;&#125; 上文register方法里的bind,都是Laravel的Ioc容器(控制反转容器)的骚操作,简单地理解是Laravel帮你管理类实例,管理他们的生命周期,不用你到处new来new去,耦合代码,目的是彻底模块化,一个类只负责自己的东西,自己类里尽量不new别模块的类。 就是作者所说的严守类的边界(Respect Boundaries) 回归正题原来往A类里注入的是TestImplement类的实例,原来似李啊TestImplement,赶紧给我负责吖混蛋！(感觉污污的..Orz) 所以基本方针就这样，掌握了工具之后，就开始填坑吧！ 遇到问题 环境：Laravel5.2 依赖: JWT-Auth 1.0.0-beta.3 当我使用了JWT-Auth之后，由于模型里的密码字段是adminPass，在注册好服务提供者，做好各种配置之后，使用JWTAuth::attempt()方法验证账号密码时，我填入的数组是 1234[ &quot;phone&quot; =&gt; &apos;xxxxxx&apos;, // 此处充当账号 &quot;adminPass&quot; =&gt; &apos;xxxxxx&apos;] 然后attempt方法一直返回false，按照常理账号密码没有错的话，jwt会自动生成token返回，在确认其他配置没问题的情况下，只能硬着头皮去翻源码，逐步测试。 一步一步溯源根据attempt线索追踪根源 因为使用了先找出JWTAuth::attempt()所在的类.由于此处使用了JWTAuth的门面，我们先去JWTAuth里面看看它要拿的是哪个类 Laravel的门面其实就是为服务类提供”静态”接口，看似我们不需要实例化对象，然后再用A::method()这样的类似静态方法的方式调用服务类的方法。其实质是laravel从用户的门面调用方法中，拿到用户的要调用的方法以及参数，然后从Ioc容器里拿到对应的服务类实例，然后使用php灵活的回调函数，让这个实例执行用户填入的方法及其参数，具体的源码分析会在之后浅读一蛤然后再写篇博客(挖坑) 12345678910111213class JWTAuth extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; //经过Facade(门面)一系列操作，向Ioc容器中拿出注册名叫tymon.jwt.auth的实例 return 'tymon.jwt.auth'; &#125;&#125; 耐心地找到Tymon\\JWTAuth\\Providers\\AbstractServiceProvider，找到以下注册信息 123456789101112131415/** * Register the bindings for the main JWTAuth class. * * @return void */protected function registerJWTAuth()&#123; $this-&gt;app-&gt;singleton('tymon.jwt.auth', function ($app) &#123; return new JWTAuth( $app['tymon.jwt.manager'], $app['tymon.jwt.provider.auth'], $app['tymon.jwt.parser'] ); &#125;);&#125; 翻翻Tymon\\JWTAuth的目录，所以门面拿到的实例就是Tymon\\JWTAuth\\JWTAuth.php 诚不欺我，果然JWTAuth.php 有attempt方法 123456789101112131415/** * Attempt to authenticate the user and return the token. * * @param array $credentials * * @return false|string */public function attempt(array $credentials)&#123; if (! $this-&gt;auth-&gt;byCredentials($credentials)) &#123; return false; &#125; return $this-&gt;fromUser($this-&gt;user());&#125; 侦查手段（套路）$credentials数组就是我们问题里传入验证数组，验证数组又传给了$this-&gt;auth-&gt;byCredentials($credentials)，这个方法，相信大家已经知道套路了吧？没错他这个JWTAuth又注入了一个类实例来执行byCredentials方法，所以执行我们的套路 先翻一下构造器，注入的是什么接口 然后找找附近的provider，给这个接口绑定的是什么类实例 找到类实例，就是实际注入JWTAuth类的实例 所以通过一顿操作,JWTAuth.php的构造器如下 12345678910111213141516/** * @var \\Tymon\\JWTAuth\\Contracts\\Providers\\Auth */protected $auth;/** * @param \\Tymon\\JWTAuth\\Manager $manager * @param \\Tymon\\JWTAuth\\Contracts\\Providers\\Auth $auth * @param \\Tymon\\JWTAuth\\Http\\Parser\\Parser $parser * * @return void */public function __construct(Manager $manager, Auth $auth, Parser $parser)&#123; parent::__construct($manager, $parser); $this-&gt;auth = $auth;&#125; 所以锁定\\Tymon\\JWTAuth\\Contracts\\Providers\\Auth，继续翻AbstractServiceProvider 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected function registerAliases()&#123; $this-&gt;app-&gt;alias('tymon.jwt', JWT::class); $this-&gt;app-&gt;alias('tymon.jwt.auth', JWTAuth::class); $this-&gt;app-&gt;alias('tymon.jwt.provider.jwt', JWTContract::class); $this-&gt;app-&gt;alias('tymon.jwt.provider.auth', Auth::class); $this-&gt;app-&gt;alias('tymon.jwt.provider.storage', Storage::class); $this-&gt;app-&gt;alias('tymon.jwt.manager', Manager::class); $this-&gt;app-&gt;alias('tymon.jwt.blacklist', Blacklist::class); $this-&gt;app-&gt;alias('tymon.jwt.payload.factory', Factory::class); $this-&gt;app-&gt;alias('tymon.jwt.validators.payload', PayloadValidator::class);&#125;protected function registerAuthProvider()&#123; $this-&gt;app-&gt;singleton('tymon.jwt.provider.auth', function () &#123; return $this-&gt;getConfigInstance('providers.auth'); &#125;);&#125;protected function getConfigInstance($key)&#123; $instance = $this-&gt;config($key); if (is_string($instance)) &#123; return $this-&gt;app-&gt;make($instance); &#125; return $instance;&#125;protected function config($key, $default = null)&#123; return config(\"jwt.$key\", $default);&#125;// 此方法在helper中function config($key = null, $default = null)&#123; if (is_null($key)) &#123; return app('config'); &#125; if (is_array($key)) &#123; return app('config')-&gt;set($key); &#125; return app('config')-&gt;get($key, $default);&#125; 上面一连串貌似很复杂，其实就是\\Tymon\\JWTAuth\\Contracts\\Providers\\Auth::class起个别名叫做tymon.jwt.provider.auth，然后registerAuthProvider方法就是正式的绑定方法，通过一连串操作，最终是从/config/jwt.php(如果没用publish命令的，则访问tymon目录里的config) 拿出providers键名里，auth键名的东西 12345678910//就是Tymon\\JWTAuth\\Providers\\Auth\\Illuminate::class'providers' =&gt; [ 'jwt' =&gt; Tymon\\JWTAuth\\Providers\\JWT\\Namshi::class, 'auth' =&gt; Tymon\\JWTAuth\\Providers\\Auth\\Illuminate::class, 'storage' =&gt; Tymon\\JWTAuth\\Providers\\Storage\\Illuminate::class, ] laravel自带的helper中的config十分实用，一般我们开发是都是把配置数据以数组形式存入/config/脚本里，然后用config函数来通过键名(通常写法是xxxx.xxx.xx)读取对应的值 所以回到我们的目的attempt需要注入的auth，而注入的auth实际是Tymon\\JWTAuth\\Providers\\Auth\\Illuminate::class，同样的套路，里面的byCredentials方法里面注入了\\Illuminate\\Contracts\\Auth\\Guard，这个接口是属于Laravel的，而不是JWT内部的，这就是为什么JWT-auth切合了Laravel自带的Auth的原因，然后通过AbstractServiceProvider，我们可以知道，Laravel注册了自己的Auth时会翻一下配置文件/config/auth.php，然后根据guard里的driver来选择验证驱动，这就是为什么配置JWT-auth时需要配置/config/auth.php的原因 举一反三，找出罪魁祸首选择jwt作为guard驱动时，根据上面一流程的套路，就可以发现JWTAuth里面用到的byCredentials方法来自于JWTGuard，然后JWTGuard属于Laravel的拓展Guard，也是使用Laravel的一些功能，例如EloquentUserProvider,这个就是将我们的传入的数组与数据作对比的服务提供类,用到这两个方法retrieveByCredentials,validateCredentials 1234567891011121314151617181920212223//EloquentUserProvider.php public function retrieveByCredentials(array $credentials) &#123; if (empty($credentials)) &#123; return; &#125; $query = $this-&gt;createModel()-&gt;newQuery(); foreach ($credentials as $key =&gt; $value) &#123; if (! Str::contains($key, 'password')) &#123; $query-&gt;where($key, $value); &#125; &#125; return $query-&gt;first(); &#125; public function validateCredentials(UserContract $user, array $credentials) &#123; $plain = $credentials['password']; return $this-&gt;hasher-&gt;check($plain, $user-&gt;getAuthPassword()); &#125; 介绍下这两个方法的作用: retrieveByCredentials,通过验证数组，查询数据库(查询条件除去password) validateCredentials,拿到的数据与验证数组作对比，包括密码，当然密码是使用hash的check方法来检查的 结案陈词可见validateCredentials方法里$credentials[‘password’]这里就是限定我们attempt一定填入password字段名的原因，不填入这个字段名会报password index not found的异常，至于我传入的[‘phone’=&gt;’xxx’,’adminPass’=&gt;’xxxx’],没有报异常，是因为上面的retrieveByCredentials方法，正常会把非’password’字段纳入查询，所以把adminPass，导致方法返回false，导致于下面的validateCredentials方法因主调方(没记错的话主调方是JWTGuard里的attempt方法)的条件控制而进入不了，因而不报异常，直接返回false 总结&amp;收获通过这次阅读，让我接触到了laravel的核心部分，服务提供者，依赖注入等等，以及大概了解了laravel自带的权限认证时怎样的。其内部十分复杂，突出的一点是子模块特别的多！其实这体现了Laravel作者Taylor Otwell的设计理念，严守边界，一个类只实现自己的东西，绝不干涉其他类，以及利用了大量的面向接口编程，这种松耦合在开发拓展(遵循开放封闭原则)的时候，也能易于维护。唯一的缺点感觉就是不易于快速入门了，需要慢慢翻看。总的来说耐心是第一要务，没有耐心研究，什么都白谈~","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"JWT-Auth","slug":"JWT-Auth","permalink":"https://dawnki.github.io/tags/JWT-Auth/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://dawnki.github.io/tags/源码阅读/"}]},{"title":"Laravel中应用JWT","date":"2017-07-26T16:15:22.000Z","path":"2017/07/27/JWT/","text":"JWT-Json Web Token，一种基于json格式的开放标准，常常被用作替代cookie的认证方式，特别适合前后端分离的WEB应用，以及api接口。今天就讲讲如何在Laravel应用中使用JWT，虽然网上找到的Laravel集成JWT的方法，不过要么就坑点太多，要么就有诸多限制（比如要验证的模型有多个怎么配置）。 实验环境 Laravel 5.2+ PHP 5.5+ tymon/jwt-auth 1.0.0-beta.3 (十分重要) 起步利用composer安装jwt-atuh 在你的Laravel项目目录里composer.json补充上以下 12345&#123; \"required\" : &#123; \"tymon/jwt-auth\" : \"1.0.0-beta.3\" # 这个版本很急很关键，我用这个版本才能跑通..Orz &#125;&#125; 然后安装一下依赖 1$ composer update 配置Laravel的服务提供者及其门面 在/config/app.php里找到对应的数组，补充以下东西 1234567'providers' =&gt; [ Tymon\\JWTAuth\\Providers\\LaravelServiceProvider::class,]'aliases' =&gt; [ 'JWTAuth' =&gt; Tymon\\JWTAuth\\Facades\\JWTFactory::class,] 配置你的用户表（用户模型） 因为Jwt-auth默认用的是Laravel的auth权限管理，Laravel 的权限管理默认用的是项目一开始就有的User模型(/app/User.php)，下面姑且先用着Laravel的User模型为例，至于如何自定义用户模型使用其他表，我待会再讲 1234567891011121314151617181920212223242526272829&lt;?phpnamespace App;use Illuminate\\Foundation\\Auth\\User as Authenticatable;use Tymon\\JWTAuth\\Contracts\\JWTSubject;class User extends Authenticatable implements JWTSubject&#123; protected $fillable = [ 'name', 'email', 'password', ]; protected $hidden = [ 'password', 'remember_token', ]; // JWT-Auth默认要实现的方法 public function getJWTIdentifier() &#123; return $this-&gt;getKey(); &#125; // JWT-Auth默认要实现的方法 public function getJWTCustomClaims() &#123; return []; &#125;&#125; 可见，配置用户表只需继承Illuminate\\Foundation\\Auth\\User这个类，实现JWTSubject这个接口的两个方法即可。不过这个表必须要有password这个字段，必须有主键, 至于如果你的用户表不用password而是用userPass等等自己自定义的字段名怎么办，这个我待会再讲~ 配置Laravel的auth /config/auth.php 123456789101112131415161718192021222324252627'defaults' =&gt; [ 'guard' =&gt; 'api', // 此处改成api 'passwords' =&gt; 'users',],'guards' =&gt; [ 'web' =&gt; [ 'driver' =&gt; 'session', 'provider' =&gt; 'users', ], 'api' =&gt; [ 'driver' =&gt; 'jwt', // 此处改成jwt 'provider' =&gt; 'users', ],],'providers' =&gt; [ 'users' =&gt; [ 'driver' =&gt; 'eloquent', 'model' =&gt; App\\User::class, //你实际用到的用户表(用户模型)],// 'users' =&gt; [// 'driver' =&gt; 'database',// 'table' =&gt; 'users',// ],], 生成JWT密钥12$ php artisan vendor:publish # 将jwt的配置文件自动拉到/config目录$ php artisan jwt:secret # 自动生成JWT密钥，具体可看.env文件 实际业务逻辑 可以直接在你的控制器里进行调试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace App\\Http\\Controllers;use App\\User;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Auth;use Tymon\\JWTAuth\\Facades\\JWTAuth;class TestController extends Controller&#123; /** * 注册 */ public function register() &#123; User::create([ 'name' =&gt; 'Dawnki', 'phone' =&gt; '188xxxxxx', //此处例子假设以手机为账号 'password' =&gt; bcrypt('123456') //加密务必用Laravel中hepler提供的bcrypt ]); &#125; /** * 登录 * @param Request $request */ public function login(Request $request) &#123; //attempt方法用于验证帐号信息 成功则生成token值 //attempt必须有\"password\"字段，无论你是自定义密码字段 $token = JWTAuth::attempt(['phone'=&gt;'188xxxxxx','password'=&gt;123456]); return response(json_encode(['token'=&gt;$token]),200); &#125; /** * 访问内部页面 * 附上Header \"Authorization\" : \"Bearer token值\" 注意Bearer与token值间的空格 * @param Request $request * @return mixed */ public function index(Request $request) &#123; //return Auth::id(); //直接获取用户id return Auth::guard('api')-&gt;user(); //直接获取用户model &#125;&#125; 给index方法（即实际业务里的内部需要登陆后才能访问的接口）编写一个中间件12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\Http\\Middleware;use Closure;use Illuminate\\Support\\Facades\\Auth;/** * Class UserMiddleware 用户中间件 * @package App\\Http\\Middleware */class UserMiddleware&#123; protected $auth; function __construct(Auth $auth) &#123; $this-&gt;auth = $auth; &#125; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next, $guard = 'api') &#123; if (!($user = Auth::guard($guard)-&gt;user())) &#123; // token值不对 根据实际情况编写返回错误信息,此处返回只作样例 return response('token',403); &#125; return $next($request); &#125;&#125; 此处只显示中间件的关键方法，至于如何给内部接口（如上例中的index方法）配置中间件自行解决，关键的验证即是 Auth::guard(‘api’)-&gt;user(); 当前端把Token值放入Header中， 即 “Authorization” : “Bearer token值”（注意Bearer与token值中的空格）. Jwt-Auth结合了Laravel的Auth就会通过user()方法自动从Header中取出token值，并且从中解密找出隐含在其中的用户摘要(id). 注意坑点:用户表的加密方式 务必使用bcrypt(即哈希加密),不要使用Crypt门面提供的加密，不要使用Crypt门面提供的加密，不要使用Crypt门面提供的加密!Crypt的加密不适合数据库迁移! 自定义你的用户模型首先自定义用户模型，不使用自带的User模型1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Foundation\\Auth\\User;use Tymon\\JWTAuth\\Contracts\\JWTSubject;class Admin extends User implements JWTSubject&#123; protected $table=\"admin\"; protected $primaryKey=\"admin_id\"; protected $fillable=[\"admin_name\",\"adminPass\"]; protected $guarded=''; protected $hidden=[\"adminPass\"]; public function getJWTIdentifier() &#123; return $this-&gt;getKey(); &#125; public function getJWTCustomClaims() &#123; return []; &#125; /** * 重写的方法 */ public function getAuthPassword() &#123; return $this-&gt;getAttribute('adminPass'); # 表中密码字段是adminPass &#125;&#125; 如上，只需继承User,实现JWTSubject。另外如果你表密码字段不是password，而是其他（如上的adminPass）,只需重写getAuthPassword方法(来自于Illuminate\\Foundation\\Auth\\User中用到的trait)即可 然后在/config/auth.php中修改 123456&lt;?php &apos;providers&apos; =&gt; [ &apos;users&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;eloquent&apos;, &apos;model&apos; =&gt; App\\Admin::class, //你需要的类 ] 然后你就可以使用自己编写的用户模型,又能搭配上JWT了! 另外此处有一个坑点就是你自定义的密码字段， 在attempt验证账号登陆时是要注意一些细节 12345678910&lt;?php /** * 登录 * @param Request $request */ public function login(Request $request) &#123; $token = JWTAuth::attempt(['phone'=&gt;'188xxxxxx','password'=&gt;123456]); return response(json_encode(['token'=&gt;$token]),200); &#125; 上例，我自定义的密码字段为adminPass，在调用attempt时，不要顺理成章的在验证数组里使用adminPass，依然是使用’password’，这是由于attempt方法内部的限定，在下一篇博客将详细介绍为何要这样~~如果你表里的字段是password的那就没你的事啦，此处只针对自定义的密码字段名 使用两个以上需要权限认证的表 比如一个系统中，有管理员和普通用户，他们分别存在两张不同的表(模型) 只需使用上 Config方法动态修改auth.php的model 即可 12345678910111213&lt;?php public function adminLogin(Request $request) &#123; Config::set('auth.providers.users.model',\\App\\Admin::class); #对应管理员表 // Todo your admin login method &#125; public function userLogin(Request $request) &#123; Config::set('auth.providers.users.model',\\App\\User::class); #对应用户表 // Todo your user login method &#125; 总结 刚开始没看Jwt-auth的源码时，配置起来真的很累，用了各种版本都不，最终发现1.0.0-beta.3可以，又根据github里面的issue，找遍了各种自定义方法加上自己琢磨了一下，才能使得根据自己项目的业务需求尽心修改，当中算是了解了jwt-auth是如何跟laravel自带的auth结合在一起的，收获还算可以。 最后附上tymon大大的github,虽然被他的拓展折磨的很惨，不过十分感谢大大的贡献.","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"JWT","slug":"JWT","permalink":"https://dawnki.github.io/tags/JWT/"},{"name":"Tymon/jwt-auth","slug":"Tymon-jwt-auth","permalink":"https://dawnki.github.io/tags/Tymon-jwt-auth/"}]},{"title":"Laravel的数据填充Seeder食用方法","date":"2017-07-18T17:49:47.000Z","path":"2017/07/19/Seeder/","text":"在日常开发中，经常需要往数据库里填充数据，以便调试接口发现bug。Laravel自带的数据填充器seeder也十分好用，纯自动化填充，还支持一键回滚，只需在使用之前定义些方法即可，下面就介绍一下seeder普遍的用法。 版本 Laravel 5.2 流程介绍 生成Seeder填充类 按实际情况定义模型工厂 执行artisan命令自动化填充数据到数据库 回滚，恢复到实际生产环境 起步首先利用artisan命令创建一个seeder类 1$ php artisan make:seeder TestSeeder 在/database/seeds/中，编写run方法 123456789class TestSeeder extends Seeder&#123; public function run() &#123; DB::table('YourTable')-&gt;insert([ 'name' =&gt; str_random(10) ]); &#125;&#125; 如上，只需把插入语句写进seeder类的run方法即可。上面的例子是往YourTable表里插入一条记录，但是这是我们日常都是大批量填充数据的，此时就需要用到模型工厂。 一个模型单角色定义模型工厂的定义脚本在/database/factories/ModelFactory.php，我们只需脚本里定义好模型，然后就可以在seeder类里使用了。 123456789$factory-&gt;define(App\\YourModel::class,function (Faker\\Generator $faker)&#123; return [ 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;email, 'password' =&gt; str_random(10), 'remember_token' =&gt; str_random(10), 'admin' =&gt; true, ];&#125;); Faker是专门生成假数据的包(GITHUB地址),这样至少生成的假数据也好看点而不是一堆乱码数字对吧。 一个模型多角色定义除了用define字段定义模型外，我们常常还用到defineAs，因为通常一个模型(表)里面，存在这不同角色，比如User表里可以存在普通用户或者管理员两种角色，这时可以用defineAs 12345678910$factory-&gt;defineAs(App\\YourModel::class,'admin',function (Faker\\Generator $faker)&#123; return [ // blabla 按实际情况编写 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;email, 'password' =&gt; str_random(10), 'remember_token' =&gt; str_random(10), 'is_admin' =&gt; true, ];&#125;); 生产这样我们就定义好了一个模型工厂，要工厂生产产品就需要用到Laravel的全局函数factory.生产产品的工厂一定要是定义过的才能用factory函数 1234567// 以下写在seeder类的run方法里// 生产1个模型实例$obj=$factory-&gt;(App\\YourModel::class)-&gt;make();// 生产5个模型实例 返回类型为collection$collection=$factory-&gt;(App\\YourModel::class,5)-&gt;make();// 生产5个admin身份的模型实例$collection=$factory-&gt;(App\\YourModel::class,'admin',5)-&gt;make(); 处理关联数据库插入时也经常涉及关联，比如有两张表父表与子表，由于存在关联关系，设置了外键约束时，填充数据会很蛋疼，不过利用Laravel的eloquent使得填充数据十分方便，下面就讲一下如何操作 首先假设有两张表father和son，其中son的主键参照father表中的一个字段id father的模型： 1234567class father extends Model&#123; public function test()&#123; // Laravel 的模型关联方法 不清楚的可以补一下文档 return $this-&gt;hasMany(\\App\\son:class,'id'); &#125;&#125; son的模型细节我就忽略了，因为不是重点。接下来就要定义两个表的模型工厂 1234567891011$factory-&gt;define(App\\father::class,function ()&#123; return [ //blabla ] ;&#125;);$factory-&gt;define(App\\father::class,function ()&#123; return [ //blabla ] ;&#125;); 然后就可以在seeder类的run方法里使用了 12345factory(App\\father::class,3) -&gt;create() -&gt;each(function ($obj)&#123; $obj-&gt;test()-&gt;save(factory(App\\son::class,2)-&gt;make()); &#125;); 就可以在你填充3个父亲的数据的同时，也为每个父亲填充2个与之关联的儿子 填充器模块化一个填充器写N多个factory来填充数据，难免会看晕，因此我们需要将负责不同模型的生产分模块，划分成N多个子填充器 1234567public function run()&#123; Model::unguard(); $this-&gt;call(Test1Seeder::class); $this-&gt;call(Test2Seeder::class); // ....... Model::reguard();&#125; unguard函数貌似是关闭自动填充的限制，reguard是恢复限制.还有一个函数Model::truncate();用于放在成员函数里可以清空成员表数据，用来初始化填充还可以，不过有重要数据请备份。 最后一步在编写好seeder之后，运行artisan即可进行填充 12php artisan db:seedphp artisan db:seed --class=xxxxxSeeder // 你的填充类 一键回滚，重建数据库 1php artisan migrate:refresh --seed 坑点因为运行artisan命令时本质上是用CLI，因此请开启proc_open,proc_get_status等系统调用函数，留意你的CLI所用的拓展是否有对应数据库的拓展，如果遇到CLI的坑可以去翻一些我前几天些的关于CLI的坑，遇到什么permission denied的给对应文件加上权限就好。","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"Seeder","slug":"Seeder","permalink":"https://dawnki.github.io/tags/Seeder/"},{"name":"数据填充","slug":"数据填充","permalink":"https://dawnki.github.io/tags/数据填充/"}]},{"title":"Redis报错:MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk","date":"2017-07-16T09:06:53.000Z","path":"2017/07/16/Redis报错/","text":"在捣鼓redis时，一次不小心关闭了强制关闭了redis-cli，导致下次启动cli,进行数据插入操作时报错了，具体错误如下: (error) MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error. 在网上查了较多的资料最好的解决方式是启动redis-cli,然后 1$ 127.0.0.1:6379&gt; config set stop-writes-on-bgsave-error no 然后就OK了~老哥这方法贼稳，哈哈哈","tags":[{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"Redis","slug":"Redis","permalink":"https://dawnki.github.io/tags/Redis/"}]},{"title":"Linux环境下Redis安装并配置PHP","date":"2017-07-16T07:16:24.000Z","path":"2017/07/16/redis安装/","text":"Redis作为一种高效的nosql数据库，常常被用作为缓存，本篇就讲一下关于Redis的安装配置，以及怎么应用到PHP项目当中。 安装并配置Redis 下载官网最新且稳定的redis版本 1234wget http://download.redis.io/releases/redis-4.0.0.tar.gz # 此处安装的是redis4.0tar xzf redis-4.0.0.tar.gz # 解压下载完的压缩包cd redis-4.0.0 make # 编译安装 编译安装完之后，redis目录里会生成/src目录 下面是几个重要的文件路径 redis配置文件 /path/to/redis-xxx/redis.confredis服务端 /path/to/redis-xxx/src/redis-serverredis客户端 /path/to/redis-xxx/src/redis-cli 配置redis服务器守护进程 有时我们通过shell开启了redis-server之后，如果不把他放进守护进程就会一直占用我们的shell，因此需要把redis的服务端进程放进守护进程 1vi /path/to/redis-xxx/redis.conf 通过vi的/daemonize，找到守护进程的配置，把yes改为no保存退出即可. 下次开启redis-server时需要 1./redis-server ./../redis.conf # 即参数为配置文件的路径 也可以编写shell脚本redis-server,不用输入配置文件路径,随便找个地方放，不要放到src就行,具体如下 12#!/bin/bash`/path/to/redis-xxx/src/redis-server /path/to/redis-xxx/redis.conf` 然后加上执行权限 1sudo chmod +x redis-server # 此处的redis-server为刚刚编写的脚本 为了方便shell里直接启动，把软连接放到/usr/local/bin里 12ln -s /path/to/your-script/redis-server /usr/local/bin # 刚写的脚本路径ln -s /path/to/redis-xxx/src/redis-cli /usr/local/bin # 实际客户端的路径 这样即可在shell里开启带有守护的redis-server了，而不用输入配置文件路径参数，如下: 1redis-server 把Redis应用到PHP中 PHP连接redis有两种途径，一种是用phpredis拓展，由c编写的php拓展，因此处理效率较高，不过不支持PHP5.2以下的版本。第二种是用predis，是一个php包，可以理解为PHP应用来连接redis，效率没有phpredis不过适应高，容易部署。由于我在踩phpredis的坑时中招了，下面就用predis吧，毕竟简单易用。 我采用composer安装方式，在composer.json里附上 12345&#123; \"require\": &#123; \"predis/predis\": \"~1.1@dev\" &#125;&#125; 然后就可以用predis连接redis进行各种操作了,具体函数跟redis原生指令相差不大，在这就不多赘述 可以安装phpredisadmin管理你的redis，开发环境可以用，生产的话还是算了吧","tags":[{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"Linux","slug":"Linux","permalink":"https://dawnki.github.io/tags/Linux/"},{"name":"Redis","slug":"Redis","permalink":"https://dawnki.github.io/tags/Redis/"}]},{"title":"那些年PHP-CLI踩过的坑","date":"2017-07-14T11:32:54.000Z","path":"2017/07/14/cli的坑/","text":"最近在捣鼓swoole以及phpunit时，需要用到PHP-CLI（PHP的命令行模式），可是却中途却一直出现问题，就以phpunit为例，在用到调试数据库的断言时，出现could not find driver，以及在捣鼓swoole时，使用了swoole的定义类缺找不到，最终原来发现PHP-CLI模式的拓展与PHP-FPM那边的拓展配置不一致导致的。 基础 在填坑前先介绍下几个路径以及命令： /usr/local/php 通常是通过网页调用PHP脚本(FastCGI,FPM)时，php配置以及拓展放置的目录 /usr/bin/ 用户命令放置的地方，也是PHP-CLI调用php命令放置的地方 php -m 查看CLI模式下加载的拓展以及模块 在脚本中编写phpinfo();然后网页访问，可以查看网络调用脚本时加载的拓展和模块 /etc/php 在某些情况下，PHP-CLI调用PHP脚本时，php配置以及拓展放置的目录，也是本文的罪魁祸首 步骤 在linux里安装多个PHP版本或者，安装过PHP7时有可能会出现CLI模式与普通模式(网页调用PHP脚本)配置以及模块不一致的情况，由于我是用LNMP安装的PHP7，之后有安装了PHPStorm，不知是不是乱搞的关系，导致CLI与普通模式加载配置不一致了，在折腾Swoole时就明显发现了这个问题。 要知道模块是否加载一致，普通模式用phpinfo() ，命令行模式直接用php -m就可以查到模块是否一致了。 若不一致时，绝大多是/usr/bin/php(大多是软连接)指向/etc/php/bin目录里的php 1ls -li 软链接文件 # 这样既可找到链接指向的源文件 要解决也是十分简单，只需把/usr/local/php/bin里面的php的软连接放到/usr/bin/里即可，注意要把之前/usr/bin/里的php删掉 12rm -rf /usr/bin/phpln -s /usr/lcoal/php/bin/php /usr/bin/php # 软连接的两个参数都需写绝对路径 接着在命令行里 1php -m 即可发现CLI模式加载的模块就与普通模式保持一致了","tags":[{"name":"Linux","slug":"Linux","permalink":"https://dawnki.github.io/tags/Linux/"},{"name":"PHP CLI","slug":"PHP-CLI","permalink":"https://dawnki.github.io/tags/PHP-CLI/"},{"name":"Swoole","slug":"Swoole","permalink":"https://dawnki.github.io/tags/Swoole/"}]},{"title":"PHP实现链式操作","date":"2017-07-06T13:11:32.000Z","path":"2017/07/06/链式操作/","text":"玩耍过jQuery的朋友们应该对链式操作不陌生，链式操作在实际应用上不仅美观，并且代码容易阅读，下面用PHP简单实现下链式操作。 1$(\"#Test\").css('color','red').show(200).removeClass('style'); //jquery中的链式操作 起步 先贴一波代码 123456789101112131415161718192021222324&lt;?php class A &#123; private $name; private $age; # 要改变的属性聚合在类中成为类属性 public function cname($name) &#123; $this-&gt;name=$name; return $this; # 链式操作的关键 方法中返回对象自身 &#125; public function cage($age) &#123; $this-&gt;age=$age; return $this; &#125; public function __toString() &#123; return 'name:'.$this-&gt;name.' age:'.$this-&gt;age; &#125; &#125; 实际调用 123$instance = new A();$instance-&gt;cage(111)-&gt;cname(\"Dawnki\");echo $instance; // name:Dawnki age:111 简单吧？如果是改变的属性为对象，即可进行更多的操作，这个代码风格使用起来也是十分顺手易读性强。 Laravel 使用的链式操作 Laravel在对数据库增删查询也是采用链式操作： 1Model::where('xxx','xxx')-&gt;where('xxxxxx','xxxx')-&gt;get(); 这里就会有个小问题，上面的链式操作明明都是return $this , 这里Model上来就搞了个where的静态方法，不会炸开锅吗？ 实际上，阅读下Laravel的源码，里面采用了许多魔术方法，下面就看看源码的实现(好像有点偏题，哈哈) 在/vendor/laravel/illuminate/Database/Eloquent/Model.php中找到他们的两个魔术方法 12345678910111213141516171819202122232425262728293031/** * Handle dynamic method calls into the model. * * @param string $method * @param array $parameters * @return mixed */public function __call($method, $parameters)&#123; if (in_array($method, ['increment', 'decrement'])) &#123; return call_user_func_array([$this, $method], $parameters); &#125; $query = $this-&gt;newQuery(); return call_user_func_array([$query, $method], $parameters);&#125;/** * Handle dynamic static method calls into the method. * * @param string $method * @param array $parameters * @return mixed */public static function __callStatic($method, $parameters)&#123; $instance = new static; return call_user_func_array([$instance, $method], $parameters);&#125; 可见,当 Model:where(xxxx) 时，会先生成一个Model的实例(执行__callStatic)，然后再用回调函数,让这个刚生成的实例去执行where，由于模型里面本来是没有涉及sql查询的方法，正在执行sql语句的是同目录下面的Builder.php,即SQL构造器，这个builder里面才负责处理SQL.因此Model的实例因为没有where方法而执行魔术方法__call来生成一个构造器(builder)去执行where方法。所以 真正执行where方法的是Builder.php 下面是/vendor/laravel/illuminate/Database/Eloquent/Builder中的where方法 123456789101112131415161718192021222324/** * Add a basic where clause to the query. * * @param string $column * @param string $operator * @param mixed $value * @param string $boolean * @return $this */public function where($column, $operator = null, $value = null, $boolean = 'and')&#123; if ($column instanceof Closure) &#123; $query = $this-&gt;model-&gt;newQueryWithoutScopes(); call_user_func($column, $query); $this-&gt;query-&gt;addNestedWhereQuery($query-&gt;getQuery(), $boolean); &#125; else &#123; call_user_func_array([$this-&gt;query, 'where'], func_get_args()); &#125; return $this; # 链式操作关键&#125; 用链式操作改造CURL 附带一个利用链式操作的封装curl类 总结 所以不妨改良一下自己的代码吧！~","tags":[{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"链式操作","slug":"链式操作","permalink":"https://dawnki.github.io/tags/链式操作/"}]},{"title":"PHP的打包工具--Phar实践","date":"2017-07-04T10:40:40.000Z","path":"2017/07/04/Phar/","text":"Phar,是一种将PHP程序打包的工具，至PHP5.3以来开始支持，这个就类似于Java中的jar包，使用的时候也十分简便，只要include或者require即可，网上的许多PHP的SDK也支持这种打包方式。下面就简单说下怎么使用phar打包以及引入phar包。 实验环境 PHP5.6 打包PHP程序修改PHP配置 要想利用Phar将PHP应用程序打包，先修改php.ini的相关配置 打开php.ini，找到phar.readonly 1phar.readonly = Off # 去掉;的注释，并且将On改为Off 此时就可以愉快的使用phar打包 开始打包 假定项目的目录结构如下图: Demo的github地址 build.php 为我们的打包程序. 内容如下: 12345678910111213&lt;?php // 参数内容为生成文件路径 此例中则在当前目录生成example.phar打包程序 $phar = new Phar('example.phar'); // 开始打包 $phar-&gt;startBuffering(); // 要打包的目的目录 绝对路径 $phar-&gt;buildFromDirectory(__DIR__); // 压缩方式 GZ-&gt;gzip BZ2-&gt;bz2 $phar-&gt;compressFiles(Phar::GZ); // 设置启动加载脚本 即导入phar之后第一个自动执行的脚本 $phar-&gt;setStub($phar-&gt;createDefaultStub('index.php')); // 结束打包 $phar-&gt;stopBuffering(); 其中buildFromDirectory方法还接收第二个参数可以用正则表达式来筛选不需打包的文件 123&lt;?php // 只打包结尾为.php的文件 $phar-&gt;buildFromDirectory(__DIR__,'/\\.php$/'); 使用phar打包程序 如果是直接使用整个项目的话可以直接，用include 或者 require 123&lt;?php // 直接导入phar包 并且会自动执行启动脚本 require_once __DIR__.'/example.phar'; 如果只是导入phar中的一个脚本，可以这样 123&lt;?php // 只导入 your_script.php 这个脚本 include 'phar://example.phar/your_project_path/your_script.php'; 注意事(坑)项(点) 假如你打包的项目中，入口文件index.php 要引入(include or require)项目中的其他脚本，务必使用绝对路径，否则你打包成phar包之后，其他项目要引入这个phar就会路径出错!!,即如下: 123&lt;?php //这是index.php 入口文件 require __DIR__.\"/src/controller.php\"; //要使用绝对路径 require \"./lib/tools.php\"; //不要使用相对路径 感谢 &amp; 参考资料 韩天峰大大的博客 官方文档","tags":[{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"Phar","slug":"Phar","permalink":"https://dawnki.github.io/tags/Phar/"}]},{"title":"(转) 2017年PHP程序员未来路在何方","date":"2017-07-01T09:19:41.000Z","path":"2017/07/01/2017PHP程序出路/","text":"作者: 韩天峰转载连接: 2017年PHP程序员未来路在何方 PHP 从诞生到现在已经有20多年历史，从Web时代兴起到移动互联网退潮，互联网领域各种编程语言和技术层出不穷， Node.js 、 GO 、 Python 不断地在挑战 PHP 的地位。这些技术的推动者非常热衷于唱衰 PHP ， PHP 语言的未来在哪里？PHP 程序员当如何应对未来的变革？ 作为老牌的Web后端编程语言，PHP 在全球市场占有率非常高，仅次于 Java ，从各个招聘网站的数据上来看PHP 开发的职位非常多，薪资水平也非常不错。实际在中小企业、互联网创业公司PHP的市场地位是高于 Java 的。Java 在超大型企业、传统软件行业、金融领域优势更大。目前来看 Node.js、 GO 、 Python 、 Ruby 等语言还难以企及PHP和Java。 PHP 语言之所以能有今天的地位，得益于PHP语言设计者一直遵从实用主义，将技术的复杂性隐藏在底层。PHP 语言入门简单，容易掌握，程序健壮性好，不容易出现像 Java 、 C++ 等其他语言那样复杂的问题，如内存泄漏和 Crash ，跟踪调试相对轻松很多。PHP 官方提供的标准库非常强大，各种功能函数都能在官方的标准库中找到，包括MySQL、Memcache、Redis、GD图形库、CURL、XML、JSON等等，免除了开发者到处找库的烦恼。PHP 的文档非常棒，每个函数都有详细的说明和使用示例。第三方类库和工具、代码、项目也很丰富。开发者可以快速、高效地使用 PHP 编写开发各类软件。到目前为止市面上仍然没有出现比 PHP 更简单易用的编程语言。所以 PHP 的前景还是很广阔的，与其纠结于编程语言的选择，不如好好地深入学习使用 PHP 。 作为一个资深的 PHP 开发者，在技术上给各位 PHP 程序十点未来的建议，希望对大家有所帮助。 Composer第一点就要提 Composer ，自从 Composer 出现后，PHP 的依赖管理可以变得非常简单。程序内依赖一些类库和框架，直接使用 Composer 引入即可，通过使用 composer update 安装依赖的包。解决了过去加载外部库的各种难题。Composer 也有国内镜像，速度非常快。现在绝大部分PHP开源的项目都提供了 Composer 的支持，建议大家在项目中使用 Composer 来解决 PHP 代码包管理的问题，不要再使用下载源码、手工 include 的原始方法。 PHP7PHP7 版本对 Zend 引擎做了大量修改，大幅提升了 PHP 语言的性能，使用 PHP7 可以使你的程序性能瞬间翻倍。即使是 WordPress 这样重量级的软件运行在 PHP7 都能有上千 QPS ，相当于一台服务器每天就能处理 8000 万次请求。使用 PHP7 ，做好 MySQL 优化，使用 Memcache 和 Redis 进行加速，这套技术架构完全可以应对相当大规模的系统。除了某些亿级用户的平台之外，一般规模的系统完全没有压力。 PSRPSR 是 http://www.php-fig.org/ 组织制定的PHP语言开发规范，约定了很多方面的规则，如命名空间、类名规范、编码风格标准、Autoload、公共接口等。现在已经成为PHP技术社区事实上的标准了。很多知名的 PHP 框架和类库都遵守了 PSR 规范。PHP 开发者应当学习掌握 PSR 规范，在开发程序时应当尽量遵循 PSR 规范。 Swoole2017 年 PHP 还局限于做 Web 网站吗？No ，如果你还不知道 Swoole ，赶快去了解一下吧。Swoole 的口号是重新定义 PHP 语言，Swoole 是一个异步并行的通信引擎，作为 PHP 的扩展来运行。Node.js 的异步回调 Swoole 有，Go语言的协程 Swoole 也有，这完全颠覆了对 PHP 的认知。使用 Swoole PHP 可以实现常驻内存的 Server 程序，可以实现 TCP 、 UDP 异步网络通信的编程开发。过去PHP只能做一个 Web 网站，现在使用 Swoole 可以做 Java 、C++ 才能实现的通信服务，比如 WebSocket 即使通信、聊天、推送服务器、RPC 远程调用服务、网关、代理、游戏服务器等。如果你想用 PHP 做点 Web 系统之外的东西，Swoole 是最好的选择。 Laravel最近几年最火热的 PHP 框架，官网号称是为 Web 艺术家设计的框架，可见这套框架有多优雅。Laravel 提供的功能模块丰富，API 设计简洁，表达力强。而且它的社区非常活跃，代码贡献者众多，第三方的插件非常多，生态系统相当繁荣。 Laravel 底层使用了很多 symfony2 组件，通过 composer 实现了依赖管理。如果还在纠结使用什么PHP框架，不如选择 Laravel 。 Laravel 提供的命令行工具基于 symfony.console 实现，功能强大，集成了各种项目管理、自动生成代码的功能。 PharPHP5.3 之后支持了类似 Java 的 jar 包，名为 phar。用来将多个 PHP 文件打包为一个文件。这个特性使得 PHP 也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到PHP-FPM 中运行。配合 Swoole ，可以在命令行下执行 php server.phar 一键启动服务器。PHP 的代码包可以用 Phar 打包成组件，放到 Swoole 的服务器容器中去加载执行。 C/C++/GO任何技术有优点就有缺点，PHP 作为一门动态脚本语言，优点是开发方便效率高。缺点就是性能差。在密集运算的场景下比 C 、 C++ 相差几十倍甚至上百倍。另外 PHP 不可以直接操作底层，需要依赖扩展库来提供 API 实现。PHP 程序员可以学习一门静态编译语言作为补充实现动静互补，C/C++/Go 都是不错的选择。而且静态语言的编程体验与动态语言完全不同，学习过程可以让你得到更大的提升。 掌握 C/C++ 语言后，还可以阅读 PHP 、 Swoole 、 Nginx 、Redis 、 Linux内核 等开源软件的源码，了解其底层运行原理。 现在最新版本的Swoole提供了C++扩展模块的支持，封装了Zend API，用C++操作PHP变得很简单，可以用C++实现PHP扩展函数和类。 HTML5作为 Web 前端新一代标准，HTML5 未来前景非常广阔，市场需求量非常大。从 PC 网站、B/S 企业软件、移动端网页、APP，这些领域都在拥抱 HTML5，掌握了 HTML5 才能在下一波互联网技术大潮中存活下来。 Vue.jsPHP 程序员除了写后台程序之外，还有很大一部分工作在展现层，和浏览器前端打交道。2017 年你还在用 jQuery 操作 DOM 实现界面渲染吗？已经完全 out 了。现在用 Vue.js 可以非常方便地实现数据和 DOM 元素的绑定。通过 Ajax 请求后台接口返回数据后，更新前端数据自动实现界面渲染。2017 年再不学 Vue 就晚了。 如果你不光要写 Web 程序，同时还希望兼顾 Android 、IOS 、PC 客户端等平台，React Native 是一个不错的选择。 深度学习/人工智能互联网的未来属于人工智能，如果你还不了解机器学习、深度学习、人工智能这些概念，那你需要尽快学习了解一下。现在互联网巨头们都在布局人工智能，包括 Google 、 Facebook 、微软、亚马逊 和国内的百度。虽然现在还处于科学研究的阶段，但未来互联网的各个领域都会应用到人工智能，包括自动驾驶、大数据分析、网络游戏、图像识别、语言处理等。当然现在普通的工程师可能还无法参与到人工智能产品中，但至少应该理解深度学习/人工智能的基本概念和原理。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"技术栈","slug":"技术栈","permalink":"https://dawnki.github.io/tags/技术栈/"}]},{"title":"mysql开启Innodb引擎","date":"2017-06-30T19:41:26.000Z","path":"2017/07/01/Mysql开启Innodb引擎/","text":"Innodb引擎是我们经常用到的mysql存储引擎，在我们需要事务管理以及外键等功能的时候，单单的Myisam引擎并不满足我们的需求，此时就需要我们启用innodb引擎。不过在我们安装数据库或者用lnmp一键安装配置，没有选开启innodb引擎，那该怎么办呢？ 起步 关闭mysql服务 1$ service mysql stop 1$ sudo lnmp stop # lnmp一键安装的用户 修改mysql配置文件(my.ini / my.cnf) linux用户需要修改的是my.cnf文件. 1$ vi /etc/my.cnf 在里面一行加入 innodb = ON ，然后保存退出 重启mysql或lnmp即可开启innodb引擎 小结 以上方法仅适用于已经安装了innodb引擎，但是没有开启的情况 可以在mysql的shell里面输入 show engines; 来查看是否安装了innodb引擎 网上查到的结果说my.cnf中如果有 skip-innodb 就用#号注释掉，然后并没找到，只找到loose-skip-innodb，然而当我一注释时，启动mysql就出错，因此不能随便注释..","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"开启Innodb","slug":"开启Innodb","permalink":"https://dawnki.github.io/tags/开启Innodb/"}]},{"title":"软件杯设计大赛展示视频","date":"2017-06-29T04:24:10.000Z","path":"2017/06/29/软件杯设计大赛展示视频/","text":"第六届 中国软件杯 大学生软件设计大赛概述 所选课题: 图片认知分类系统设计与开发 PowerBy: SCAU_Cifar团队 团队成员: Ariel Dawnki Seahub 课题地址: http://www.cnsoftbei.com/bencandy.php?fid=148&amp;aid=1537 成果视频展示ImgTagger&amp;ImgMaster: 优酷 腾讯视频","tags":[{"name":"图片认知","slug":"图片认知","permalink":"https://dawnki.github.io/tags/图片认知/"},{"name":"机器学习","slug":"机器学习","permalink":"https://dawnki.github.io/tags/机器学习/"},{"name":"中国软件杯","slug":"中国软件杯","permalink":"https://dawnki.github.io/tags/中国软件杯/"}]},{"title":"PHP系统调用(调用Bash&Python脚本)","date":"2017-06-27T04:05:23.000Z","path":"2017/06/27/PHP系统调用/","text":"有时候，我们在使用php进行开发时，需要调用服务器上的脚本或者调用python脚本来实现某些功能，这时候就需要使用PHP的系统调用函数。不过实际调用中会出现许许多多的问题，就拿最近有关机器学习的项目，后台是PHP实现的，不过机器学习部分用的是Python(需要用到caffe)，中间调用python就遇到了许许多多的坑。 实验环境 系统: Ubuntu 14.04 PHP: 5.6.22 Python: 2.7.6 起步 在挖矿之前先介绍一下php的系统调用函数吧: system() 描述：执行外部程序，成功则返回命令输出的最后一行， 失败则返回 FALSE，特点直接输出 12$command='pwd';system($command); 1/home/wwwroot/cifar/public exec() 描述：执行一个外部程序,返回命令执行结果的最后一行内容。不直接输出到屏幕.如果输出只有一行则按空格为分隔符获取内容,如果多行则按行来为分隔符来获取内容存入到数组中. 123$command='pwd';exec($command,$result); //命令输出内容存至result变量print_r($result); 1234Array( [0] =&gt; /home/wwwroot/cifar/public) shell_exec() 描述： 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。返回命令执行的输出。 如果执行过程中发生错误或者进程不产生输出，则返回 NULL。使用本函数无法通过返回值检测进程是否成功执行。 如果需要检查进程执行的退出码，请使用 exec() 函数。 123$command='who';$data=shell_exec($command);print_r($data); 12root tty1 Jun 25 14:46root pts/0 Jun 27 12:44 passthru() 描述：执行外部程序并且显示原始输出 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。特点直接输出,原始输出 12$command='who';passthru($command); 12root tty1 Jun 25 14:46root pts/0 Jun 27 12:44 综上 要获取原始输出就用passthru 听说exec跟表单(grep查询的结果)更配哦 其他函数看着需求用就好 挖坑 起步完之后就会开始进入实践，就会遇到各种坑，准备好了吗？ 第一坑： disable_functions 解除PHP禁用函数 虽说这个默认设置不是坑，但是99%的服务器在你部署完php之后，disable_funcitons设置上都会禁用掉上面所用到函数，所以先去php.ini里面解除系统调用函数设置 vi /usr/local/php/etc/php.ini (我lnmp安装默认是这个路径的，php安装在其他地方的请自行调整) 打开配置文件后找到disable_functions(可以用vi在命令模式下/disable_functions来查找) 将你之后用到的系统调用函数删去(exec,system,passthru等等),如果不在此列则表示没有默认禁用该PHP函数 保存(Esc退出到命令模式然后:wq!退出)，如果权限不够不能写则自行加权限解决 重启PHP/LNMP (lnmp restart) 然后就可以愉快地使用系统调用函数了 第二坑： 补充错误日志 在你调试命令的时候，最烦的不是出错，最烦的是出错了但没有错误提示，因此不能对症下药，所以，不妨在你调试命令时，顺便输出到文本文件，然后去文本文件里面找错误输出。 123$command='ll / 2&gt;/xxxxxx/log.txt'; //将错误重定向到log.txtexec($command,$result); //命令输出内容存至result变量print_r($result); 建议命令里面涉及路径的全部都用上绝对路径，并且给日志文件给上权限(777简单粗暴) bash命令中的0代表标准输入，1代表标准输出，2代表标准错误输出 第三坑： 权限 在你补充完错误日志时，你会发现最多的错误就是有关于权限的，以及有关于sudoer的，因为当你浏览器发送一个请求给服务器的web应用时，web服务器(apache或者nginx)所用的用户(www)不具备root的一些权限，所以需要修改sudoer以及涉及到的文件权限(读写操作) visudo 直接编辑 (进入利用nano编辑器编辑sudoer) 如果发现文本中存在 defaults requiretty 的，则用#号注释掉如 #defaults requiretty apache用户的话一般系统会建立apache用户，nginx用户的话一般是www用户(可用vi /usr/local/nginx/conf/nginx.conf查看，第一行就是显示nginx所用的用户) 在visudo末尾中 添加 www ALL=NOPASSWD:ALL 或者 apache ALL=NOPASSWD:ALL(不同web服务器所用的用户不同) 然后ctrl+x 按Y保存退出nano 然后给你需要读写的文件加上对应权限，就可以用PHP系统调用进行文件读写等等需要权限的操作 第四坑： 调用Python脚本时import问题 就举我上面提到的例子，PHP调用机器学习的Python脚本，这个Python脚本中用到了刚编译好的caffe（非Python标准库），然后import caffe的时候，或许在shell运行没问题，但是在PHP调用Python的时候可能就会炸了。 例如会报 ImportError: No module named caffe 的错误 12345#修改前的 PHP调用时会报caffe模块缺失的错误import numpy as npimport sysimport osimport caffe 123456import numpy as npimport sysimport ossys.path.append(\"/（caffe-master路径）/caffe/python\") #根据自己实际的绝对路径修改sys.path.append(\"/（caffe-master路径）/caffe/python/caffe\")#根据自己实际的绝对路径修改import caffe 对于其他需要自行编译的模块，同理举一反三吧~ 第五坑： PHP默认开始安全模式 如果PHP默认开启了安全模式，只要去php.ini里面把safe_mode(如果存在)用#号注释掉即关闭 小结 对于其他错误的话，根据错误日志慢慢解决就好，还有更多的坑需要填呢~最后说一句，既然PHP调用Python这么麻烦，为什么不直接用Python开发呢？因为PHP是世界上最好的语言啊(误) ^_^ PHP系统调用官方文档","tags":[{"name":"PHP函数","slug":"PHP函数","permalink":"https://dawnki.github.io/tags/PHP函数/"},{"name":"系统调用","slug":"系统调用","permalink":"https://dawnki.github.io/tags/系统调用/"},{"name":"PHP调用Python脚本","slug":"PHP调用Python脚本","permalink":"https://dawnki.github.io/tags/PHP调用Python脚本/"}]},{"title":"PHP常用的几种魔术方法","date":"2017-06-03T08:05:11.000Z","path":"2017/06/03/php的魔术方法/","text":"补个档，重新复习下php的几种魔术方法,同时魔术方法也是必须掌握的，面试什么的也是必考的.附上php文档的相关警告:PHP 将所有以两个下划线开头的类方法保留为魔术方法。所以在定义类方法时，除了讲到的魔术方法，建议不要以两个下划线为前缀. 切记切记~~ 常用魔术方法__construct() 描述:类构造方法，在实例化类时自动调用 12345678class A &#123; function __construct() //参数列表可选 &#123; //..... &#125;&#125;$instance = new A(); //实例化时自动调用 __destruct() 描述:析构函数，在对象的所有引用被删除或者脚本执行结束时调用 12345678910class A &#123; function __destruct() //参数列表为空 &#123; //... &#125;&#125;$instance = new A();unset($instance); //此处调用析构函数 如果此行注释掉，脚本结束亦会调用 __toString() 描述:当类被当作字符串时，此方法返回字符串。返回值为string，无参数。 123456789101112class A&#123; function __toString() &#123; return \"I AM A\"; &#125;&#125;$instance = new A();echo $instance;print $instance; __get() 描述:当读取不可访问属性的调用，参数string值，返回值mixed 12345678910111213class A&#123; private $a = 1; function __get($name) //$name为要访问的属性名 &#123; if(isset($this-&gt;$name))&#123; return $this-&gt;$name; &#125; &#125;&#125;$instance = new A();echo $instance-&gt;a; //1 __set() 描述:当给不可访问的属性赋值时调用，参数1(属性名) string 参数2(赋值) mixed ，返回值为void 1234567891011121314151617181920class A&#123; private $a = 1; function __set($name,$value) &#123; if(isset($this-&gt;$name))&#123; $this-&gt;$name=$value; &#125; &#125; function __get($name)&#123; if(isset($this-&gt;$name))&#123; return $this-&gt;$name; &#125; &#125;&#125;$instance = new A();$instance-&gt;a = 3; //自动调用__set()echo $instance-&gt;a; //自动调用__get() __isset() 描述:对当不可访问的属性调用isset()或empty()时,__isset()会被自动调用，接受一个string 参数(被访问的属性名) 1234567891011class A&#123; private $a; function __isset($name) //被访问的属性名 &#123; echo $name.\"__isset is invoked\"; &#125;&#125;$instance = new A();isset($instance-&gt;a); // a__isset is invoked __unset() 描述:对当不可访问的属性调用unset()时,__unset()会被自动调用，接受一个string 参数(被访问的属性名) 1234567891011class A&#123; private $a; function __unset($name) //被访问的属性名 &#123; echo $name.\"__unset is invoked\"; &#125;&#125;$instance = new A();unset($instance-&gt;a); //a__unset is invoked __call() 描述:当对象调用一个不可访问的方法是，__call()会被自动调用，接受两个参数，第一个参数string(方法名)，第二个参数array(参数列表) 1234567891011121314151617class A&#123; private function inside($a,$b) &#123; echo $a.'_'.$b; &#125; function __call($name,$args) //方法名&amp;参数列表 &#123; echo 'funciton_name:'.$name.' parameter:'.implode(' , ',$args); &#125;&#125;$instance = new A();$instance-&gt;inside(1,2,3); //funciton_name:inside parameter:1 , 2 , 3 __callStatic() 描述:当对象调用一个不可访问的静态方法是，__callStatic()会被自动调用，接受两个参数，第一个参数string(方法名)，第二个参数array(参数列表)，修饰必须是可见的以及静态的 12345678910111213class A&#123; private static function inside($a,$b) &#123; echo $a.'_'.$b; &#125; public static function __callStatic($name,$args) //修饰必须是可见的以及静态的 &#123; echo 'static_funciton_name:'.$name.' parameter:'.implode(' , ',$args); &#125;&#125;A::inside(1,2,3); //static_funciton_name:inside parameter:1 , 2 , 3 __clone() 描述:当使用关键字clone对象是，__clone()方法会被自动调用. 作用:因为clone是浅克隆，当要复制的对象内部有一个引用属性时，并不会进行复制，而是照搬引用，所以此时需要在__clone方法中对某些引用属性进行深克隆 1234567891011121314151617181920212223242526class A&#123; public $obj ; //引用对象 public function __construct(B $ojb) &#123; $this-&gt;obj = $ojb; &#125; function __clone()&#123; $this-&gt;obj = clone $this-&gt;obj; //对应引用对象进行深克隆 &#125;&#125;class B&#123; public $content=\"abc\";&#125;$a = new A(new B());$b = clone $a;$a-&gt;obj-&gt;content = \"efg\"; //即使$a内部的引用对象改变了echo $b-&gt;obj-&gt;content; //$b内部的引用对象仍不变 为abc __sleep() 描述:serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 备注:__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 12345678910111213141516class A&#123; public $var1 = 1; public $var2 = 2; public $var3 = 3; public function __sleep() //返回应被序列化的变量名称的数组 &#123; return array('var1','var2'); //序列化时忽略序列化$var3 &#125;&#125;$instance = new A();echo serialize($instance); //O:1:\"A\":2:&#123;s:4:\"var1\";i:1;s:4:\"var2\";i:2;&#125; Notice:serialize()和unserialize()，是将php的值与字符串相互转化的方法(序列化与反序列化)，主要便于存储，同时也不丢失类型结构。 __wakeup() 描述:unserialize(反序列化)对象时，__wakeup()会被自动调用。 作用:经常用在反序列化操作(字符串还原成对象时)中，例如重新建立数据库连接，或执行其它初始化操作。 123456789101112131415161718192021222324252627class A&#123; public $var1 = 1; public $var2 = 2; public $var3 = 3; public function __sleep() &#123; return array('var1','var2'); &#125; function __wakeup() &#123; $this-&gt;var1 = 233; &#125;&#125;$instance = new A();$a=serialize($instance);echo $a; // O:1:\"A\":2:&#123;s:4:\"var1\";i:1;s:4:\"var2\";i:2;&#125; 可见var1的值为1$a=unserialize($a);echo $a-&gt;var1; //输出233 而不是 1 魔术方法实现重载属性重载 PHP所提供的”属性重载”是指动态地”创建”类属性 12345678910111213141516171819202122232425262728class A&#123; // 可重载的属性存放在data数组中 private $data = array(); // 此属性不能被重载 public $declared = 1; // 从类外部访问此属性时才发生重载 private $hidden = 2; // 利用__set动态创建 public function __set($name , $value) &#123; $this-&gt;data[$name] = $value; &#125; // 返回重载属性数组data public function getData() &#123; return $this-&gt;data; &#125;&#125;$instance = new A();$instance-&gt;a = 3; //a属性被动态添加print_r($instance-&gt;getData()); //Array ( [a] =&gt; 3 ) 方法重载 传统的”重载”是用于提供多个同名的类方法，但各方法的参数类型和个数不同。不过要实现相同的功能可以使用__call()魔术方法. 1234567891011121314151617181920212223242526272829class A&#123; function __call($name,$args) &#123; if($name == 'func') &#123; $args_num = count($args); $invoke_name=$name.$args_num; if(method_exists($this,$invoke_name))&#123; call_user_func_array(array($this,$invoke_name),$args); //参数1:回调方法 参数2:数组形式的参数列表 &#125; &#125; &#125; function func1($arg1) &#123; echo \"invoke func1:\".$arg1; &#125; function func2($arg1,$arg2) &#123; echo \"invoke func2:\".$arg1.','.$arg2; &#125;&#125;$instance = new A();$instance-&gt;func(1); //执行func1$instance-&gt;func(1,2); //执行func2 notice:call_user_func_array方法的第一个参数是callable类型，一个已实例化的 object 的方法被作为 array 传递，下标 0 包含该 object，下标 1 包含方法名。 在同一个类里可以访问 protected 和 private 方法。 参考资料PHP官方文档","tags":[{"name":"PHP魔术方法","slug":"PHP魔术方法","permalink":"https://dawnki.github.io/tags/PHP魔术方法/"},{"name":"重载","slug":"重载","permalink":"https://dawnki.github.io/tags/重载/"}]},{"title":"Ubuntu完全卸载mysql","date":"2017-05-10T04:45:44.000Z","path":"2017/05/10/删除mysql/","text":"我们安装了mysql之后想卸载mysql时，往往是卸载不完全，导致下次安装又有问题，下面就提供ubuntu完全卸载mysql的方法. 实验环境 Linux: Ubuntu 16:04 Mysql 5.7 步骤 温馨提示:执行之前务必确认是否备份了数据库的数据,数据无价! 先在shell里执行以下指令 12345sudo apt-get autoremove --purge mysql-server*sudo apt-get remove mysql-server*sudo apt-get autoremove mysql-server*sudo apt-get remove mysql-commonsudo rm -rf /etc/my.cnf 建一个shell脚本(文件)叫deleteMysql.sh,内容如下: 1234567#!/bin/bashlist=`sudo find / -name mysql*`for i in $list do sudo rm -rf $idoneexit 0 给这个脚本加上执行权限后执行 12sudo chmod u+x deleteMysql.shsudo ./deleteMysql.sh 小结这下子mysql应该算是完全卸载了，然后就可以跑路(误)了!!!∑(ﾟДﾟノ)ノ","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"ubunut","slug":"ubunut","permalink":"https://dawnki.github.io/tags/ubunut/"}]},{"title":"Laravel5.2消息队列实践","date":"2017-05-10T03:21:41.000Z","path":"2017/05/10/laravel-job/","text":"在后台开发中，很多情况需要用到队列来处理业务逻辑，前几天亲自实践了一下Laravel的队列功能，在此分享一蛤。 使用情景举几个使用到消息队列的栗子 在处理商城的库存问题，简单的实现是当用户的某件商品下单了，库存就相对应减少，但是当并发量一大时，比如A,B两个顾客同时下单，如果不使用队列可能会造成库存错误，使用队列了保证不同时执行两个减库存操作(一个阻塞掉了另外一个)。 当一个服务器要处理一个请求端发来的多组大量数据，而且每组数据处理起来的时间会很慢时，可以采取异步队列，就相当于请求端发过来的数据先存着，放进队列里，然后再异步处理数据(即处理数据的过程不在请求的生命周期里) 由于比如用户登陆了某网站之后，后台就过xx分钟给用户发延迟邮件来推送广告(怎么有点流氓(°Д°))，这里也可以用到异步队列，虽然可以用设计定时任务来轮询检查的笨方法，不过感觉用轮询来实现异步不是真正的异步 扯了这么多，刚回到正题了—实践 实验环境 Laravel 5.2 系统: Windows(wamp) or Linux(lnmp) 步骤 配置laravel提供了多种消息队列驱动: sync(同步) database beanstalkd sqs redis默认是sync，不过实际上其他几种异步队列多点，本章先用database练练手，前几天刚服务器刚配好redis，迟点再补上redis的吧~ so,先到 /.env (默认根目录为你的项目目录) 中 填上 QUEUE_DRIVER=database ,当然你也可以到/config/queue.php的default中将sync修改，但是建议修改.env 建表修改完队列驱动后，就用Laravel的migration自动生成队列需要的表，到根目录执行artisan 123php artisan queue:tablephp artisan queue:failed-table #处理出错队列用的表php artisan migrate 此时，数据库中就会出现jobs表和failed_jobs表 创建任务类并编写任务类执行artisan命令快速生成任务类并在/app/jobs/ 目录下面找到刚创建的任务 1php artisan make:job yourJobName 刚自动生成的任务类包含了两个初始方法 12345678910111213141516171819/** * Create a new job instance. * * @return void */public function __construct()&#123; //&#125;/** * Execute the job. * * @return void */public function handle()&#123; //&#125; 构造方法__construct用于你给任务类传值or对象用，至于handle方法则是队列任务的处理(即给排在队列里的任务如何执行业务逻辑) 这时就有个问题了，排在队列里的任务如果处理时失败了，或者因不符合某些业务逻辑需要进行统一的失败操作，那该怎么办呢？ 此时可以在这个任务类中添加一个failed方法 1234public function failed()&#123; //&#125; 这样laravel就可以识别得到，当一个任务在执行handle方法时，遇到异常了(Throw Exception)，laravel就会自动捕获异常并执行failed方法，并在failed_job表中记录信息。这个用来管控你看不见摸不着的异步队列任务比较有用，你可以根据业务逻辑在failed方法里将错误信息输出到自己的日志或者其他操作。 任务类里自带的几个有用方法通过artisan生成的任务类里，由于使用(use)了InteractsWithQueue这个trait，所以可以使用到里面有几个自带的方法 attempts 作用:返回任务的已经执行次数(eg.可以用于在handle方法中判断任务执行超过n次时就抛出异常来执行failed方法等等) 食用方法:在任务类的handle方法或者failed方法中,无参 1$this-&gt;attempts(); delete 作用:在队列中删除该任务(jobs表里删除) 食用方法:同上 1$this-&gt;delete(); release 作用:将当前任务再次放进队列中，可传入参数，来控制同一个任务两次运行之间的等待时间 食用方法:同上，不过有参，参数为int类型 表示多少秒 1$this-&gt;release(10); // 同一个任务两次运行之间隔10秒执行 目前任务类里比较常用的就是这几个方法了。 执行任务代码里要做的事编写好任务类之后，你可以在你的控制器里面创建任务，并且将它调度执行(dispatch) 12$job=new yourJobName($value); // 按实际情况来传值dispatch($job); 如果想设置延时 12$job=new yourJobName()-&gt;delay(10); // 延迟10秒执行dispatch($job); 如果想指定队列(分类) 12$job=new yourJobName()-&gt;onQueue('test'); //可以查看对应job表的queue字段dispatch($job); shell里要做的事当代码里做的事做好了之后，我们一个请求过去服务器的项目程序就能启动任务了吗？不能，因为之前我们说过，除了sync其他驱动都是异步的，而php是单线程的(意味着一个开启一个php脚本相当于开启一个进程，而这个进程里面只有一个线程)，所以我们一个请求只有一个线程，因此我们需要开多一个进程来进行队列监听了，当监听脚本监听到队列有动静时，就对队列进行处理。 1php artisan queue:listen 测试 开始监听 发送请求(可以用postman试试)到指定控制器来调度队列任务 观察正在执行监听任务的shell(ctrl+c 退出监听) 小结 通过实践，算是掌握了laravel的队列使用，下面就提一下我遇到的坑点以及改进吧~ 注意事(坑)项(点) 当你使用了onQueue方法来给任务分类然后调度时，监听的命令该怎么写？ 一开始我天真的认为一句 php artisan queue:listen 就能监听所有分类的任务，结果之后发现我定义的一个分类的任务一直不执行，看了文档又找不到缘故 12$job=new yourJobName()-&gt;onQueue('test'); //将一个任务归为test分类dispatch($job); 1php artisan queue:listen # 你会发现,是监听不了上面的的任务的 翻了一下帮助命令 1php artisan help queue:listen 可以看到 所以正确的执行姿势应该是 12php artisan queue:listen --queue test # 以我上面的例子而言 此处队列分类是testphp artisan queue:listen --QUEUE test # help里面说到大写也可以 还有其他queue的命令就自己发掘或者看文档吧~ 优化 为了保护监听进程(失败后重启等)，我们可以尝试用一下Supervisor(linux) 因为现在很多缓存都用redis，所以这个队列任务如果用redis的话，就可以一举两得了~~ 以上两点列入到Todo list中，有空再捣鼓一蛤!! 感谢感谢 Laravel学院 的中文文档 ！","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"异步消息队列","slug":"异步消息队列","permalink":"https://dawnki.github.io/tags/异步消息队列/"}]},{"title":"Sublime Text 安装Package Controller","date":"2017-05-10T00:38:46.000Z","path":"2017/05/10/sublimetextPC/","text":"前言众所周知，sublime是一款很好用的文本编辑器，其好用之处在于其背后强大的插件功能，但是刚安装的sublime是不能直接安装插件的，需要先安装Package Controller 才能通过Package Controller来安装插件，下面就介绍如何安装Package Controller. 安装方法安装方法分为简单安装和手动安装,自行选择即可. 简单的安装方法使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码： Sublime Text 3 1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 如果顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了。 Sublime Text 2 的如下: 1import urllib2,os; pf=&apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), &apos;wb&apos; ).write( urllib2.urlopen( &apos;http://sublime.wbond.net/&apos; +pf.replace( &apos; &apos;,&apos;%20&apos; )).read()); print( &apos;Please restart Sublime Text to finish installation&apos;) 手动安装可能由于各种原因，无法使用代码安装，那可以通过以下步骤手动安装Package Control： 点击Preferences &gt; Browse Packages菜单 进入打开的目录的上层目录，然后再进入Installed Packages/目录 下载Package Control.sublime-package并复制到Installed Packages/目录 重启Sublime Text。 如何使用Package Controller 安装插件 快捷键ctrl+shift+P，或者直接在Preferences &gt; Package Controller 来打开 在输入框中输入 install package 按回车 在新弹出的框中输入你要安装的插件即可 效果如下图:","tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://dawnki.github.io/tags/Sublime-Text/"}]},{"title":"LNMP坑点系列:\"mysql.serviceJob for mysql.service failed because the control process exited with error code.\"","date":"2017-05-09T13:02:09.000Z","path":"2017/05/09/mysql-question/","text":"一天舍友在lnmp下，动了一下/etc/my.cnf文件之后,重启lnmp是出现了”mysql.serviceJob for mysql.service failed because the control process exited with error code.”的问题。 寻找元凶经过几番询问后，发现原来舍友为了更改mysql密码动了一下/etc/my.cnf文件. 锁定/etc/my.cnf文件！！ 可以看到这个文件的初始权限是拥有者有读写功能，但同组或者其他人只有读的功能，由于舍友为了修改这个文件，帮这个文件加了所有身份都加了写的功能。 即：1sudo chmod go+w /etc/my.cnf 接着重启就炸了 1sudo lnmp restart 解决办法要解决很简单，只将这个文件的权限还原即可(只保留拥有者有写功能) 1sudo chmod go-w /etc/my.cnf 如图修改完之后，大功告成!lnmp能正常重启了! 小结这个坑告诉我们一定要有做事要有头有尾，文件由于一时特殊需要改了权限的，之后完事后记得改回权限!!","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"}]}]
[{"title":"JWT-Auth&Laravel-Auth源码浅读","date":"2017-07-28T17:04:12.000Z","path":"2017/07/29/JWT-Auth&Laravel-Auth源码浅读/","text":"故事发生月黑风高的…..啊呸，扯题了。简单来说前几天在配置JWT-Auth的时候，因为自己建的用户表没有用国际标准的’password’字段，而是自己随便起了个userPassword，导致不是在挖坑就是在挖坑的路上.不得不阅读其源码解决问题。 前置条件不过结构复杂的Laravel，里面运用了许多魔术方法及其核心的Ioc容器，阅读前拿到以下几种工具才好动手: 读一下Laravel作者的From Apprentice To Artisan(感谢中文翻译者) ，宛如laravel中的行动纲领 Laravel自带helper函数dd(),用于单步调试，运行完立即退出脚本，方便知道某个方法究竟有没有执行或者取值是什么 phpstorm ，虽然遇到Laravel一片黄，不过能查到追踪到多少代码算多少，O(∩_∩)O哈哈~ 遇到某个类中有依赖注入的，二话不说先找其服务提供者，看看服务提供者的注册方法中将注入的接口(Contract)绑定的是哪个类,为了方便解释，先来个例子~ 123456789class A &#123; protected $test; // 这个Test不是一个接口算我输 public function __construct(Test $test) &#123; $this-&gt;test=$test; &#125;&#125; 上文注入的Test，用phpstorm的ctrl+b追踪到的肯定是个接口.那么实际传给这个构造方法的实例是什么呢？在这个类附近找找provider字眼的类不会太远(看起来不太靠谱但是却有效,哈哈哈)，或者去/config/app.php里面找找 123456789101112//假装我找到了对应的providerclass TestServiceProvider extends ServiceProvider&#123; //关键是找register的内容 public function register() &#123; $this-&gt;app-&gt;bind('Test',function()&#123; // 假装有个叫做TestImplemet的类实现了上文的Test接口 return new TestImplement(); &#125;); &#125;&#125; 上文register方法里的bind,都是Laravel的Ioc容器(控制反转容器)的骚操作,简单地理解是Laravel帮你管理类实例,管理他们的生命周期,不用你到处new来new去,耦合代码,目的是彻底模块化,一个类只负责自己的东西,自己类里尽量不new别模块的类。 就是作者所说的严守类的边界(Respect Boundaries) 回归正题原来往A类里注入的是TestImplement类的实例,原来似李啊TestImplement,赶紧给我负责吖混蛋！(感觉污污的..Orz) 所以基本方针就这样，掌握了工具之后，就开始填坑吧！ 遇到问题 环境：Laravel5.2 依赖: JWT-Auth 1.0.0-beta.3 当我使用了JWT-Auth之后，由于模型里的密码字段是adminPass，在注册好服务提供者，做好各种配置之后，使用JWTAuth::attempt()方法验证账号密码时，我填入的数组是 1234[ &quot;phone&quot; =&gt; &apos;xxxxxx&apos;, // 此处充当账号 &quot;adminPass&quot; =&gt; &apos;xxxxxx&apos;] 然后attempt方法一直返回false，按照常理账号密码没有错的话，jwt会自动生成token返回，在确认其他配置没问题的情况下，只能硬着头皮去翻源码，逐步测试。 一步一步溯源根据attempt线索追踪根源 因为使用了先找出JWTAuth::attempt()所在的类.由于此处使用了JWTAuth的门面，我们先去JWTAuth里面看看它要拿的是哪个类 Laravel的门面其实就是为服务类提供”静态”接口，看似我们不需要实例化对象，然后再用A::method()这样的类似静态方法的方式调用服务类的方法。其实质是laravel从用户的门面调用方法中，拿到用户的要调用的方法以及参数，然后从Ioc容器里拿到对应的服务类实例，然后使用php灵活的回调函数，让这个实例执行用户填入的方法及其参数，具体的源码分析会在之后浅读一蛤然后再写篇博客(挖坑) 12345678910111213class JWTAuth extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; //经过Facade(门面)一系列操作，向Ioc容器中拿出注册名叫tymon.jwt.auth的实例 return 'tymon.jwt.auth'; &#125;&#125; 耐心地找到Tymon\\JWTAuth\\Providers\\AbstractServiceProvider，找到以下注册信息 123456789101112131415/** * Register the bindings for the main JWTAuth class. * * @return void */protected function registerJWTAuth()&#123; $this-&gt;app-&gt;singleton('tymon.jwt.auth', function ($app) &#123; return new JWTAuth( $app['tymon.jwt.manager'], $app['tymon.jwt.provider.auth'], $app['tymon.jwt.parser'] ); &#125;);&#125; 翻翻Tymon\\JWTAuth的目录，所以门面拿到的实例就是Tymon\\JWTAuth\\JWTAuth.php 诚不欺我，果然JWTAuth.php 有attempt方法 123456789101112131415/** * Attempt to authenticate the user and return the token. * * @param array $credentials * * @return false|string */public function attempt(array $credentials)&#123; if (! $this-&gt;auth-&gt;byCredentials($credentials)) &#123; return false; &#125; return $this-&gt;fromUser($this-&gt;user());&#125; 侦查手段（套路）$credentials数组就是我们问题里传入验证数组，验证数组又传给了$this-&gt;auth-&gt;byCredentials($credentials)，这个方法，相信大家已经知道套路了吧？没错他这个JWTAuth又注入了一个类实例来执行byCredentials方法，所以执行我们的套路 先翻一下构造器，注入的是什么接口 然后找找附近的provider，给这个接口绑定的是什么类实例 找到类实例，就是实际注入JWTAuth类的实例 所以通过一顿操作,JWTAuth.php的构造器如下 12345678910111213141516/** * @var \\Tymon\\JWTAuth\\Contracts\\Providers\\Auth */protected $auth;/** * @param \\Tymon\\JWTAuth\\Manager $manager * @param \\Tymon\\JWTAuth\\Contracts\\Providers\\Auth $auth * @param \\Tymon\\JWTAuth\\Http\\Parser\\Parser $parser * * @return void */public function __construct(Manager $manager, Auth $auth, Parser $parser)&#123; parent::__construct($manager, $parser); $this-&gt;auth = $auth;&#125; 所以锁定\\Tymon\\JWTAuth\\Contracts\\Providers\\Auth，继续翻AbstractServiceProvider 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected function registerAliases()&#123; $this-&gt;app-&gt;alias('tymon.jwt', JWT::class); $this-&gt;app-&gt;alias('tymon.jwt.auth', JWTAuth::class); $this-&gt;app-&gt;alias('tymon.jwt.provider.jwt', JWTContract::class); $this-&gt;app-&gt;alias('tymon.jwt.provider.auth', Auth::class); $this-&gt;app-&gt;alias('tymon.jwt.provider.storage', Storage::class); $this-&gt;app-&gt;alias('tymon.jwt.manager', Manager::class); $this-&gt;app-&gt;alias('tymon.jwt.blacklist', Blacklist::class); $this-&gt;app-&gt;alias('tymon.jwt.payload.factory', Factory::class); $this-&gt;app-&gt;alias('tymon.jwt.validators.payload', PayloadValidator::class);&#125;protected function registerAuthProvider()&#123; $this-&gt;app-&gt;singleton('tymon.jwt.provider.auth', function () &#123; return $this-&gt;getConfigInstance('providers.auth'); &#125;);&#125;protected function getConfigInstance($key)&#123; $instance = $this-&gt;config($key); if (is_string($instance)) &#123; return $this-&gt;app-&gt;make($instance); &#125; return $instance;&#125;protected function config($key, $default = null)&#123; return config(\"jwt.$key\", $default);&#125;// 此方法在helper中function config($key = null, $default = null)&#123; if (is_null($key)) &#123; return app('config'); &#125; if (is_array($key)) &#123; return app('config')-&gt;set($key); &#125; return app('config')-&gt;get($key, $default);&#125; 上面一连串貌似很复杂，其实就是\\Tymon\\JWTAuth\\Contracts\\Providers\\Auth::class起个别名叫做tymon.jwt.provider.auth，然后registerAuthProvider方法就是正式的绑定方法，通过一连串操作，最终是从/config/jwt.php(如果没用publish命令的，则访问tymon目录里的config) 拿出providers键名里，auth键名的东西 12345678910//就是Tymon\\JWTAuth\\Providers\\Auth\\Illuminate::class'providers' =&gt; [ 'jwt' =&gt; Tymon\\JWTAuth\\Providers\\JWT\\Namshi::class, 'auth' =&gt; Tymon\\JWTAuth\\Providers\\Auth\\Illuminate::class, 'storage' =&gt; Tymon\\JWTAuth\\Providers\\Storage\\Illuminate::class, ] laravel自带的helper中的config十分实用，一般我们开发是都是把配置数据以数组形式存入/config/脚本里，然后用config函数来通过键名(通常写法是xxxx.xxx.xx)读取对应的值 所以回到我们的目的attempt需要注入的auth，而注入的auth实际是Tymon\\JWTAuth\\Providers\\Auth\\Illuminate::class，同样的套路，里面的byCredentials方法里面注入了\\Illuminate\\Contracts\\Auth\\Guard，这个接口是属于Laravel的，而不是JWT内部的，这就是为什么JWT-auth切合了Laravel自带的Auth的原因，然后通过AbstractServiceProvider，我们可以知道，Laravel注册了自己的Auth时会翻一下配置文件/config/auth.php，然后根据guard里的driver来选择验证驱动，这就是为什么配置JWT-auth时需要配置/config/auth.php的原因 举一反三，找出罪魁祸首选择jwt作为guard驱动时，根据上面一流程的套路，就可以发现JWTAuth里面用到的byCredentials方法来自于JWTGuard，然后JWTGuard属于Laravel的拓展Guard，也是使用Laravel的一些功能，例如EloquentUserProvider,这个就是将我们的传入的数组与数据作对比的服务提供类,用到这两个方法retrieveByCredentials,validateCredentials 1234567891011121314151617181920212223//EloquentUserProvider.php public function retrieveByCredentials(array $credentials) &#123; if (empty($credentials)) &#123; return; &#125; $query = $this-&gt;createModel()-&gt;newQuery(); foreach ($credentials as $key =&gt; $value) &#123; if (! Str::contains($key, 'password')) &#123; $query-&gt;where($key, $value); &#125; &#125; return $query-&gt;first(); &#125; public function validateCredentials(UserContract $user, array $credentials) &#123; $plain = $credentials['password']; return $this-&gt;hasher-&gt;check($plain, $user-&gt;getAuthPassword()); &#125; 介绍下这两个方法的作用: retrieveByCredentials,通过验证数组，查询数据库(查询条件除去password) validateCredentials,拿到的数据与验证数组作对比，包括密码，当然密码是使用hash的check方法来检查的 结案陈词可见validateCredentials方法里$credentials[‘password’]这里就是限定我们attempt一定填入password字段名的原因，不填入这个字段名会报password index not found的异常，至于我传入的[‘phone’=&gt;’xxx’,’adminPass’=&gt;’xxxx’],没有报异常，是因为上面的retrieveByCredentials方法，正常会把非’password’字段纳入查询，所以把adminPass，导致方法返回false，导致于下面的validateCredentials方法因主调方(没记错的话主调方是JWTGuard里的attempt方法)的条件控制而进入不了，因而不报异常，直接返回false 总结&amp;收获通过这次阅读，让我接触到了laravel的核心部分，服务提供者，依赖注入等等，以及大概了解了laravel自带的权限认证时怎样的。其内部十分复杂，突出的一点是子模块特别的多！其实这体现了Laravel作者Taylor Otwell的设计理念，严守边界，一个类只实现自己的东西，绝不干涉其他类，以及利用了大量的面向接口编程，这种松耦合在开发拓展(遵循开放封闭原则)的时候，也能易于维护。唯一的缺点感觉就是不易于快速入门了，需要慢慢翻看。总的来说耐心是第一要务，没有耐心研究，什么都白谈~","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"JWT-Auth","slug":"JWT-Auth","permalink":"https://dawnki.github.io/tags/JWT-Auth/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://dawnki.github.io/tags/源码阅读/"}]},{"title":"Laravel中应用JWT","date":"2017-07-26T16:15:22.000Z","path":"2017/07/27/JWT/","text":"JWT-Json Web Token，一种基于json格式的开放标准，常常被用作替代cookie的认证方式，特别适合前后端分离的WEB应用，以及api接口。今天就讲讲如何在Laravel应用中使用JWT，虽然网上找到的Laravel集成JWT的方法，不过要么就坑点太多，要么就有诸多限制（比如要验证的模型有多个怎么配置）。 实验环境 Laravel 5.2+ PHP 5.5+ tymon/jwt-auth 1.0.0-beta.3 (十分重要) 起步利用composer安装jwt-atuh 在你的Laravel项目目录里composer.json补充上以下 12345&#123; \"required\" : &#123; \"tymon/jwt-auth\" : \"1.0.0-beta.3\" # 这个版本很急很关键，我用这个版本才能跑通..Orz &#125;&#125; 然后安装一下依赖 1$ composer update 配置Laravel的服务提供者及其门面 在/config/app.php里找到对应的数组，补充以下东西 1234567'providers' =&gt; [ Tymon\\JWTAuth\\Providers\\LaravelServiceProvider::class,]'aliases' =&gt; [ 'JWTAuth' =&gt; Tymon\\JWTAuth\\Facades\\JWTFactory::class,] 配置你的用户表（用户模型） 因为Jwt-auth默认用的是Laravel的auth权限管理，Laravel 的权限管理默认用的是项目一开始就有的User模型(/app/User.php)，下面姑且先用着Laravel的User模型为例，至于如何自定义用户模型使用其他表，我待会再讲 1234567891011121314151617181920212223242526272829&lt;?phpnamespace App;use Illuminate\\Foundation\\Auth\\User as Authenticatable;use Tymon\\JWTAuth\\Contracts\\JWTSubject;class User extends Authenticatable implements JWTSubject&#123; protected $fillable = [ 'name', 'email', 'password', ]; protected $hidden = [ 'password', 'remember_token', ]; // JWT-Auth默认要实现的方法 public function getJWTIdentifier() &#123; return $this-&gt;getKey(); &#125; // JWT-Auth默认要实现的方法 public function getJWTCustomClaims() &#123; return []; &#125;&#125; 可见，配置用户表只需继承Illuminate\\Foundation\\Auth\\User这个类，实现JWTSubject这个接口的两个方法即可。不过这个表必须要有password这个字段，必须有主键, 至于如果你的用户表不用password而是用userPass等等自己自定义的字段名怎么办，这个我待会再讲~ 配置Laravel的auth /config/auth.php 123456789101112131415161718192021222324252627'defaults' =&gt; [ 'guard' =&gt; 'api', // 此处改成api 'passwords' =&gt; 'users',],'guards' =&gt; [ 'web' =&gt; [ 'driver' =&gt; 'session', 'provider' =&gt; 'users', ], 'api' =&gt; [ 'driver' =&gt; 'jwt', // 此处改成jwt 'provider' =&gt; 'users', ],],'providers' =&gt; [ 'users' =&gt; [ 'driver' =&gt; 'eloquent', 'model' =&gt; App\\User::class, //你实际用到的用户表(用户模型)],// 'users' =&gt; [// 'driver' =&gt; 'database',// 'table' =&gt; 'users',// ],], 生成JWT密钥12$ php artisan vendor:publish # 将jwt的配置文件自动拉到/config目录$ php artisan jwt:secret # 自动生成JWT密钥，具体可看.env文件 实际业务逻辑 可以直接在你的控制器里进行调试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace App\\Http\\Controllers;use App\\User;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Auth;use Tymon\\JWTAuth\\Facades\\JWTAuth;class TestController extends Controller&#123; /** * 注册 */ public function register() &#123; User::create([ 'name' =&gt; 'Dawnki', 'phone' =&gt; '188xxxxxx', //此处例子假设以手机为账号 'password' =&gt; bcrypt('123456') //加密务必用Laravel中hepler提供的bcrypt ]); &#125; /** * 登录 * @param Request $request */ public function login(Request $request) &#123; //attempt方法用于验证帐号信息 成功则生成token值 //attempt必须有\"password\"字段，无论你是自定义密码字段 $token = JWTAuth::attempt(['phone'=&gt;'188xxxxxx','password'=&gt;123456]); return response(json_encode(['token'=&gt;$token]),200); &#125; /** * 访问内部页面 * 附上Header \"Authorization\" : \"Bearer token值\" 注意Bearer与token值间的空格 * @param Request $request * @return mixed */ public function index(Request $request) &#123; //return Auth::id(); //直接获取用户id return Auth::guard('api')-&gt;user(); //直接获取用户model &#125;&#125; 给index方法（即实际业务里的内部需要登陆后才能访问的接口）编写一个中间件12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\\Http\\Middleware;use Closure;use Illuminate\\Support\\Facades\\Auth;/** * Class UserMiddleware 用户中间件 * @package App\\Http\\Middleware */class UserMiddleware&#123; protected $auth; function __construct(Auth $auth) &#123; $this-&gt;auth = $auth; &#125; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next, $guard = 'api') &#123; if (!($user = Auth::guard($guard)-&gt;user())) &#123; // token值不对 根据实际情况编写返回错误信息,此处返回只作样例 return response('token',403); &#125; return $next($request); &#125;&#125; 此处只显示中间件的关键方法，至于如何给内部接口（如上例中的index方法）配置中间件自行解决，关键的验证即是 Auth::guard(‘api’)-&gt;user(); 当前端把Token值放入Header中， 即 “Authorization” : “Bearer token值”（注意Bearer与token值中的空格）. Jwt-Auth结合了Laravel的Auth就会通过user()方法自动从Header中取出token值，并且从中解密找出隐含在其中的用户摘要(id). 注意坑点:用户表的加密方式 务必使用bcrypt(即哈希加密),不要使用Crypt门面提供的加密，不要使用Crypt门面提供的加密，不要使用Crypt门面提供的加密!Crypt的加密不适合数据库迁移! 自定义你的用户模型首先自定义用户模型，不使用自带的User模型1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Foundation\\Auth\\User;use Tymon\\JWTAuth\\Contracts\\JWTSubject;class Admin extends User implements JWTSubject&#123; protected $table=\"admin\"; protected $primaryKey=\"admin_id\"; protected $fillable=[\"admin_name\",\"adminPass\"]; protected $guarded=''; protected $hidden=[\"adminPass\"]; public function getJWTIdentifier() &#123; return $this-&gt;getKey(); &#125; public function getJWTCustomClaims() &#123; return []; &#125; /** * 重写的方法 */ public function getAuthPassword() &#123; return $this-&gt;getAttribute('adminPass'); # 表中密码字段是adminPass &#125;&#125; 如上，只需继承User,实现JWTSubject。另外如果你表密码字段不是password，而是其他（如上的adminPass）,只需重写getAuthPassword方法(来自于Illuminate\\Foundation\\Auth\\User中用到的trait)即可 然后在/config/auth.php中修改 123456&lt;?php &apos;providers&apos; =&gt; [ &apos;users&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;eloquent&apos;, &apos;model&apos; =&gt; App\\Admin::class, //你需要的类 ] 然后你就可以使用自己编写的用户模型,又能搭配上JWT了! 另外此处有一个坑点就是你自定义的密码字段， 在attempt验证账号登陆时是要注意一些细节 12345678910&lt;?php /** * 登录 * @param Request $request */ public function login(Request $request) &#123; $token = JWTAuth::attempt(['phone'=&gt;'188xxxxxx','password'=&gt;123456]); return response(json_encode(['token'=&gt;$token]),200); &#125; 上例，我自定义的密码字段为adminPass，在调用attempt时，不要顺理成章的在验证数组里使用adminPass，依然是使用’password’，这是由于attempt方法内部的限定，在下一篇博客将详细介绍为何要这样~~如果你表里的字段是password的那就没你的事啦，此处只针对自定义的密码字段名 使用两个以上需要权限认证的表 比如一个系统中，有管理员和普通用户，他们分别存在两张不同的表(模型) 只需使用上 Config方法动态修改auth.php的model 即可 12345678910111213&lt;?php public function adminLogin(Request $request) &#123; Config::set('auth.providers.users.model',\\App\\Admin::class); #对应管理员表 // Todo your admin login method &#125; public function userLogin(Request $request) &#123; Config::set('auth.providers.users.model',\\App\\User::class); #对应用户表 // Todo your user login method &#125; 总结 刚开始没看Jwt-auth的源码时，配置起来真的很累，用了各种版本都不，最终发现1.0.0-beta.3可以，又根据github里面的issue，找遍了各种自定义方法加上自己琢磨了一下，才能使得根据自己项目的业务需求尽心修改，当中算是了解了jwt-auth是如何跟laravel自带的auth结合在一起的，收获还算可以。 最后附上tymon大大的github,虽然被他的拓展折磨的很惨，不过十分感谢大大的贡献.","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"JWT","slug":"JWT","permalink":"https://dawnki.github.io/tags/JWT/"},{"name":"Tymon/jwt-auth","slug":"Tymon-jwt-auth","permalink":"https://dawnki.github.io/tags/Tymon-jwt-auth/"}]},{"title":"Laravel的数据填充Seeder食用方法","date":"2017-07-18T17:49:47.000Z","path":"2017/07/19/Seeder/","text":"在日常开发中，经常需要往数据库里填充数据，以便调试接口发现bug。Laravel自带的数据填充器seeder也十分好用，纯自动化填充，还支持一键回滚，只需在使用之前定义些方法即可，下面就介绍一下seeder普遍的用法。 版本 Laravel 5.2 流程介绍 生成Seeder填充类 按实际情况定义模型工厂 执行artisan命令自动化填充数据到数据库 回滚，恢复到实际生产环境 起步首先利用artisan命令创建一个seeder类 1$ php artisan make:seeder TestSeeder 在/database/seeds/中，编写run方法 123456789class TestSeeder extends Seeder&#123; public function run() &#123; DB::table('YourTable')-&gt;insert([ 'name' =&gt; str_random(10) ]); &#125;&#125; 如上，只需把插入语句写进seeder类的run方法即可。上面的例子是往YourTable表里插入一条记录，但是这是我们日常都是大批量填充数据的，此时就需要用到模型工厂。 一个模型单角色定义模型工厂的定义脚本在/database/factories/ModelFactory.php，我们只需脚本里定义好模型，然后就可以在seeder类里使用了。 123456789$factory-&gt;define(App\\YourModel::class,function (Faker\\Generator $faker)&#123; return [ 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;email, 'password' =&gt; str_random(10), 'remember_token' =&gt; str_random(10), 'admin' =&gt; true, ];&#125;); Faker是专门生成假数据的包(GITHUB地址),这样至少生成的假数据也好看点而不是一堆乱码数字对吧。 一个模型多角色定义除了用define字段定义模型外，我们常常还用到defineAs，因为通常一个模型(表)里面，存在这不同角色，比如User表里可以存在普通用户或者管理员两种角色，这时可以用defineAs 12345678910$factory-&gt;defineAs(App\\YourModel::class,'admin',function (Faker\\Generator $faker)&#123; return [ // blabla 按实际情况编写 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;email, 'password' =&gt; str_random(10), 'remember_token' =&gt; str_random(10), 'is_admin' =&gt; true, ];&#125;); 生产这样我们就定义好了一个模型工厂，要工厂生产产品就需要用到Laravel的全局函数factory.生产产品的工厂一定要是定义过的才能用factory函数 1234567// 以下写在seeder类的run方法里// 生产1个模型实例$obj=$factory-&gt;(App\\YourModel::class)-&gt;make();// 生产5个模型实例 返回类型为collection$collection=$factory-&gt;(App\\YourModel::class,5)-&gt;make();// 生产5个admin身份的模型实例$collection=$factory-&gt;(App\\YourModel::class,'admin',5)-&gt;make(); 处理关联数据库插入时也经常涉及关联，比如有两张表父表与子表，由于存在关联关系，设置了外键约束时，填充数据会很蛋疼，不过利用Laravel的eloquent使得填充数据十分方便，下面就讲一下如何操作 首先假设有两张表father和son，其中son的主键参照father表中的一个字段id father的模型： 1234567class father extends Model&#123; public function test()&#123; // Laravel 的模型关联方法 不清楚的可以补一下文档 return $this-&gt;hasMany(\\App\\son:class,'id'); &#125;&#125; son的模型细节我旧忽略了，因为不是重点。接下来就要定义两个表的模型工厂 1234567891011$factory-&gt;define(App\\father::class,function ()&#123; return [ //blabla ] ;&#125;);$factory-&gt;define(App\\father::class,function ()&#123; return [ //blabla ] ;&#125;); 然后就可以在seeder类的run方法里使用了 12345factory(App\\father::class,3) -&gt;create() -&gt;each(function ($obj)&#123; $obj-&gt;test()-&gt;save(factory(App\\son::class,2)-&gt;make()); &#125;); 就可以在你填充3个父亲的数据的同时，也为每个父亲填充2个与之关联的儿子 填充器模块化一个填充器写N多个factory来填充数据，难免会看晕，因此我们需要将负责不同模型的生产分模块，划分成N多个子填充器 1234567public function run()&#123; Model::unguard(); $this-&gt;call(Test1Seeder::class); $this-&gt;call(Test2Seeder::class); // ....... Model::reguard();&#125; unguard函数貌似是关闭自动填充的限制，reguard是恢复限制.还有一个函数Model::truncate();用于放在成员函数里可以清空成员表数据，用来初始化填充还可以，不过有重要数据请备份。 最后一步在编写好seeder之后，运行artisan即可进行填充 12php artisan db:seedphp artisan db:seed --class=xxxxxSeeder // 你的填充类 一键回滚，重建数据库 1php artisan migrate:refresh --seed 坑点因为运行artisan命令时本质上是用CLI，因此请开启proc_open,proc_get_status等系统调用函数，留意你的CLI所用的拓展是否有对应数据库的拓展，如果遇到CLI的坑可以去翻一些我前几天些的关于CLI的坑，遇到什么permission denied的给对应文件加上权限就好。","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"Seeder","slug":"Seeder","permalink":"https://dawnki.github.io/tags/Seeder/"},{"name":"数据填充","slug":"数据填充","permalink":"https://dawnki.github.io/tags/数据填充/"}]},{"title":"Redis报错:MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk","date":"2017-07-16T09:06:53.000Z","path":"2017/07/16/Redis报错/","text":"在捣鼓redis时，一次不小心关闭了强制关闭了redis-cli，导致下次启动cli,进行数据插入操作时报错了，具体错误如下: (error) MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error. 在网上查了较多的资料最好的解决方式是启动redis-cli,然后 1$ 127.0.0.1:6379&gt; config set stop-writes-on-bgsave-error no 然后就OK了~老哥这方法贼稳，哈哈哈","tags":[{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"Redis","slug":"Redis","permalink":"https://dawnki.github.io/tags/Redis/"}]},{"title":"Linux环境下Redis安装并配置PHP","date":"2017-07-16T07:16:24.000Z","path":"2017/07/16/redis安装/","text":"Redis作为一种高效的nosql数据库，常常被用作为缓存，本篇就讲一下关于Redis的安装配置，以及怎么应用到PHP项目当中。 安装并配置Redis 下载官网最新且稳定的redis版本 1234wget http://download.redis.io/releases/redis-4.0.0.tar.gz # 此处安装的是redis4.0tar xzf redis-4.0.0.tar.gz # 解压下载完的压缩包cd redis-4.0.0 make # 编译安装 编译安装完之后，redis目录里会生成/src目录 下面是几个重要的文件路径 redis配置文件 /path/to/redis-xxx/redis.confredis服务端 /path/to/redis-xxx/src/redis-serverredis客户端 /path/to/redis-xxx/src/redis-cli 配置redis服务器守护进程 有时我们通过shell开启了redis-server之后，如果不把他放进守护进程就会一直占用我们的shell，因此需要把redis的服务端进程放进守护进程 1vi /path/to/redis-xxx/redis.conf 通过vi的/daemonize，找到守护进程的配置，把yes改为no保存退出即可. 下次开启redis-server时需要 1./redis-server ./../redis.conf # 即参数为配置文件的路径 也可以编写shell脚本redis-server,不用输入配置文件路径,随便找个地方放，不要放到src就行,具体如下 12#!/bin/bash`/path/to/redis-xxx/src/redis-server /path/to/redis-xxx/redis.conf` 然后加上执行权限 1sudo chmod +x redis-server # 此处的redis-server为刚刚编写的脚本 为了方便shell里直接启动，把软连接放到/usr/local/bin里 12ln -s /path/to/your-script/redis-server /usr/local/bin # 刚写的脚本路径ln -s /path/to/redis-xxx/src/redis-cli /usr/local/bin # 实际客户端的路径 这样即可在shell里开启带有守护的redis-server了，而不用输入配置文件路径参数，如下: 1redis-server 把Redis应用到PHP中 PHP连接redis有两种途径，一种是用phpredis拓展，由c编写的php拓展，因此处理效率较高，不过不支持PHP5.2以下的版本。第二种是用predis，是一个php包，可以理解为PHP应用来连接redis，效率没有phpredis不过适应高，容易部署。由于我在踩phpredis的坑时中招了，下面就用predis吧，毕竟简单易用。 我采用composer安装方式，在composer.json里附上 12345&#123; \"require\": &#123; \"predis/predis\": \"~1.1@dev\" &#125;&#125; 然后就可以用predis连接redis进行各种操作了,具体函数跟redis原生指令相差不大，在这就不多赘述 可以安装phpredisadmin管理你的redis，开发环境可以用，生产的话还是算了吧","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"Redis","slug":"Redis","permalink":"https://dawnki.github.io/tags/Redis/"},{"name":"Linux","slug":"Linux","permalink":"https://dawnki.github.io/tags/Linux/"}]},{"title":"那些年PHP-CLI踩过的坑","date":"2017-07-14T11:32:54.000Z","path":"2017/07/14/cli的坑/","text":"最近在捣鼓swoole以及phpunit时，需要用到PHP-CLI（PHP的命令行模式），可是却中途却一直出现问题，就以phpunit为例，在用到调试数据库的断言时，出现could not find driver，以及在捣鼓swoole时，使用了swoole的定义类缺找不到，最终原来发现PHP-CLI模式的拓展与PHP-FPM那边的拓展配置不一致导致的。 基础 在填坑前先介绍下几个路径以及命令： /usr/local/php 通常是通过网页调用PHP脚本(FastCGI,FPM)时，php配置以及拓展放置的目录 /usr/bin/ 用户命令放置的地方，也是PHP-CLI调用php命令放置的地方 php -m 查看CLI模式下加载的拓展以及模块 在脚本中编写phpinfo();然后网页访问，可以查看网络调用脚本时加载的拓展和模块 /etc/php 在某些情况下，PHP-CLI调用PHP脚本时，php配置以及拓展放置的目录，也是本文的罪魁祸首 步骤 在linux里安装多个PHP版本或者，安装过PHP7时有可能会出现CLI模式与普通模式(网页调用PHP脚本)配置以及模块不一致的情况，由于我是用LNMP安装的PHP7，之后有安装了PHPStorm，不知是不是乱搞的关系，导致CLI与普通模式加载配置不一致了，在折腾Swoole时就明显发现了这个问题。 要知道模块是否加载一致，普通模式用phpinfo() ，命令行模式直接用php -m就可以查到模块是否一致了。 若不一致时，绝大多是/usr/bin/php(大多是软连接)指向/etc/php/bin目录里的php 1ls -li 软链接文件 # 这样既可找到链接指向的源文件 要解决也是十分简单，只需把/usr/local/php/bin里面的php的软连接放到/usr/bin/里即可，注意要把之前/usr/bin/里的php删掉 12rm -rf /usr/bin/phpln -s /usr/lcoal/php/bin/php /usr/bin/php # 软连接的两个参数都需写绝对路径 接着在命令行里 1php -m 即可发现CLI模式加载的模块就与普通模式保持一致了","tags":[{"name":"PHP CLI","slug":"PHP-CLI","permalink":"https://dawnki.github.io/tags/PHP-CLI/"},{"name":"Swoole","slug":"Swoole","permalink":"https://dawnki.github.io/tags/Swoole/"},{"name":"Linux","slug":"Linux","permalink":"https://dawnki.github.io/tags/Linux/"}]},{"title":"PHP实现链式操作","date":"2017-07-06T13:11:32.000Z","path":"2017/07/06/链式操作/","text":"玩耍过jQuery的朋友们应该对链式操作不陌生，链式操作在实际应用上不仅美观，并且代码容易阅读，下面用PHP简单实现下链式操作。 1$(\"#Test\").css('color','red').show(200).removeClass('style'); //jquery中的链式操作 起步 先贴一波代码 123456789101112131415161718192021222324&lt;?php class A &#123; private $name; private $age; # 要改变的属性聚合在类中成为类属性 public function cname($name) &#123; $this-&gt;name=$name; return $this; # 链式操作的关键 方法中返回对象自身 &#125; public function cage($age) &#123; $this-&gt;age=$age; return $this; &#125; public function __toString() &#123; return 'name:'.$this-&gt;name.' age:'.$this-&gt;age; &#125; &#125; 实际调用 123$instance = new A();$instance-&gt;cage(111)-&gt;cname(\"Dawnki\");echo $instance; // name:Dawnki age:111 简单吧？如果是改变的属性为对象，即可进行更多的操作，这个代码风格使用起来也是十分顺手易读性强。 Laravel 使用的链式操作 Laravel在对数据库增删查询也是采用链式操作： 1Model::where('xxx','xxx')-&gt;where('xxxxxx','xxxx')-&gt;get(); 这里就会有个小问题，上面的链式操作明明都是return $this , 这里Model上来就搞了个where的静态方法，不会炸开锅吗？ 实际上，阅读下Laravel的源码，里面采用了许多魔术方法，下面就看看源码的实现(好像有点偏题，哈哈) 在/vendor/laravel/illuminate/Database/Eloquent/Model.php中找到他们的两个魔术方法 12345678910111213141516171819202122232425262728293031/** * Handle dynamic method calls into the model. * * @param string $method * @param array $parameters * @return mixed */public function __call($method, $parameters)&#123; if (in_array($method, ['increment', 'decrement'])) &#123; return call_user_func_array([$this, $method], $parameters); &#125; $query = $this-&gt;newQuery(); return call_user_func_array([$query, $method], $parameters);&#125;/** * Handle dynamic static method calls into the method. * * @param string $method * @param array $parameters * @return mixed */public static function __callStatic($method, $parameters)&#123; $instance = new static; return call_user_func_array([$instance, $method], $parameters);&#125; 可见,当 Model:where(xxxx) 时，会先生成一个Model的实例(执行__callStatic)，然后再用回调函数,让这个刚生成的实例去执行where，由于模型里面本来是没有涉及sql查询的方法，正在执行sql语句的是同目录下面的Builder.php,即SQL构造器，这个builder里面才负责处理SQL.因此Model的实例因为没有where方法而执行魔术方法__call来生成一个构造器(builder)去执行where方法。所以 真正执行where方法的是Builder.php 下面是/vendor/laravel/illuminate/Database/Eloquent/Builder中的where方法 123456789101112131415161718192021222324/** * Add a basic where clause to the query. * * @param string $column * @param string $operator * @param mixed $value * @param string $boolean * @return $this */public function where($column, $operator = null, $value = null, $boolean = 'and')&#123; if ($column instanceof Closure) &#123; $query = $this-&gt;model-&gt;newQueryWithoutScopes(); call_user_func($column, $query); $this-&gt;query-&gt;addNestedWhereQuery($query-&gt;getQuery(), $boolean); &#125; else &#123; call_user_func_array([$this-&gt;query, 'where'], func_get_args()); &#125; return $this; # 链式操作关键&#125; 用链式操作改造CURL 附带一个利用链式操作的封装curl类 总结 所以不妨改良一下自己的代码吧！~","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"链式操作","slug":"链式操作","permalink":"https://dawnki.github.io/tags/链式操作/"}]},{"title":"PHP的打包工具--Phar实践","date":"2017-07-04T10:40:40.000Z","path":"2017/07/04/Phar/","text":"Phar,是一种将PHP程序打包的工具，至PHP5.3以来开始支持，这个就类似于Java中的jar包，使用的时候也十分简便，只要include或者require即可，网上的许多PHP的SDK也支持这种打包方式。下面就简单说下怎么使用phar打包以及引入phar包。 实验环境 PHP5.6 打包PHP程序修改PHP配置 要想利用Phar将PHP应用程序打包，先修改php.ini的相关配置 打开php.ini，找到phar.readonly 1phar.readonly = Off # 去掉;的注释，并且将On改为Off 此时就可以愉快的使用phar打包 开始打包 假定项目的目录结构如下图: Demo的github地址 build.php 为我们的打包程序. 内容如下: 12345678910111213&lt;?php // 参数内容为生成文件路径 此例中则在当前目录生成example.phar打包程序 $phar = new Phar('example.phar'); // 开始打包 $phar-&gt;startBuffering(); // 要打包的目的目录 绝对路径 $phar-&gt;buildFromDirectory(__DIR__); // 压缩方式 GZ-&gt;gzip BZ2-&gt;bz2 $phar-&gt;compressFiles(Phar::GZ); // 设置启动加载脚本 即导入phar之后第一个自动执行的脚本 $phar-&gt;setStub($phar-&gt;createDefaultStub('index.php')); // 结束打包 $phar-&gt;stopBuffering(); 其中buildFromDirectory方法还接收第二个参数可以用正则表达式来筛选不需打包的文件 123&lt;?php // 只打包结尾为.php的文件 $phar-&gt;buildFromDirectory(__DIR__,'/\\.php$/'); 使用phar打包程序 如果是直接使用整个项目的话可以直接，用include 或者 require 123&lt;?php // 直接导入phar包 并且会自动执行启动脚本 require_once __DIR__.'/example.phar'; 如果只是导入phar中的一个脚本，可以这样 123&lt;?php // 只导入 your_script.php 这个脚本 include 'phar://example.phar/your_project_path/your_script.php'; 注意事(坑)项(点) 假如你打包的项目中，入口文件index.php 要引入(include or require)项目中的其他脚本，务必使用绝对路径，否则你打包成phar包之后，其他项目要引入这个phar就会路径出错!!,即如下: 123&lt;?php //这是index.php 入口文件 require __DIR__.\"/src/controller.php\"; //要使用绝对路径 require \"./lib/tools.php\"; //不要使用相对路径 感谢 &amp; 参考资料 韩天峰大大的博客 官方文档","tags":[{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"Phar","slug":"Phar","permalink":"https://dawnki.github.io/tags/Phar/"}]},{"title":"(转) 2017年PHP程序员未来路在何方","date":"2017-07-01T09:19:41.000Z","path":"2017/07/01/2017PHP程序出路/","text":"作者: 韩天峰转载连接: 2017年PHP程序员未来路在何方 PHP 从诞生到现在已经有20多年历史，从Web时代兴起到移动互联网退潮，互联网领域各种编程语言和技术层出不穷， Node.js 、 GO 、 Python 不断地在挑战 PHP 的地位。这些技术的推动者非常热衷于唱衰 PHP ， PHP 语言的未来在哪里？PHP 程序员当如何应对未来的变革？ 作为老牌的Web后端编程语言，PHP 在全球市场占有率非常高，仅次于 Java ，从各个招聘网站的数据上来看PHP 开发的职位非常多，薪资水平也非常不错。实际在中小企业、互联网创业公司PHP的市场地位是高于 Java 的。Java 在超大型企业、传统软件行业、金融领域优势更大。目前来看 Node.js、 GO 、 Python 、 Ruby 等语言还难以企及PHP和Java。 PHP 语言之所以能有今天的地位，得益于PHP语言设计者一直遵从实用主义，将技术的复杂性隐藏在底层。PHP 语言入门简单，容易掌握，程序健壮性好，不容易出现像 Java 、 C++ 等其他语言那样复杂的问题，如内存泄漏和 Crash ，跟踪调试相对轻松很多。PHP 官方提供的标准库非常强大，各种功能函数都能在官方的标准库中找到，包括MySQL、Memcache、Redis、GD图形库、CURL、XML、JSON等等，免除了开发者到处找库的烦恼。PHP 的文档非常棒，每个函数都有详细的说明和使用示例。第三方类库和工具、代码、项目也很丰富。开发者可以快速、高效地使用 PHP 编写开发各类软件。到目前为止市面上仍然没有出现比 PHP 更简单易用的编程语言。所以 PHP 的前景还是很广阔的，与其纠结于编程语言的选择，不如好好地深入学习使用 PHP 。 作为一个资深的 PHP 开发者，在技术上给各位 PHP 程序十点未来的建议，希望对大家有所帮助。 Composer第一点就要提 Composer ，自从 Composer 出现后，PHP 的依赖管理可以变得非常简单。程序内依赖一些类库和框架，直接使用 Composer 引入即可，通过使用 composer update 安装依赖的包。解决了过去加载外部库的各种难题。Composer 也有国内镜像，速度非常快。现在绝大部分PHP开源的项目都提供了 Composer 的支持，建议大家在项目中使用 Composer 来解决 PHP 代码包管理的问题，不要再使用下载源码、手工 include 的原始方法。 PHP7PHP7 版本对 Zend 引擎做了大量修改，大幅提升了 PHP 语言的性能，使用 PHP7 可以使你的程序性能瞬间翻倍。即使是 WordPress 这样重量级的软件运行在 PHP7 都能有上千 QPS ，相当于一台服务器每天就能处理 8000 万次请求。使用 PHP7 ，做好 MySQL 优化，使用 Memcache 和 Redis 进行加速，这套技术架构完全可以应对相当大规模的系统。除了某些亿级用户的平台之外，一般规模的系统完全没有压力。 PSRPSR 是 http://www.php-fig.org/ 组织制定的PHP语言开发规范，约定了很多方面的规则，如命名空间、类名规范、编码风格标准、Autoload、公共接口等。现在已经成为PHP技术社区事实上的标准了。很多知名的 PHP 框架和类库都遵守了 PSR 规范。PHP 开发者应当学习掌握 PSR 规范，在开发程序时应当尽量遵循 PSR 规范。 Swoole2017 年 PHP 还局限于做 Web 网站吗？No ，如果你还不知道 Swoole ，赶快去了解一下吧。Swoole 的口号是重新定义 PHP 语言，Swoole 是一个异步并行的通信引擎，作为 PHP 的扩展来运行。Node.js 的异步回调 Swoole 有，Go语言的协程 Swoole 也有，这完全颠覆了对 PHP 的认知。使用 Swoole PHP 可以实现常驻内存的 Server 程序，可以实现 TCP 、 UDP 异步网络通信的编程开发。过去PHP只能做一个 Web 网站，现在使用 Swoole 可以做 Java 、C++ 才能实现的通信服务，比如 WebSocket 即使通信、聊天、推送服务器、RPC 远程调用服务、网关、代理、游戏服务器等。如果你想用 PHP 做点 Web 系统之外的东西，Swoole 是最好的选择。 Laravel最近几年最火热的 PHP 框架，官网号称是为 Web 艺术家设计的框架，可见这套框架有多优雅。Laravel 提供的功能模块丰富，API 设计简洁，表达力强。而且它的社区非常活跃，代码贡献者众多，第三方的插件非常多，生态系统相当繁荣。 Laravel 底层使用了很多 symfony2 组件，通过 composer 实现了依赖管理。如果还在纠结使用什么PHP框架，不如选择 Laravel 。 Laravel 提供的命令行工具基于 symfony.console 实现，功能强大，集成了各种项目管理、自动生成代码的功能。 PharPHP5.3 之后支持了类似 Java 的 jar 包，名为 phar。用来将多个 PHP 文件打包为一个文件。这个特性使得 PHP 也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到PHP-FPM 中运行。配合 Swoole ，可以在命令行下执行 php server.phar 一键启动服务器。PHP 的代码包可以用 Phar 打包成组件，放到 Swoole 的服务器容器中去加载执行。 C/C++/GO任何技术有优点就有缺点，PHP 作为一门动态脚本语言，优点是开发方便效率高。缺点就是性能差。在密集运算的场景下比 C 、 C++ 相差几十倍甚至上百倍。另外 PHP 不可以直接操作底层，需要依赖扩展库来提供 API 实现。PHP 程序员可以学习一门静态编译语言作为补充实现动静互补，C/C++/Go 都是不错的选择。而且静态语言的编程体验与动态语言完全不同，学习过程可以让你得到更大的提升。 掌握 C/C++ 语言后，还可以阅读 PHP 、 Swoole 、 Nginx 、Redis 、 Linux内核 等开源软件的源码，了解其底层运行原理。 现在最新版本的Swoole提供了C++扩展模块的支持，封装了Zend API，用C++操作PHP变得很简单，可以用C++实现PHP扩展函数和类。 HTML5作为 Web 前端新一代标准，HTML5 未来前景非常广阔，市场需求量非常大。从 PC 网站、B/S 企业软件、移动端网页、APP，这些领域都在拥抱 HTML5，掌握了 HTML5 才能在下一波互联网技术大潮中存活下来。 Vue.jsPHP 程序员除了写后台程序之外，还有很大一部分工作在展现层，和浏览器前端打交道。2017 年你还在用 jQuery 操作 DOM 实现界面渲染吗？已经完全 out 了。现在用 Vue.js 可以非常方便地实现数据和 DOM 元素的绑定。通过 Ajax 请求后台接口返回数据后，更新前端数据自动实现界面渲染。2017 年再不学 Vue 就晚了。 如果你不光要写 Web 程序，同时还希望兼顾 Android 、IOS 、PC 客户端等平台，React Native 是一个不错的选择。 深度学习/人工智能互联网的未来属于人工智能，如果你还不了解机器学习、深度学习、人工智能这些概念，那你需要尽快学习了解一下。现在互联网巨头们都在布局人工智能，包括 Google 、 Facebook 、微软、亚马逊 和国内的百度。虽然现在还处于科学研究的阶段，但未来互联网的各个领域都会应用到人工智能，包括自动驾驶、大数据分析、网络游戏、图像识别、语言处理等。当然现在普通的工程师可能还无法参与到人工智能产品中，但至少应该理解深度学习/人工智能的基本概念和原理。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"技术栈","slug":"技术栈","permalink":"https://dawnki.github.io/tags/技术栈/"}]},{"title":"mysql开启Innodb引擎","date":"2017-06-30T19:41:26.000Z","path":"2017/07/01/Mysql开启Innodb引擎/","text":"Innodb引擎是我们经常用到的mysql存储引擎，在我们需要事务管理以及外键等功能的时候，单单的Myisam引擎并不满足我们的需求，此时就需要我们启用innodb引擎。不过在我们安装数据库或者用lnmp一键安装配置，没有选开启innodb引擎，那该怎么办呢？ 起步 关闭mysql服务 1$ service mysql stop 1$ sudo lnmp stop # lnmp一键安装的用户 修改mysql配置文件(my.ini / my.cnf) linux用户需要修改的是my.cnf文件. 1$ vi /etc/my.cnf 在里面一行加入 innodb = ON ，然后保存退出 重启mysql或lnmp即可开启innodb引擎 小结 以上方法仅适用于已经安装了innodb引擎，但是没有开启的情况 可以在mysql的shell里面输入 show engines; 来查看是否安装了innodb引擎 网上查到的结果说my.cnf中如果有 skip-innodb 就用#号注释掉，然后并没找到，只找到loose-skip-innodb，然而当我一注释时，启动mysql就出错，因此不能随便注释..","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"开启Innodb","slug":"开启Innodb","permalink":"https://dawnki.github.io/tags/开启Innodb/"}]},{"title":"软件杯设计大赛展示视频","date":"2017-06-29T04:24:10.000Z","path":"2017/06/29/软件杯设计大赛展示视频/","text":"第六届 中国软件杯 大学生软件设计大赛概述 所选课题: 图片认知分类系统设计与开发 PowerBy: SCAU_Cifar团队 团队成员: Ariel Dawnki Seahub 课题地址: http://www.cnsoftbei.com/bencandy.php?fid=148&amp;aid=1537 成果视频展示ImgTagger&amp;ImgMaster: 优酷 腾讯视频","tags":[{"name":"图片认知","slug":"图片认知","permalink":"https://dawnki.github.io/tags/图片认知/"},{"name":"机器学习","slug":"机器学习","permalink":"https://dawnki.github.io/tags/机器学习/"},{"name":"中国软件杯","slug":"中国软件杯","permalink":"https://dawnki.github.io/tags/中国软件杯/"}]},{"title":"PHP系统调用(调用Bash&Python脚本)","date":"2017-06-27T04:05:23.000Z","path":"2017/06/27/PHP系统调用/","text":"有时候，我们在使用php进行开发时，需要调用服务器上的脚本或者调用python脚本来实现某些功能，这时候就需要使用PHP的系统调用函数。不过实际调用中会出现许许多多的问题，就拿最近有关机器学习的项目，后台是PHP实现的，不过机器学习部分用的是Python(需要用到caffe)，中间调用python就遇到了许许多多的坑。 实验环境 系统: Ubuntu 14.04 PHP: 5.6.22 Python: 2.7.6 起步 在挖矿之前先介绍一下php的系统调用函数吧: system() 描述：执行外部程序，成功则返回命令输出的最后一行， 失败则返回 FALSE，特点直接输出 12$command='pwd';system($command); 1/home/wwwroot/cifar/public exec() 描述：执行一个外部程序,返回命令执行结果的最后一行内容。不直接输出到屏幕.如果输出只有一行则按空格为分隔符获取内容,如果多行则按行来为分隔符来获取内容存入到数组中. 123$command='pwd';exec($command,$result); //命令输出内容存至result变量print_r($result); 1234Array( [0] =&gt; /home/wwwroot/cifar/public) shell_exec() 描述： 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。返回命令执行的输出。 如果执行过程中发生错误或者进程不产生输出，则返回 NULL。使用本函数无法通过返回值检测进程是否成功执行。 如果需要检查进程执行的退出码，请使用 exec() 函数。 123$command='who';$data=shell_exec($command);print_r($data); 12root tty1 Jun 25 14:46root pts/0 Jun 27 12:44 passthru() 描述：执行外部程序并且显示原始输出 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。特点直接输出,原始输出 12$command='who';passthru($command); 12root tty1 Jun 25 14:46root pts/0 Jun 27 12:44 综上 要获取原始输出就用passthru 听说exec跟表单(grep查询的结果)更配哦 其他函数看着需求用就好 挖坑 起步完之后就会开始进入实践，就会遇到各种坑，准备好了吗？ 第一坑： disable_functions 解除PHP禁用函数 虽说这个默认设置不是坑，但是99%的服务器在你部署完php之后，disable_funcitons设置上都会禁用掉上面所用到函数，所以先去php.ini里面解除系统调用函数设置 vi /usr/local/php/etc/php.ini (我lnmp安装默认是这个路径的，php安装在其他地方的请自行调整) 打开配置文件后找到disable_functions(可以用vi在命令模式下/disable_functions来查找) 将你之后用到的系统调用函数删去(exec,system,passthru等等),如果不在此列则表示没有默认禁用该PHP函数 保存(Esc退出到命令模式然后:wq!退出)，如果权限不够不能写则自行加权限解决 重启PHP/LNMP (lnmp restart) 然后就可以愉快地使用系统调用函数了 第二坑： 补充错误日志 在你调试命令的时候，最烦的不是出错，最烦的是出错了但没有错误提示，因此不能对症下药，所以，不妨在你调试命令时，顺便输出到文本文件，然后去文本文件里面找错误输出。 123$command='ll / 2&gt;/xxxxxx/log.txt'; //将错误重定向到log.txtexec($command,$result); //命令输出内容存至result变量print_r($result); 建议命令里面涉及路径的全部都用上绝对路径，并且给日志文件给上权限(777简单粗暴) bash命令中的0代表标准输入，1代表标准输出，2代表标准错误输出 第三坑： 权限 在你补充完错误日志时，你会发现最多的错误就是有关于权限的，以及有关于sudoer的，因为当你浏览器发送一个请求给服务器的web应用时，web服务器(apache或者nginx)所用的用户(www)不具备root的一些权限，所以需要修改sudoer以及涉及到的文件权限(读写操作) visudo 直接编辑 (进入利用nano编辑器编辑sudoer) 如果发现文本中存在 defaults requiretty 的，则用#号注释掉如 #defaults requiretty apache用户的话一般系统会建立apache用户，nginx用户的话一般是www用户(可用vi /usr/local/nginx/conf/nginx.conf查看，第一行就是显示nginx所用的用户) 在visudo末尾中 添加 www ALL=NOPASSWD:ALL 或者 apache ALL=NOPASSWD:ALL(不同web服务器所用的用户不同) 然后ctrl+x 按Y保存退出nano 然后给你需要读写的文件加上对应权限，就可以用PHP系统调用进行文件读写等等需要权限的操作 第四坑： 调用Python脚本时import问题 就举我上面提到的例子，PHP调用机器学习的Python脚本，这个Python脚本中用到了刚编译好的caffe（非Python标准库），然后import caffe的时候，或许在shell运行没问题，但是在PHP调用Python的时候可能就会炸了。 例如会报 ImportError: No module named caffe 的错误 12345#修改前的 PHP调用时会报caffe模块缺失的错误import numpy as npimport sysimport osimport caffe 123456import numpy as npimport sysimport ossys.path.append(\"/（caffe-master路径）/caffe/python\") #根据自己实际的绝对路径修改sys.path.append(\"/（caffe-master路径）/caffe/python/caffe\")#根据自己实际的绝对路径修改import caffe 对于其他需要自行编译的模块，同理举一反三吧~ 第五坑： PHP默认开始安全模式 如果PHP默认开启了安全模式，只要去php.ini里面把safe_mode(如果存在)用#号注释掉即关闭 小结 对于其他错误的话，根据错误日志慢慢解决就好，还有更多的坑需要填呢~最后说一句，既然PHP调用Python这么麻烦，为什么不直接用Python开发呢？因为PHP是世界上最好的语言啊(误) ^_^ PHP系统调用官方文档","tags":[{"name":"PHP函数","slug":"PHP函数","permalink":"https://dawnki.github.io/tags/PHP函数/"},{"name":"系统调用","slug":"系统调用","permalink":"https://dawnki.github.io/tags/系统调用/"},{"name":"PHP调用Python脚本","slug":"PHP调用Python脚本","permalink":"https://dawnki.github.io/tags/PHP调用Python脚本/"}]},{"title":"PHP常用的几种魔术方法","date":"2017-06-03T08:05:11.000Z","path":"2017/06/03/php的魔术方法/","text":"补个档，重新复习下php的几种魔术方法,同时魔术方法也是必须掌握的，面试什么的也是必考的.附上php文档的相关警告:PHP 将所有以两个下划线开头的类方法保留为魔术方法。所以在定义类方法时，除了讲到的魔术方法，建议不要以两个下划线为前缀. 切记切记~~ 常用魔术方法__construct() 描述:类构造方法，在实例化类时自动调用 12345678class A &#123; function __construct() //参数列表可选 &#123; //..... &#125;&#125;$instance = new A(); //实例化时自动调用 __destruct() 描述:析构函数，在对象的所有引用被删除或者脚本执行结束时调用 12345678910class A &#123; function __destruct() //参数列表为空 &#123; //... &#125;&#125;$instance = new A();unset($instance); //此处调用析构函数 如果此行注释掉，脚本结束亦会调用 __toString() 描述:当类被当作字符串时，此方法返回字符串。返回值为string，无参数。 123456789101112class A&#123; function __toString() &#123; return \"I AM A\"; &#125;&#125;$instance = new A();echo $instance;print $instance; __get() 描述:当读取不可访问属性的调用，参数string值，返回值mixed 12345678910111213class A&#123; private $a = 1; function __get($name) //$name为要访问的属性名 &#123; if(isset($this-&gt;$name))&#123; return $this-&gt;$name; &#125; &#125;&#125;$instance = new A();echo $instance-&gt;a; //1 __set() 描述:当给不可访问的属性赋值时调用，参数1(属性名) string 参数2(赋值) mixed ，返回值为void 1234567891011121314151617181920class A&#123; private $a = 1; function __set($name,$value) &#123; if(isset($this-&gt;$name))&#123; $this-&gt;$name=$value; &#125; &#125; function __get($name)&#123; if(isset($this-&gt;$name))&#123; return $this-&gt;$name; &#125; &#125;&#125;$instance = new A();$instance-&gt;a = 3; //自动调用__set()echo $instance-&gt;a; //自动调用__get() __isset() 描述:对当不可访问的属性调用isset()或empty()时,__isset()会被自动调用，接受一个string 参数(被访问的属性名) 1234567891011class A&#123; private $a; function __isset($name) //被访问的属性名 &#123; echo $name.\"__isset is invoked\"; &#125;&#125;$instance = new A();isset($instance-&gt;a); // a__isset is invoked __unset() 描述:对当不可访问的属性调用unset()时,__unset()会被自动调用，接受一个string 参数(被访问的属性名) 1234567891011class A&#123; private $a; function __unset($name) //被访问的属性名 &#123; echo $name.\"__unset is invoked\"; &#125;&#125;$instance = new A();unset($instance-&gt;a); //a__unset is invoked __call() 描述:当对象调用一个不可访问的方法是，__call()会被自动调用，接受两个参数，第一个参数string(方法名)，第二个参数array(参数列表) 1234567891011121314151617class A&#123; private function inside($a,$b) &#123; echo $a.'_'.$b; &#125; function __call($name,$args) //方法名&amp;参数列表 &#123; echo 'funciton_name:'.$name.' parameter:'.implode(' , ',$args); &#125;&#125;$instance = new A();$instance-&gt;inside(1,2,3); //funciton_name:inside parameter:1 , 2 , 3 __callStatic() 描述:当对象调用一个不可访问的静态方法是，__callStatic()会被自动调用，接受两个参数，第一个参数string(方法名)，第二个参数array(参数列表)，修饰必须是可见的以及静态的 12345678910111213class A&#123; private static function inside($a,$b) &#123; echo $a.'_'.$b; &#125; public static function __callStatic($name,$args) //修饰必须是可见的以及静态的 &#123; echo 'static_funciton_name:'.$name.' parameter:'.implode(' , ',$args); &#125;&#125;A::inside(1,2,3); //static_funciton_name:inside parameter:1 , 2 , 3 __clone() 描述:当使用关键字clone对象是，__clone()方法会被自动调用. 作用:因为clone是浅克隆，当要复制的对象内部有一个引用属性时，并不会进行复制，而是照搬引用，所以此时需要在__clone方法中对某些引用属性进行深克隆 1234567891011121314151617181920212223242526class A&#123; public $obj ; //引用对象 public function __construct(B $ojb) &#123; $this-&gt;obj = $ojb; &#125; function __clone()&#123; $this-&gt;obj = clone $this-&gt;obj; //对应引用对象进行深克隆 &#125;&#125;class B&#123; public $content=\"abc\";&#125;$a = new A(new B());$b = clone $a;$a-&gt;obj-&gt;content = \"efg\"; //即使$a内部的引用对象改变了echo $b-&gt;obj-&gt;content; //$b内部的引用对象仍不变 为abc __sleep() 描述:serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 备注:__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 12345678910111213141516class A&#123; public $var1 = 1; public $var2 = 2; public $var3 = 3; public function __sleep() //返回应被序列化的变量名称的数组 &#123; return array('var1','var2'); //序列化时忽略序列化$var3 &#125;&#125;$instance = new A();echo serialize($instance); //O:1:\"A\":2:&#123;s:4:\"var1\";i:1;s:4:\"var2\";i:2;&#125; Notice:serialize()和unserialize()，是将php的值与字符串相互转化的方法(序列化与反序列化)，主要便于存储，同时也不丢失类型结构。 __wakeup() 描述:unserialize(反序列化)对象时，__wakeup()会被自动调用。 作用:经常用在反序列化操作(字符串还原成对象时)中，例如重新建立数据库连接，或执行其它初始化操作。 123456789101112131415161718192021222324252627class A&#123; public $var1 = 1; public $var2 = 2; public $var3 = 3; public function __sleep() &#123; return array('var1','var2'); &#125; function __wakeup() &#123; $this-&gt;var1 = 233; &#125;&#125;$instance = new A();$a=serialize($instance);echo $a; // O:1:\"A\":2:&#123;s:4:\"var1\";i:1;s:4:\"var2\";i:2;&#125; 可见var1的值为1$a=unserialize($a);echo $a-&gt;var1; //输出233 而不是 1 魔术方法实现重载属性重载 PHP所提供的”属性重载”是指动态地”创建”类属性 12345678910111213141516171819202122232425262728class A&#123; // 可重载的属性存放在data数组中 private $data = array(); // 此属性不能被重载 public $declared = 1; // 从类外部访问此属性时才发生重载 private $hidden = 2; // 利用__set动态创建 public function __set($name , $value) &#123; $this-&gt;data[$name] = $value; &#125; // 返回重载属性数组data public function getData() &#123; return $this-&gt;data; &#125;&#125;$instance = new A();$instance-&gt;a = 3; //a属性被动态添加print_r($instance-&gt;getData()); //Array ( [a] =&gt; 3 ) 方法重载 传统的”重载”是用于提供多个同名的类方法，但各方法的参数类型和个数不同。不过要实现相同的功能可以使用__call()魔术方法. 1234567891011121314151617181920212223242526272829class A&#123; function __call($name,$args) &#123; if($name == 'func') &#123; $args_num = count($args); $invoke_name=$name.$args_num; if(method_exists($this,$invoke_name))&#123; call_user_func_array(array($this,$invoke_name),$args); //参数1:回调方法 参数2:数组形式的参数列表 &#125; &#125; &#125; function func1($arg1) &#123; echo \"invoke func1:\".$arg1; &#125; function func2($arg1,$arg2) &#123; echo \"invoke func2:\".$arg1.','.$arg2; &#125;&#125;$instance = new A();$instance-&gt;func(1); //执行func1$instance-&gt;func(1,2); //执行func2 notice:call_user_func_array方法的第一个参数是callable类型，一个已实例化的 object 的方法被作为 array 传递，下标 0 包含该 object，下标 1 包含方法名。 在同一个类里可以访问 protected 和 private 方法。 参考资料PHP官方文档","tags":[{"name":"PHP魔术方法","slug":"PHP魔术方法","permalink":"https://dawnki.github.io/tags/PHP魔术方法/"},{"name":"重载","slug":"重载","permalink":"https://dawnki.github.io/tags/重载/"}]},{"title":"Ubuntu完全卸载mysql","date":"2017-05-10T04:45:44.000Z","path":"2017/05/10/删除mysql/","text":"我们安装了mysql之后想卸载mysql时，往往是卸载不完全，导致下次安装又有问题，下面就提供ubuntu完全卸载mysql的方法. 实验环境 Linux: Ubuntu 16:04 Mysql 5.7 步骤 温馨提示:执行之前务必确认是否备份了数据库的数据,数据无价! 先在shell里执行以下指令 12345sudo apt-get autoremove --purge mysql-server*sudo apt-get remove mysql-server*sudo apt-get autoremove mysql-server*sudo apt-get remove mysql-commonsudo rm -rf /etc/my.cnf 建一个shell脚本(文件)叫deleteMysql.sh,内容如下: 1234567#!/bin/bashlist=`sudo find / -name mysql*`for i in $list do sudo rm -rf $idoneexit 0 给这个脚本加上执行权限后执行 12sudo chmod u+x deleteMysql.shsudo ./deleteMysql.sh 小结这下子mysql应该算是完全卸载了，然后就可以跑路(误)了!!!∑(ﾟДﾟノ)ノ","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"ubunut","slug":"ubunut","permalink":"https://dawnki.github.io/tags/ubunut/"}]},{"title":"Laravel5.2消息队列实践","date":"2017-05-10T03:21:41.000Z","path":"2017/05/10/laravel-job/","text":"在后台开发中，很多情况需要用到队列来处理业务逻辑，前几天亲自实践了一下Laravel的队列功能，在此分享一蛤。 使用情景举几个使用到消息队列的栗子 在处理商城的库存问题，简单的实现是当用户的某件商品下单了，库存就相对应减少，但是当并发量一大时，比如A,B两个顾客同时下单，如果不使用队列可能会造成库存错误，使用队列了保证不同时执行两个减库存操作(一个阻塞掉了另外一个)。 当一个服务器要处理一个请求端发来的多组大量数据，而且每组数据处理起来的时间会很慢时，可以采取异步队列，就相当于请求端发过来的数据先存着，放进队列里，然后再异步处理数据(即处理数据的过程不在请求的生命周期里) 由于比如用户登陆了某网站之后，后台就过xx分钟给用户发延迟邮件来推送广告(怎么有点流氓(°Д°))，这里也可以用到异步队列，虽然可以用设计定时任务来轮询检查的笨方法，不过感觉用轮询来实现异步不是真正的异步 扯了这么多，刚回到正题了—实践 实验环境 Laravel 5.2 系统: Windows(wamp) or Linux(lnmp) 步骤 配置laravel提供了多种消息队列驱动: sync(同步) database beanstalkd sqs redis默认是sync，不过实际上其他几种异步队列多点，本章先用database练练手，前几天刚服务器刚配好redis，迟点再补上redis的吧~ so,先到 /.env (默认根目录为你的项目目录) 中 填上 QUEUE_DRIVER=database ,当然你也可以到/config/queue.php的default中将sync修改，但是建议修改.env 建表修改完队列驱动后，就用Laravel的migration自动生成队列需要的表，到根目录执行artisan 123php artisan queue:tablephp artisan queue:failed-table #处理出错队列用的表php artisan migrate 此时，数据库中就会出现jobs表和failed_jobs表 创建任务类并编写任务类执行artisan命令快速生成任务类并在/app/jobs/ 目录下面找到刚创建的任务 1php artisan make:job yourJobName 刚自动生成的任务类包含了两个初始方法 12345678910111213141516171819/** * Create a new job instance. * * @return void */public function __construct()&#123; //&#125;/** * Execute the job. * * @return void */public function handle()&#123; //&#125; 构造方法__construct用于你给任务类传值or对象用，至于handle方法则是队列任务的处理(即给排在队列里的任务如何执行业务逻辑) 这时就有个问题了，排在队列里的任务如果处理时失败了，或者因不符合某些业务逻辑需要进行统一的失败操作，那该怎么办呢？ 此时可以在这个任务类中添加一个failed方法 1234public function failed()&#123; //&#125; 这样laravel就可以识别得到，当一个任务在执行handle方法时，遇到异常了(Throw Exception)，laravel就会自动捕获异常并执行failed方法，并在failed_job表中记录信息。这个用来管控你看不见摸不着的异步队列任务比较有用，你可以根据业务逻辑在failed方法里将错误信息输出到自己的日志或者其他操作。 任务类里自带的几个有用方法通过artisan生成的任务类里，由于使用(use)了InteractsWithQueue这个trait，所以可以使用到里面有几个自带的方法 attempts 作用:返回任务的已经执行次数(eg.可以用于在handle方法中判断任务执行超过n次时就抛出异常来执行failed方法等等) 食用方法:在任务类的handle方法或者failed方法中,无参 1$this-&gt;attempts(); delete 作用:在队列中删除该任务(jobs表里删除) 食用方法:同上 1$this-&gt;delete(); release 作用:将当前任务再次放进队列中，可传入参数，来控制同一个任务两次运行之间的等待时间 食用方法:同上，不过有参，参数为int类型 表示多少秒 1$this-&gt;release(10); // 同一个任务两次运行之间隔10秒执行 目前任务类里比较常用的就是这几个方法了。 执行任务代码里要做的事编写好任务类之后，你可以在你的控制器里面创建任务，并且将它调度执行(dispatch) 12$job=new yourJobName($value); // 按实际情况来传值dispatch($job); 如果想设置延时 12$job=new yourJobName()-&gt;delay(10); // 延迟10秒执行dispatch($job); 如果想指定队列(分类) 12$job=new yourJobName()-&gt;onQueue('test'); //可以查看对应job表的queue字段dispatch($job); shell里要做的事当代码里做的事做好了之后，我们一个请求过去服务器的项目程序就能启动任务了吗？不能，因为之前我们说过，除了sync其他驱动都是异步的，而php是单线程的(意味着一个开启一个php脚本相当于开启一个进程，而这个进程里面只有一个线程)，所以我们一个请求只有一个线程，因此我们需要开多一个进程来进行队列监听了，当监听脚本监听到队列有动静时，就对队列进行处理。 1php artisan queue:listen 测试 开始监听 发送请求(可以用postman试试)到指定控制器来调度队列任务 观察正在执行监听任务的shell(ctrl+c 退出监听) 小结 通过实践，算是掌握了laravel的队列使用，下面就提一下我遇到的坑点以及改进吧~ 注意事(坑)项(点) 当你使用了onQueue方法来给任务分类然后调度时，监听的命令该怎么写？ 一开始我天真的认为一句 php artisan queue:listen 就能监听所有分类的任务，结果之后发现我定义的一个分类的任务一直不执行，看了文档又找不到缘故 12$job=new yourJobName()-&gt;onQueue('test'); //将一个任务归为test分类dispatch($job); 1php artisan queue:listen # 你会发现,是监听不了上面的的任务的 翻了一下帮助命令 1php artisan help queue:listen 可以看到 所以正确的执行姿势应该是 12php artisan queue:listen --queue test # 以我上面的例子而言 此处队列分类是testphp artisan queue:listen --QUEUE test # help里面说到大写也可以 还有其他queue的命令就自己发掘或者看文档吧~ 优化 为了保护监听进程(失败后重启等)，我们可以尝试用一下Supervisor(linux) 因为现在很多缓存都用redis，所以这个队列任务如果用redis的话，就可以一举两得了~~ 以上两点列入到Todo list中，有空再捣鼓一蛤!! 感谢感谢 Laravel学院 的中文文档 ！","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"异步消息队列","slug":"异步消息队列","permalink":"https://dawnki.github.io/tags/异步消息队列/"}]},{"title":"Sublime Text 安装Package Controller","date":"2017-05-10T00:38:46.000Z","path":"2017/05/10/sublimetextPC/","text":"前言众所周知，sublime是一款很好用的文本编辑器，其好用之处在于其背后强大的插件功能，但是刚安装的sublime是不能直接安装插件的，需要先安装Package Controller 才能通过Package Controller来安装插件，下面就介绍如何安装Package Controller. 安装方法安装方法分为简单安装和手动安装,自行选择即可. 简单的安装方法使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码： Sublime Text 3 1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 如果顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了。 Sublime Text 2 的如下: 1import urllib2,os; pf=&apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), &apos;wb&apos; ).write( urllib2.urlopen( &apos;http://sublime.wbond.net/&apos; +pf.replace( &apos; &apos;,&apos;%20&apos; )).read()); print( &apos;Please restart Sublime Text to finish installation&apos;) 手动安装可能由于各种原因，无法使用代码安装，那可以通过以下步骤手动安装Package Control： 点击Preferences &gt; Browse Packages菜单 进入打开的目录的上层目录，然后再进入Installed Packages/目录 下载Package Control.sublime-package并复制到Installed Packages/目录 重启Sublime Text。 如何使用Package Controller 安装插件 快捷键ctrl+shift+P，或者直接在Preferences &gt; Package Controller 来打开 在输入框中输入 install package 按回车 在新弹出的框中输入你要安装的插件即可 效果如下图:","tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://dawnki.github.io/tags/Sublime-Text/"}]},{"title":"LNMP坑点系列:\"mysql.serviceJob for mysql.service failed because the control process exited with error code.\"","date":"2017-05-09T13:02:09.000Z","path":"2017/05/09/mysql-question/","text":"一天舍友在lnmp下，动了一下/etc/my.cnf文件之后,重启lnmp是出现了”mysql.serviceJob for mysql.service failed because the control process exited with error code.”的问题。 寻找元凶经过几番询问后，发现原来舍友为了更改mysql密码动了一下/etc/my.cnf文件. 锁定/etc/my.cnf文件！！ 可以看到这个文件的初始权限是拥有者有读写功能，但同组或者其他人只有读的功能，由于舍友为了修改这个文件，帮这个文件加了所有身份都加了写的功能。 即：1sudo chmod go+w /etc/my.cnf 接着重启就炸了 1sudo lnmp restart 解决办法要解决很简单，只将这个文件的权限还原即可(只保留拥有者有写功能) 1sudo chmod go-w /etc/my.cnf 如图修改完之后，大功告成!lnmp能正常重启了! 小结这个坑告诉我们一定要有做事要有头有尾，文件由于一时特殊需要改了权限的，之后完事后记得改回权限!!","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"}]},{"title":"Hello World","date":"2017-05-09T10:51:21.767Z","path":"2017/05/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]
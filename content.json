[{"title":"PHP实现链式操作","date":"2017-07-06T13:11:32.000Z","path":"2017/07/06/链式操作/","text":"玩耍过jQuery的朋友们应该对链式操作不陌生，链式操作在实际应用上不仅美观，并且代码容易阅读，下面用PHP简单实现下链式操作。 1$(\"#Test\").css('color','red').show(200).removeClass('style'); //jquery中的链式操作 起步 先贴一波代码 123456789101112131415161718192021222324&lt;?php class A &#123; private $name; private $age; # 要改变的属性聚合在类中成为类属性 public function cname($name) &#123; $this-&gt;name=$name; return $this; # 链式操作的关键 方法中返回对象自身 &#125; public function cage($age) &#123; $this-&gt;age=$age; return $this; &#125; public function __toString() &#123; return 'name:'.$this-&gt;name.' age:'.$this-&gt;age; &#125; &#125; 实际调用 123$instance = new A();$instance-&gt;cage(111)-&gt;cname(\"Dawnki\");echo $instance; // name:Dawnki age:111 简单吧？如果是改变的属性为对象，即可进行更多的操作，这个代码风格使用起来也是十分顺手易读性强。 Laravel 使用的链式操作 Laravel在对数据库增删查询也是采用链式操作： 1Model::where('xxx','xxx')-&gt;where('xxxxxx','xxxx')-&gt;get(); 这里就会有个小问题，上面的链式操作明明都是return $this , 这里Model上来就搞了个where的静态方法，不会炸开锅吗？ 实际上，阅读下Laravel的源码，里面采用了许多魔术方法，下面就看看源码的实现(好像有点偏题，哈哈) 在/vendor/laravel/illuminate/Database/Eloquent/Model.php中找到他们的两个魔术方法 12345678910111213141516171819202122232425262728293031/** * Handle dynamic method calls into the model. * * @param string $method * @param array $parameters * @return mixed */public function __call($method, $parameters)&#123; if (in_array($method, ['increment', 'decrement'])) &#123; return call_user_func_array([$this, $method], $parameters); &#125; $query = $this-&gt;newQuery(); return call_user_func_array([$query, $method], $parameters);&#125;/** * Handle dynamic static method calls into the method. * * @param string $method * @param array $parameters * @return mixed */public static function __callStatic($method, $parameters)&#123; $instance = new static; return call_user_func_array([$instance, $method], $parameters);&#125; 可见,当 Model:where(xxxx) 时，会先生成一个Model的实例(执行__callStatic)，然后再用回调函数,让这个刚生成的实例去执行where，由于模型里面本来是没有涉及sql查询的方法，正在执行sql语句的是同目录下面的Builder.php,即SQL构造器，这个builder里面才负责处理SQL.因此Model的实例因为没有where方法而执行魔术方法__call来生成一个构造器(builder)去执行where方法。所以 真正执行where方法的是Builder.php 下面是/vendor/laravel/illuminate/Database/Eloquent/Builder中的where方法 123456789101112131415161718192021222324/** * Add a basic where clause to the query. * * @param string $column * @param string $operator * @param mixed $value * @param string $boolean * @return $this */public function where($column, $operator = null, $value = null, $boolean = 'and')&#123; if ($column instanceof Closure) &#123; $query = $this-&gt;model-&gt;newQueryWithoutScopes(); call_user_func($column, $query); $this-&gt;query-&gt;addNestedWhereQuery($query-&gt;getQuery(), $boolean); &#125; else &#123; call_user_func_array([$this-&gt;query, 'where'], func_get_args()); &#125; return $this; # 链式操作关键&#125; 用链式操作改造CURL 附带一个利用链式操作的封装curl类 总结 所以不妨改良一下自己的代码吧！~","tags":[{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"链式操作","slug":"链式操作","permalink":"https://dawnki.github.io/tags/链式操作/"}]},{"title":"PHP的打包工具--Phar实践","date":"2017-07-04T10:40:40.000Z","path":"2017/07/04/Phar/","text":"Phar,是一种将PHP程序打包的工具，至PHP5.3以来开始支持，这个就类似于Java中的jar包，使用的时候也十分简便，只要include或者require即可，网上的许多PHP的SDK也支持这种打包方式。下面就简单说下怎么使用phar打包以及引入phar包。 实验环境 PHP5.6 打包PHP程序修改PHP配置 要想利用Phar将PHP应用程序打包，先修改php.ini的相关配置 打开php.ini，找到phar.readonly 1phar.readonly = Off # 去掉;的注释，并且将On改为Off 此时就可以愉快的使用phar打包 开始打包 假定项目的目录结构如下图: Demo的github地址 build.php 为我们的打包程序. 内容如下: 12345678910111213&lt;?php // 参数内容为生成文件路径 此例中则在当前目录生成example.phar打包程序 $phar = new Phar('example.phar'); // 开始打包 $phar-&gt;startBuffering(); // 要打包的目的目录 绝对路径 $phar-&gt;buildFromDirectory(__DIR__); // 压缩方式 GZ-&gt;gzip BZ2-&gt;bz2 $phar-&gt;compressFiles(Phar::GZ); // 设置启动加载脚本 即导入phar之后第一个自动执行的脚本 $phar-&gt;setStub($phar-&gt;createDefaultStub('index.php')); // 结束打包 $phar-&gt;stopBuffering(); 其中buildFromDirectory方法还接收第二个参数可以用正则表达式来筛选不需打包的文件 123&lt;?php // 只打包结尾为.php的文件 $phar-&gt;buildFromDirectory(__DIR__,'/\\.php$/'); 使用phar打包程序 如果是直接使用整个项目的话可以直接，用include 或者 require 123&lt;?php // 直接导入phar包 并且会自动执行启动脚本 require_once __DIR__.'/example.phar'; 如果只是导入phar中的一个脚本，可以这样 123&lt;?php // 只导入 your_script.php 这个脚本 include 'phar://example.phar/your_project_path/your_script.php'; 注意事(坑)项(点) 假如你打包的项目中，入口文件index.php 要引入(include or require)项目中的其他脚本，务必使用绝对路径，否则你打包成phar包之后，其他项目要引入这个phar就会路径出错!!,即如下: 123&lt;?php //这是index.php 入口文件 require __DIR__.\"/src/controller.php\"; //要使用绝对路径 require \"./lib/tools.php\"; //不要使用相对路径 感谢 &amp; 参考资料 韩天峰大大的博客 官方文档","tags":[{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"Phar","slug":"Phar","permalink":"https://dawnki.github.io/tags/Phar/"}]},{"title":"(转) 2017年PHP程序员未来路在何方","date":"2017-07-01T09:19:41.000Z","path":"2017/07/01/2017PHP程序出路/","text":"作者: 韩天峰转载连接: 2017年PHP程序员未来路在何方 PHP 从诞生到现在已经有20多年历史，从Web时代兴起到移动互联网退潮，互联网领域各种编程语言和技术层出不穷， Node.js 、 GO 、 Python 不断地在挑战 PHP 的地位。这些技术的推动者非常热衷于唱衰 PHP ， PHP 语言的未来在哪里？PHP 程序员当如何应对未来的变革？ 作为老牌的Web后端编程语言，PHP 在全球市场占有率非常高，仅次于 Java ，从各个招聘网站的数据上来看PHP 开发的职位非常多，薪资水平也非常不错。实际在中小企业、互联网创业公司PHP的市场地位是高于 Java 的。Java 在超大型企业、传统软件行业、金融领域优势更大。目前来看 Node.js、 GO 、 Python 、 Ruby 等语言还难以企及PHP和Java。 PHP 语言之所以能有今天的地位，得益于PHP语言设计者一直遵从实用主义，将技术的复杂性隐藏在底层。PHP 语言入门简单，容易掌握，程序健壮性好，不容易出现像 Java 、 C++ 等其他语言那样复杂的问题，如内存泄漏和 Crash ，跟踪调试相对轻松很多。PHP 官方提供的标准库非常强大，各种功能函数都能在官方的标准库中找到，包括MySQL、Memcache、Redis、GD图形库、CURL、XML、JSON等等，免除了开发者到处找库的烦恼。PHP 的文档非常棒，每个函数都有详细的说明和使用示例。第三方类库和工具、代码、项目也很丰富。开发者可以快速、高效地使用 PHP 编写开发各类软件。到目前为止市面上仍然没有出现比 PHP 更简单易用的编程语言。所以 PHP 的前景还是很广阔的，与其纠结于编程语言的选择，不如好好地深入学习使用 PHP 。 作为一个资深的 PHP 开发者，在技术上给各位 PHP 程序十点未来的建议，希望对大家有所帮助。 Composer第一点就要提 Composer ，自从 Composer 出现后，PHP 的依赖管理可以变得非常简单。程序内依赖一些类库和框架，直接使用 Composer 引入即可，通过使用 composer update 安装依赖的包。解决了过去加载外部库的各种难题。Composer 也有国内镜像，速度非常快。现在绝大部分PHP开源的项目都提供了 Composer 的支持，建议大家在项目中使用 Composer 来解决 PHP 代码包管理的问题，不要再使用下载源码、手工 include 的原始方法。 PHP7PHP7 版本对 Zend 引擎做了大量修改，大幅提升了 PHP 语言的性能，使用 PHP7 可以使你的程序性能瞬间翻倍。即使是 WordPress 这样重量级的软件运行在 PHP7 都能有上千 QPS ，相当于一台服务器每天就能处理 8000 万次请求。使用 PHP7 ，做好 MySQL 优化，使用 Memcache 和 Redis 进行加速，这套技术架构完全可以应对相当大规模的系统。除了某些亿级用户的平台之外，一般规模的系统完全没有压力。 PSRPSR 是 http://www.php-fig.org/ 组织制定的PHP语言开发规范，约定了很多方面的规则，如命名空间、类名规范、编码风格标准、Autoload、公共接口等。现在已经成为PHP技术社区事实上的标准了。很多知名的 PHP 框架和类库都遵守了 PSR 规范。PHP 开发者应当学习掌握 PSR 规范，在开发程序时应当尽量遵循 PSR 规范。 Swoole2017 年 PHP 还局限于做 Web 网站吗？No ，如果你还不知道 Swoole ，赶快去了解一下吧。Swoole 的口号是重新定义 PHP 语言，Swoole 是一个异步并行的通信引擎，作为 PHP 的扩展来运行。Node.js 的异步回调 Swoole 有，Go语言的协程 Swoole 也有，这完全颠覆了对 PHP 的认知。使用 Swoole PHP 可以实现常驻内存的 Server 程序，可以实现 TCP 、 UDP 异步网络通信的编程开发。过去PHP只能做一个 Web 网站，现在使用 Swoole 可以做 Java 、C++ 才能实现的通信服务，比如 WebSocket 即使通信、聊天、推送服务器、RPC 远程调用服务、网关、代理、游戏服务器等。如果你想用 PHP 做点 Web 系统之外的东西，Swoole 是最好的选择。 Laravel最近几年最火热的 PHP 框架，官网号称是为 Web 艺术家设计的框架，可见这套框架有多优雅。Laravel 提供的功能模块丰富，API 设计简洁，表达力强。而且它的社区非常活跃，代码贡献者众多，第三方的插件非常多，生态系统相当繁荣。 Laravel 底层使用了很多 symfony2 组件，通过 composer 实现了依赖管理。如果还在纠结使用什么PHP框架，不如选择 Laravel 。 Laravel 提供的命令行工具基于 symfony.console 实现，功能强大，集成了各种项目管理、自动生成代码的功能。 PharPHP5.3 之后支持了类似 Java 的 jar 包，名为 phar。用来将多个 PHP 文件打包为一个文件。这个特性使得 PHP 也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到PHP-FPM 中运行。配合 Swoole ，可以在命令行下执行 php server.phar 一键启动服务器。PHP 的代码包可以用 Phar 打包成组件，放到 Swoole 的服务器容器中去加载执行。 C/C++/GO任何技术有优点就有缺点，PHP 作为一门动态脚本语言，优点是开发方便效率高。缺点就是性能差。在密集运算的场景下比 C 、 C++ 相差几十倍甚至上百倍。另外 PHP 不可以直接操作底层，需要依赖扩展库来提供 API 实现。PHP 程序员可以学习一门静态编译语言作为补充实现动静互补，C/C++/Go 都是不错的选择。而且静态语言的编程体验与动态语言完全不同，学习过程可以让你得到更大的提升。 掌握 C/C++ 语言后，还可以阅读 PHP 、 Swoole 、 Nginx 、Redis 、 Linux内核 等开源软件的源码，了解其底层运行原理。 现在最新版本的Swoole提供了C++扩展模块的支持，封装了Zend API，用C++操作PHP变得很简单，可以用C++实现PHP扩展函数和类。 HTML5作为 Web 前端新一代标准，HTML5 未来前景非常广阔，市场需求量非常大。从 PC 网站、B/S 企业软件、移动端网页、APP，这些领域都在拥抱 HTML5，掌握了 HTML5 才能在下一波互联网技术大潮中存活下来。 Vue.jsPHP 程序员除了写后台程序之外，还有很大一部分工作在展现层，和浏览器前端打交道。2017 年你还在用 jQuery 操作 DOM 实现界面渲染吗？已经完全 out 了。现在用 Vue.js 可以非常方便地实现数据和 DOM 元素的绑定。通过 Ajax 请求后台接口返回数据后，更新前端数据自动实现界面渲染。2017 年再不学 Vue 就晚了。 如果你不光要写 Web 程序，同时还希望兼顾 Android 、IOS 、PC 客户端等平台，React Native 是一个不错的选择。 深度学习/人工智能互联网的未来属于人工智能，如果你还不了解机器学习、深度学习、人工智能这些概念，那你需要尽快学习了解一下。现在互联网巨头们都在布局人工智能，包括 Google 、 Facebook 、微软、亚马逊 和国内的百度。虽然现在还处于科学研究的阶段，但未来互联网的各个领域都会应用到人工智能，包括自动驾驶、大数据分析、网络游戏、图像识别、语言处理等。当然现在普通的工程师可能还无法参与到人工智能产品中，但至少应该理解深度学习/人工智能的基本概念和原理。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://dawnki.github.io/tags/PHP/"},{"name":"技术栈","slug":"技术栈","permalink":"https://dawnki.github.io/tags/技术栈/"}]},{"title":"mysql开启Innodb引擎","date":"2017-06-30T19:41:26.000Z","path":"2017/07/01/Mysql开启Innodb引擎/","text":"Innodb引擎是我们经常用到的mysql存储引擎，在我们需要事务管理以及外键等功能的时候，单单的Myisam引擎并不满足我们的需求，此时就需要我们启用innodb引擎。不过在我们安装数据库或者用lnmp一键安装配置，没有选开启innodb引擎，那该怎么办呢？ 起步 关闭mysql服务 1$ service mysql stop 1$ sudo lnmp stop # lnmp一键安装的用户 修改mysql配置文件(my.ini / my.cnf) linux用户需要修改的是my.cnf文件. 1$ vi /etc/my.cnf 在里面一行加入 innodb = ON ，然后保存退出 重启mysql或lnmp即可开启innodb引擎 小结 以上方法仅适用于已经安装了innodb引擎，但是没有开启的情况 可以在mysql的shell里面输入 show engines; 来查看是否安装了innodb引擎 网上查到的结果说my.cnf中如果有 skip-innodb 就用#号注释掉，然后并没找到，只找到loose-skip-innodb，然而当我一注释时，启动mysql就出错，因此不能随便注释..","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"开启Innodb","slug":"开启Innodb","permalink":"https://dawnki.github.io/tags/开启Innodb/"}]},{"title":"软件杯设计大赛展示视频","date":"2017-06-29T04:24:10.000Z","path":"2017/06/29/软件杯设计大赛展示视频/","text":"第六届 中国软件杯 大学生软件设计大赛概述 所选课题: 图片认知分类系统设计与开发 PowerBy: SCAU_Cifar团队 团队成员: Ariel Dawnki Seahub 课题地址: http://www.cnsoftbei.com/bencandy.php?fid=148&amp;aid=1537 成果视频展示ImgTagger&amp;ImgMaster: 优酷 腾讯视频","tags":[{"name":"图片认知","slug":"图片认知","permalink":"https://dawnki.github.io/tags/图片认知/"},{"name":"机器学习","slug":"机器学习","permalink":"https://dawnki.github.io/tags/机器学习/"},{"name":"中国软件杯","slug":"中国软件杯","permalink":"https://dawnki.github.io/tags/中国软件杯/"}]},{"title":"PHP系统调用(调用Bash&Python脚本)","date":"2017-06-27T04:05:23.000Z","path":"2017/06/27/PHP系统调用/","text":"有时候，我们在使用php进行开发时，需要调用服务器上的脚本或者调用python脚本来实现某些功能，这时候就需要使用PHP的系统调用函数。不过实际调用中会出现许许多多的问题，就拿最近有关机器学习的项目，后台是PHP实现的，不过机器学习部分用的是Python(需要用到caffe)，中间调用python就遇到了许许多多的坑。 实验环境 系统: Ubuntu 14.04 PHP: 5.6.22 Python: 2.7.6 起步 在挖矿之前先介绍一下php的系统调用函数吧: system() 描述：执行外部程序，成功则返回命令输出的最后一行， 失败则返回 FALSE，特点直接输出 12$command='pwd';system($command); 1/home/wwwroot/cifar/public exec() 描述：执行一个外部程序,返回命令执行结果的最后一行内容。不直接输出到屏幕.如果输出只有一行则按空格为分隔符获取内容,如果多行则按行来为分隔符来获取内容存入到数组中. 123$command='pwd';exec($command,$result); //命令输出内容存至result变量print_r($result); 1234Array( [0] =&gt; /home/wwwroot/cifar/public) shell_exec() 描述： 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。返回命令执行的输出。 如果执行过程中发生错误或者进程不产生输出，则返回 NULL。使用本函数无法通过返回值检测进程是否成功执行。 如果需要检查进程执行的退出码，请使用 exec() 函数。 123$command='who';$data=shell_exec($command);print_r($data); 12root tty1 Jun 25 14:46root pts/0 Jun 27 12:44 passthru() 描述：执行外部程序并且显示原始输出 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。特点直接输出,原始输出 12$command='who';passthru($command); 12root tty1 Jun 25 14:46root pts/0 Jun 27 12:44 综上 要获取原始输出就用passthru 听说exec跟表单(grep查询的结果)更配哦 其他函数看着需求用就好 挖坑 起步完之后就会开始进入实践，就会遇到各种坑，准备好了吗？ 第一坑： disable_functions 解除PHP禁用函数 虽说这个默认设置不是坑，但是99%的服务器在你部署完php之后，disable_funcitons设置上都会禁用掉上面所用到函数，所以先去php.ini里面解除系统调用函数设置 vi /usr/local/php/etc/php.ini (我lnmp安装默认是这个路径的，php安装在其他地方的请自行调整) 打开配置文件后找到disable_functions(可以用vi在命令模式下/disable_functions来查找) 将你之后用到的系统调用函数删去(exec,system,passthru等等),如果不在此列则表示没有默认禁用该PHP函数 保存(Esc退出到命令模式然后:wq!退出)，如果权限不够不能写则自行加权限解决 重启PHP/LNMP (lnmp restart) 然后就可以愉快地使用系统调用函数了 第二坑： 补充错误日志 在你调试命令的时候，最烦的不是出错，最烦的是出错了但没有错误提示，因此不能对症下药，所以，不妨在你调试命令时，顺便输出到文本文件，然后去文本文件里面找错误输出。 123$command='ll / 2&gt;/xxxxxx/log.txt'; //将错误重定向到log.txtexec($command,$result); //命令输出内容存至result变量print_r($result); 建议命令里面涉及路径的全部都用上绝对路径，并且给日志文件给上权限(777简单粗暴) bash命令中的0代表标准输入，1代表标准输出，2代表标准错误输出 第三坑： 权限 在你补充完错误日志时，你会发现最多的错误就是有关于权限的，以及有关于sudoer的，因为当你浏览器发送一个请求给服务器的web应用时，web服务器(apache或者nginx)所用的用户(www)不具备root的一些权限，所以需要修改sudoer以及涉及到的文件权限(读写操作) visudo 直接编辑 (进入利用nano编辑器编辑sudoer) 如果发现文本中存在 defaults requiretty 的，则用#号注释掉如 #defaults requiretty apache用户的话一般系统会建立apache用户，nginx用户的话一般是www用户(可用vi /usr/local/nginx/conf/nginx.conf查看，第一行就是显示nginx所用的用户) 在visudo末尾中 添加 www ALL=NOPASSWD:ALL 或者 apache ALL=NOPASSWD:ALL(不同web服务器所用的用户不同) 然后ctrl+x 按Y保存退出nano 然后给你需要读写的文件加上对应权限，就可以用PHP系统调用进行文件读写等等需要权限的操作 第四坑： 调用Python脚本时import问题 就举我上面提到的例子，PHP调用机器学习的Python脚本，这个Python脚本中用到了刚编译好的caffe（非Python标准库），然后import caffe的时候，或许在shell运行没问题，但是在PHP调用Python的时候可能就会炸了。 例如会报 ImportError: No module named caffe 的错误 12345#修改前的 PHP调用时会报caffe模块缺失的错误import numpy as npimport sysimport osimport caffe 123456import numpy as npimport sysimport ossys.path.append(\"/（caffe-master路径）/caffe/python\") #根据自己实际的绝对路径修改sys.path.append(\"/（caffe-master路径）/caffe/python/caffe\")#根据自己实际的绝对路径修改import caffe 对于其他需要自行编译的模块，同理举一反三吧~ 第五坑： PHP默认开始安全模式 如果PHP默认开启了安全模式，只要去php.ini里面把safe_mode(如果存在)用#号注释掉即关闭 小结 对于其他错误的话，根据错误日志慢慢解决就好，还有更多的坑需要填呢~最后说一句，既然PHP调用Python这么麻烦，为什么不直接用Python开发呢？因为PHP是世界上最好的语言啊(误) ^_^ PHP系统调用官方文档","tags":[{"name":"PHP函数","slug":"PHP函数","permalink":"https://dawnki.github.io/tags/PHP函数/"},{"name":"系统调用","slug":"系统调用","permalink":"https://dawnki.github.io/tags/系统调用/"},{"name":"PHP调用Python脚本","slug":"PHP调用Python脚本","permalink":"https://dawnki.github.io/tags/PHP调用Python脚本/"}]},{"title":"PHP常用的几种魔术方法","date":"2017-06-03T08:05:11.000Z","path":"2017/06/03/php的魔术方法/","text":"补个档，重新复习下php的几种魔术方法,同时魔术方法也是必须掌握的，面试什么的也是必考的.附上php文档的相关警告:PHP 将所有以两个下划线开头的类方法保留为魔术方法。所以在定义类方法时，除了讲到的魔术方法，建议不要以两个下划线为前缀. 切记切记~~ 常用魔术方法__construct() 描述:类构造方法，在实例化类时自动调用 12345678class A &#123; function __construct() //参数列表可选 &#123; //..... &#125;&#125;$instance = new A(); //实例化时自动调用 __destruct() 描述:析构函数，在对象的所有引用被删除或者脚本执行结束时调用 12345678910class A &#123; function __destruct() //参数列表为空 &#123; //... &#125;&#125;$instance = new A();unset($instance); //此处调用析构函数 如果此行注释掉，脚本结束亦会调用 __toString() 描述:当类被当作字符串时，此方法返回字符串。返回值为string，无参数。 123456789101112class A&#123; function __toString() &#123; return \"I AM A\"; &#125;&#125;$instance = new A();echo $instance;print $instance; __get() 描述:当读取不可访问属性的调用，参数string值，返回值mixed 12345678910111213class A&#123; private $a = 1; function __get($name) //$name为要访问的属性名 &#123; if(isset($this-&gt;$name))&#123; return $this-&gt;$name; &#125; &#125;&#125;$instance = new A();echo $instance-&gt;a; //1 __set() 描述:当给不可访问的属性赋值时调用，参数1(属性名) string 参数2(赋值) mixed ，返回值为void 1234567891011121314151617181920class A&#123; private $a = 1; function __set($name,$value) &#123; if(isset($this-&gt;$name))&#123; $this-&gt;$name=$value; &#125; &#125; function __get($name)&#123; if(isset($this-&gt;$name))&#123; return $this-&gt;$name; &#125; &#125;&#125;$instance = new A();$instance-&gt;a = 3; //自动调用__set()echo $instance-&gt;a; //自动调用__get() __isset() 描述:对当不可访问的属性调用isset()或empty()时,__isset()会被自动调用，接受一个string 参数(被访问的属性名) 1234567891011class A&#123; private $a; function __isset($name) //被访问的属性名 &#123; echo $name.\"__isset is invoked\"; &#125;&#125;$instance = new A();isset($instance-&gt;a); // a__isset is invoked __unset() 描述:对当不可访问的属性调用unset()时,__unset()会被自动调用，接受一个string 参数(被访问的属性名) 1234567891011class A&#123; private $a; function __unset($name) //被访问的属性名 &#123; echo $name.\"__unset is invoked\"; &#125;&#125;$instance = new A();unset($instance-&gt;a); //a__unset is invoked __call() 描述:当对象调用一个不可访问的方法是，__call()会被自动调用，接受两个参数，第一个参数string(方法名)，第二个参数array(参数列表) 1234567891011121314151617class A&#123; private function inside($a,$b) &#123; echo $a.'_'.$b; &#125; function __call($name,$args) //方法名&amp;参数列表 &#123; echo 'funciton_name:'.$name.' parameter:'.implode(' , ',$args); &#125;&#125;$instance = new A();$instance-&gt;inside(1,2,3); //funciton_name:inside parameter:1 , 2 , 3 __callStatic() 描述:当对象调用一个不可访问的静态方法是，__callStatic()会被自动调用，接受两个参数，第一个参数string(方法名)，第二个参数array(参数列表)，修饰必须是可见的以及静态的 12345678910111213class A&#123; private static function inside($a,$b) &#123; echo $a.'_'.$b; &#125; public static function __callStatic($name,$args) //修饰必须是可见的以及静态的 &#123; echo 'static_funciton_name:'.$name.' parameter:'.implode(' , ',$args); &#125;&#125;A::inside(1,2,3); //static_funciton_name:inside parameter:1 , 2 , 3 __clone() 描述:当使用关键字clone对象是，__clone()方法会被自动调用. 作用:因为clone是浅克隆，当要复制的对象内部有一个引用属性时，并不会进行复制，而是照搬引用，所以此时需要在__clone方法中对某些引用属性进行深克隆 1234567891011121314151617181920212223242526class A&#123; public $obj ; //引用对象 public function __construct(B $ojb) &#123; $this-&gt;obj = $ojb; &#125; function __clone()&#123; $this-&gt;obj = clone $this-&gt;obj; //对应引用对象进行深克隆 &#125;&#125;class B&#123; public $content=\"abc\";&#125;$a = new A(new B());$b = clone $a;$a-&gt;obj-&gt;content = \"efg\"; //即使$a内部的引用对象改变了echo $b-&gt;obj-&gt;content; //$b内部的引用对象仍不变 为abc __sleep() 描述:serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 备注:__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 12345678910111213141516class A&#123; public $var1 = 1; public $var2 = 2; public $var3 = 3; public function __sleep() //返回应被序列化的变量名称的数组 &#123; return array('var1','var2'); //序列化时忽略序列化$var3 &#125;&#125;$instance = new A();echo serialize($instance); //O:1:\"A\":2:&#123;s:4:\"var1\";i:1;s:4:\"var2\";i:2;&#125; Notice:serialize()和unserialize()，是将php的值与字符串相互转化的方法(序列化与反序列化)，主要便于存储，同时也不丢失类型结构。 __wakeup() 描述:unserialize(反序列化)对象时，__wakeup()会被自动调用。 作用:经常用在反序列化操作(字符串还原成对象时)中，例如重新建立数据库连接，或执行其它初始化操作。 123456789101112131415161718192021222324252627class A&#123; public $var1 = 1; public $var2 = 2; public $var3 = 3; public function __sleep() &#123; return array('var1','var2'); &#125; function __wakeup() &#123; $this-&gt;var1 = 233; &#125;&#125;$instance = new A();$a=serialize($instance);echo $a; // O:1:\"A\":2:&#123;s:4:\"var1\";i:1;s:4:\"var2\";i:2;&#125; 可见var1的值为1$a=unserialize($a);echo $a-&gt;var1; //输出233 而不是 1 魔术方法实现重载属性重载 PHP所提供的”属性重载”是指动态地”创建”类属性 12345678910111213141516171819202122232425262728class A&#123; // 可重载的属性存放在data数组中 private $data = array(); // 此属性不能被重载 public $declared = 1; // 从类外部访问此属性时才发生重载 private $hidden = 2; // 利用__set动态创建 public function __set($name , $value) &#123; $this-&gt;data[$name] = $value; &#125; // 返回重载属性数组data public function getData() &#123; return $this-&gt;data; &#125;&#125;$instance = new A();$instance-&gt;a = 3; //a属性被动态添加print_r($instance-&gt;getData()); //Array ( [a] =&gt; 3 ) 方法重载 传统的”重载”是用于提供多个同名的类方法，但各方法的参数类型和个数不同。不过要实现相同的功能可以使用__call()魔术方法. 1234567891011121314151617181920212223242526272829class A&#123; function __call($name,$args) &#123; if($name == 'func') &#123; $args_num = count($args); $invoke_name=$name.$args_num; if(method_exists($this,$invoke_name))&#123; call_user_func_array(array($this,$invoke_name),$args); //参数1:回调方法 参数2:数组形式的参数列表 &#125; &#125; &#125; function func1($arg1) &#123; echo \"invoke func1:\".$arg1; &#125; function func2($arg1,$arg2) &#123; echo \"invoke func2:\".$arg1.','.$arg2; &#125;&#125;$instance = new A();$instance-&gt;func(1); //执行func1$instance-&gt;func(1,2); //执行func2 notice:call_user_func_array方法的第一个参数是callable类型，一个已实例化的 object 的方法被作为 array 传递，下标 0 包含该 object，下标 1 包含方法名。 在同一个类里可以访问 protected 和 private 方法。 参考资料PHP官方文档","tags":[{"name":"PHP魔术方法","slug":"PHP魔术方法","permalink":"https://dawnki.github.io/tags/PHP魔术方法/"},{"name":"重载","slug":"重载","permalink":"https://dawnki.github.io/tags/重载/"}]},{"title":"Ubuntu完全卸载mysql","date":"2017-05-10T04:45:44.000Z","path":"2017/05/10/删除mysql/","text":"我们安装了mysql之后想卸载mysql时，往往是卸载不完全，导致下次安装又有问题，下面就提供ubuntu完全卸载mysql的方法. 实验环境 Linux: Ubuntu 16:04 Mysql 5.7 步骤 温馨提示:执行之前务必确认是否备份了数据库的数据,数据无价! 先在shell里执行以下指令 12345sudo apt-get autoremove --purge mysql-server*sudo apt-get remove mysql-server*sudo apt-get autoremove mysql-server*sudo apt-get remove mysql-commonsudo rm -rf /etc/my.cnf 建一个shell脚本(文件)叫deleteMysql.sh,内容如下: 1234567#!/bin/bashlist=`sudo find / -name mysql*`for i in $list do sudo rm -rf $idoneexit 0 给这个脚本加上执行权限后执行 12sudo chmod u+x deleteMysql.shsudo ./deleteMysql.sh 小结这下子mysql应该算是完全卸载了，然后就可以跑路(误)了!!!∑(ﾟДﾟノ)ノ","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"ubunut","slug":"ubunut","permalink":"https://dawnki.github.io/tags/ubunut/"}]},{"title":"Laravel5.2消息队列实践","date":"2017-05-10T03:21:41.000Z","path":"2017/05/10/laravel-job/","text":"在后台开发中，很多情况需要用到队列来处理业务逻辑，前几天亲自实践了一下Laravel的队列功能，在此分享一蛤。 使用情景举几个使用到消息队列的栗子 在处理商城的库存问题，简单的实现是当用户的某件商品下单了，库存就相对应减少，但是当并发量一大时，比如A,B两个顾客同时下单，如果不使用队列可能会造成库存错误，使用队列了保证不同时执行两个减库存操作(一个阻塞掉了另外一个)。 当一个服务器要处理一个请求端发来的多组大量数据，而且每组数据处理起来的时间会很慢时，可以采取异步队列，就相当于请求端发过来的数据先存着，放进队列里，然后再异步处理数据(即处理数据的过程不在请求的生命周期里) 由于比如用户登陆了某网站之后，后台就过xx分钟给用户发延迟邮件来推送广告(怎么有点流氓(°Д°))，这里也可以用到异步队列，虽然可以用设计定时任务来轮询检查的笨方法，不过感觉用轮询来实现异步不是真正的异步 扯了这么多，刚回到正题了—实践 实验环境 Laravel 5.2 系统: Windows(wamp) or Linux(lnmp) 步骤 配置laravel提供了多种消息队列驱动: sync(同步) database beanstalkd sqs redis默认是sync，不过实际上其他几种异步队列多点，本章先用database练练手，前几天刚服务器刚配好redis，迟点再补上redis的吧~ so,先到 /.env (默认根目录为你的项目目录) 中 填上 QUEUE_DRIVER=database ,当然你也可以到/config/queue.php的default中将sync修改，但是建议修改.env 建表修改完队列驱动后，就用Laravel的migration自动生成队列需要的表，到根目录执行artisan 123php artisan queue:tablephp artisan queue:failed-table #处理出错队列用的表php artisan migrate 此时，数据库中就会出现jobs表和failed_jobs表 创建任务类并编写任务类执行artisan命令快速生成任务类并在/app/jobs/ 目录下面找到刚创建的任务 1php artisan make:job yourJobName 刚自动生成的任务类包含了两个初始方法 12345678910111213141516171819/** * Create a new job instance. * * @return void */public function __construct()&#123; //&#125;/** * Execute the job. * * @return void */public function handle()&#123; //&#125; 构造方法__construct用于你给任务类传值or对象用，至于handle方法则是队列任务的处理(即给排在队列里的任务如何执行业务逻辑) 这时就有个问题了，排在队列里的任务如果处理时失败了，或者因不符合某些业务逻辑需要进行统一的失败操作，那该怎么办呢？ 此时可以在这个任务类中添加一个failed方法 1234public function failed()&#123; //&#125; 这样laravel就可以识别得到，当一个任务在执行handle方法时，遇到异常了(Throw Exception)，laravel就会自动捕获异常并执行failed方法，并在failed_job表中记录信息。这个用来管控你看不见摸不着的异步队列任务比较有用，你可以根据业务逻辑在failed方法里将错误信息输出到自己的日志或者其他操作。 任务类里自带的几个有用方法通过artisan生成的任务类里，由于使用(use)了InteractsWithQueue这个trait，所以可以使用到里面有几个自带的方法 attempts 作用:返回任务的已经执行次数(eg.可以用于在handle方法中判断任务执行超过n次时就抛出异常来执行failed方法等等) 食用方法:在任务类的handle方法或者failed方法中,无参 1$this-&gt;attempts(); delete 作用:在队列中删除该任务(jobs表里删除) 食用方法:同上 1$this-&gt;delete(); release 作用:将当前任务再次放进队列中，可传入参数，来控制同一个任务两次运行之间的等待时间 食用方法:同上，不过有参，参数为int类型 表示多少秒 1$this-&gt;release(10); // 同一个任务两次运行之间隔10秒执行 目前任务类里比较常用的就是这几个方法了。 执行任务代码里要做的事编写好任务类之后，你可以在你的控制器里面创建任务，并且将它调度执行(dispatch) 12$job=new yourJobName($value); // 按实际情况来传值dispatch($job); 如果想设置延时 12$job=new yourJobName()-&gt;delay(10); // 延迟10秒执行dispatch($job); 如果想指定队列(分类) 12$job=new yourJobName()-&gt;onQueue('test'); //可以查看对应job表的queue字段dispatch($job); shell里要做的事当代码里做的事做好了之后，我们一个请求过去服务器的项目程序就能启动任务了吗？不能，因为之前我们说过，除了sync其他驱动都是异步的，而php是单线程的(意味着一个开启一个php脚本相当于开启一个进程，而这个进程里面只有一个线程)，所以我们一个请求只有一个线程，因此我们需要开多一个进程来进行队列监听了，当监听脚本监听到队列有动静时，就对队列进行处理。 1php artisan queue:listen 测试 开始监听 发送请求(可以用postman试试)到指定控制器来调度队列任务 观察正在执行监听任务的shell(ctrl+c 退出监听) 小结 通过实践，算是掌握了laravel的队列使用，下面就提一下我遇到的坑点以及改进吧~ 注意事(坑)项(点) 当你使用了onQueue方法来给任务分类然后调度时，监听的命令该怎么写？ 一开始我天真的认为一句 php artisan queue:listen 就能监听所有分类的任务，结果之后发现我定义的一个分类的任务一直不执行，看了文档又找不到缘故 12$job=new yourJobName()-&gt;onQueue('test'); //将一个任务归为test分类dispatch($job); 1php artisan queue:listen # 你会发现,是监听不了上面的的任务的 翻了一下帮助命令 1php artisan help queue:listen 可以看到 所以正确的执行姿势应该是 12php artisan queue:listen --queue test # 以我上面的例子而言 此处队列分类是testphp artisan queue:listen --QUEUE test # help里面说到大写也可以 还有其他queue的命令就自己发掘或者看文档吧~ 优化 为了保护监听进程(失败后重启等)，我们可以尝试用一下Supervisor(linux) 因为现在很多缓存都用redis，所以这个队列任务如果用redis的话，就可以一举两得了~~ 以上两点列入到Todo list中，有空再捣鼓一蛤!! 感谢感谢 Laravel学院 的中文文档 ！","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"异步消息队列","slug":"异步消息队列","permalink":"https://dawnki.github.io/tags/异步消息队列/"}]},{"title":"Sublime Text 安装Package Controller","date":"2017-05-10T00:38:46.000Z","path":"2017/05/10/sublimetextPC/","text":"前言众所周知，sublime是一款很好用的文本编辑器，其好用之处在于其背后强大的插件功能，但是刚安装的sublime是不能直接安装插件的，需要先安装Package Controller 才能通过Package Controller来安装插件，下面就介绍如何安装Package Controller. 安装方法安装方法分为简单安装和手动安装,自行选择即可. 简单的安装方法使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码： Sublime Text 3 1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 如果顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了。 Sublime Text 2 的如下: 1import urllib2,os; pf=&apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), &apos;wb&apos; ).write( urllib2.urlopen( &apos;http://sublime.wbond.net/&apos; +pf.replace( &apos; &apos;,&apos;%20&apos; )).read()); print( &apos;Please restart Sublime Text to finish installation&apos;) 手动安装可能由于各种原因，无法使用代码安装，那可以通过以下步骤手动安装Package Control： 点击Preferences &gt; Browse Packages菜单 进入打开的目录的上层目录，然后再进入Installed Packages/目录 下载Package Control.sublime-package并复制到Installed Packages/目录 重启Sublime Text。 如何使用Package Controller 安装插件 快捷键ctrl+shift+P，或者直接在Preferences &gt; Package Controller 来打开 在输入框中输入 install package 按回车 在新弹出的框中输入你要安装的插件即可 效果如下图:","tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://dawnki.github.io/tags/Sublime-Text/"}]},{"title":"LNMP坑点系列:\"mysql.serviceJob for mysql.service failed because the control process exited with error code.\"","date":"2017-05-09T13:02:09.000Z","path":"2017/05/09/mysql-question/","text":"一天舍友在lnmp下，动了一下/etc/my.cnf文件之后,重启lnmp是出现了”mysql.serviceJob for mysql.service failed because the control process exited with error code.”的问题。 寻找元凶经过几番询问后，发现原来舍友为了更改mysql密码动了一下/etc/my.cnf文件. 锁定/etc/my.cnf文件！！ 可以看到这个文件的初始权限是拥有者有读写功能，但同组或者其他人只有读的功能，由于舍友为了修改这个文件，帮这个文件加了所有身份都加了写的功能。 即：1sudo chmod go+w /etc/my.cnf 接着重启就炸了 1sudo lnmp restart 解决办法要解决很简单，只将这个文件的权限还原即可(只保留拥有者有写功能) 1sudo chmod go-w /etc/my.cnf 如图修改完之后，大功告成!lnmp能正常重启了! 小结这个坑告诉我们一定要有做事要有头有尾，文件由于一时特殊需要改了权限的，之后完事后记得改回权限!!","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"}]},{"title":"Hello World","date":"2017-05-09T10:51:21.767Z","path":"2017/05/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]
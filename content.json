[{"title":"PHP系统调用(调用Bash&Python脚本)","date":"2017-06-27T04:05:23.000Z","path":"2017/06/27/PHP系统调用/","text":"有时候，我们在使用php进行开发时，需要调用服务器上的脚本或者调用python脚本来实现某些功能，这时候就需要使用PHP的系统调用函数。不过实际调用中会出现许许多多的问题，就拿最近有关机器学习的项目，后台是PHP实现的，不过机器学习部分用的是Python(需要用到caffe)，中间调用python就遇到了许许多多的坑。 实验环境 系统: Ubuntu 14.04 PHP: 5.6.22 Python: 2.7.6 起步 在挖矿之前先介绍一下php的系统调用函数吧: system() 描述：执行外部程序，成功则返回命令输出的最后一行， 失败则返回 FALSE，特点直接输出 12$command='pwd';system($command); 1/home/wwwroot/cifar/public exec() 描述：执行一个外部程序,返回命令执行结果的最后一行内容。不直接输出到屏幕.如果输出只有一行则按空格为分隔符获取内容,如果多行则按行来为分隔符来获取内容存入到数组中. 123$command='pwd';exec($command,$result); //命令输出内容存至result变量print_r($result); 1234Array( [0] =&gt; /home/wwwroot/cifar/public) shell_exec() 描述： 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。返回命令执行的输出。 如果执行过程中发生错误或者进程不产生输出，则返回 NULL。使用本函数无法通过返回值检测进程是否成功执行。 如果需要检查进程执行的退出码，请使用 exec() 函数。 123$command='who';$data=shell_exec($command);print_r($data); 12root tty1 Jun 25 14:46root pts/0 Jun 27 12:44 passthru() 描述：执行外部程序并且显示原始输出 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。特点直接输出,原始输出 12$command='who';passthru($command); 12root tty1 Jun 25 14:46root pts/0 Jun 27 12:44 综上 要获取原始输出就用passthru 听说exec跟表单(grep查询的结果)更配哦 其他函数看着需求用就好 挖坑 起步完之后就会开始进入实践，就会遇到各种坑，准备好了吗？ 第一坑： disable_functions 解除PHP禁用函数 虽说这个默认设置不是坑，但是99%的服务器在你部署完php之后，disable_funcitons设置上都会禁用掉上面所用到函数，所以先去php.ini里面解除系统调用函数设置 vi /usr/local/php/etc/php.ini (我lnmp安装默认是这个路径的，php安装在其他地方的请自行调整) 打开配置文件后找到disable_functions(可以用vi在命令模式下/disable_functions来查找) 将你之后用到的系统调用函数删去(exec,system,passthru等等),如果不在此列则表示没有默认禁用该PHP函数 保存(Esc退出到命令模式然后:wq!退出)，如果权限不够不能写则自行加权限解决 重启PHP/LNMP (lnmp restart) 然后就可以愉快地使用系统调用函数了 第二坑： 补充错误日志 在你调试命令的时候，最烦的不是出错，最烦的是出错了但没有错误提示，因此不能对症下药，所以，不妨在你调试命令时，顺便输出到文本文件，然后去文本文件里面找错误输出。 123$command='ll / 2&gt;/xxxxxx/log.txt'; //将错误重定向到log.txtexec($command,$result); //命令输出内容存至result变量print_r($result); 建议命令里面涉及路径的全部都用上绝对路径，并且给日志文件给上权限(777简单粗暴) bash命令中的0代表标准输入，1代表标准输出，2代表标准错误输出 第三坑： 权限 在你补充完错误日志时，你会发现最多的错误就是有关于权限的，以及有关于sudoer的，因为当你浏览器发送一个请求给服务器的web应用时，web服务器(apache或者nginx)所用的用户(www)不具备root的一些权限，所以需要修改sudoer以及涉及到的文件权限(读写操作) visudo 直接编辑 (进入利用nano编辑器编辑sudoer) 如果发现文本中存在 defaults requiretty 的，则用#号注释掉如 #defaults requiretty apache用户的话一般系统会建立apache用户，nginx用户的话一般是www用户(可用vi /usr/local/nginx/conf/nginx.conf查看，第一行就是显示nginx所用的用户) 在visudo末尾中 添加 www ALL=NOPASSWD:ALL 或者 apache ALL=NOPASSWD:ALL(不同web服务器所用的用户不同) 然后ctrl+x 按Y保存退出nano 然后给你需要读写的文件加上对应权限，就可以用PHP系统调用进行文件读写等等需要权限的操作 第四坑： 调用Python脚本时import问题 就举我上面提到的例子，PHP调用机器学习的Python脚本，这个Python脚本中用到了刚编译好的caffe（非Python标准库），然后import caffe的时候，或许在shell运行没问题，但是在PHP调用Python的时候可能就会炸了。 例如会报 ImportError: No module named caffe 的错误 12345#修改前的 PHP调用时会报caffe模块缺失的错误import numpy as npimport sysimport osimport caffe 123456import numpy as npimport sysimport ossys.path.append(\"/（caffe-master路径）/caffe/python\") #根据自己实际的绝对路径修改sys.path.append(\"/（caffe-master路径）/caffe/python/caffe\")#根据自己实际的绝对路径修改import caffe 对于其他需要自行编译的模块，同理举一反三吧~ 第五坑： PHP默认开始安全模式 如果PHP默认开启了安全模式，只要去php.ini里面把safe_mode(如果存在)用#号注释掉即关闭 小结 对于其他错误的话，根据错误日志慢慢解决就好，还有更多的坑需要填呢~最后说一句，既然PHP调用Python这么麻烦，为什么不直接用Python开发呢？因为PHP是世界上最好的语言啊(误) ^_^ PHP系统调用官方文档","tags":[{"name":"PHP函数","slug":"PHP函数","permalink":"https://dawnki.github.io/tags/PHP函数/"},{"name":"系统调用","slug":"系统调用","permalink":"https://dawnki.github.io/tags/系统调用/"},{"name":"PHP调用Python脚本","slug":"PHP调用Python脚本","permalink":"https://dawnki.github.io/tags/PHP调用Python脚本/"}]},{"title":"PHP常用的几种魔术方法","date":"2017-06-03T08:05:11.000Z","path":"2017/06/03/php的魔术方法/","text":"补个档，重新复习下php的几种魔术方法,同时魔术方法也是必须掌握的，面试什么的也是必考的.附上php文档的相关警告:PHP 将所有以两个下划线开头的类方法保留为魔术方法。所以在定义类方法时，除了讲到的魔术方法，建议不要以两个下划线为前缀. 切记切记~~ 常用魔术方法__construct() 描述:类构造方法，在实例化类时自动调用 12345678class A &#123; function __construct() //参数列表可选 &#123; //..... &#125;&#125;$instance = new A(); //实例化时自动调用 __destruct() 描述:析构函数，在对象的所有引用被删除或者脚本执行结束时调用 12345678910class A &#123; function __destruct() //参数列表为空 &#123; //... &#125;&#125;$instance = new A();unset($instance); //此处调用析构函数 如果此行注释掉，脚本结束亦会调用 __toString() 描述:当类被当作字符串时，此方法返回字符串。返回值为string，无参数。 123456789101112class A&#123; function __toString() &#123; return \"I AM A\"; &#125;&#125;$instance = new A();echo $instance;print $instance; __get() 描述:当读取不可访问属性的调用，参数string值，返回值mixed 12345678910111213class A&#123; private $a = 1; function __get($name) //$name为要访问的属性名 &#123; if(isset($this-&gt;$name))&#123; return $this-&gt;$name; &#125; &#125;&#125;$instance = new A();echo $instance-&gt;a; //1 __set() 描述:当给不可访问的属性赋值时调用，参数1(属性名) string 参数2(赋值) mixed ，返回值为void 1234567891011121314151617181920class A&#123; private $a = 1; function __set($name,$value) &#123; if(isset($this-&gt;$name))&#123; $this-&gt;$name=$value; &#125; &#125; function __get($name)&#123; if(isset($this-&gt;$name))&#123; return $this-&gt;$name; &#125; &#125;&#125;$instance = new A();$instance-&gt;a = 3; //自动调用__set()echo $instance-&gt;a; //自动调用__get() __isset() 描述:对当不可访问的属性调用isset()或empty()时,__isset()会被自动调用，接受一个string 参数(被访问的属性名) 1234567891011class A&#123; private $a; function __isset($name) //被访问的属性名 &#123; echo $name.\"__isset is invoked\"; &#125;&#125;$instance = new A();isset($instance-&gt;a); // a__isset is invoked __unset() 描述:对当不可访问的属性调用unset()时,__unset()会被自动调用，接受一个string 参数(被访问的属性名) 1234567891011class A&#123; private $a; function __unset($name) //被访问的属性名 &#123; echo $name.\"__unset is invoked\"; &#125;&#125;$instance = new A();unset($instance-&gt;a); //a__unset is invoked __call() 描述:当对象调用一个不可访问的方法是，__call()会被自动调用，接受两个参数，第一个参数string(方法名)，第二个参数array(参数列表) 1234567891011121314151617class A&#123; private function inside($a,$b) &#123; echo $a.'_'.$b; &#125; function __call($name,$args) //方法名&amp;参数列表 &#123; echo 'funciton_name:'.$name.' parameter:'.implode(' , ',$args); &#125;&#125;$instance = new A();$instance-&gt;inside(1,2,3); //funciton_name:inside parameter:1 , 2 , 3 __callStatic() 描述:当对象调用一个不可访问的静态方法是，__callStatic()会被自动调用，接受两个参数，第一个参数string(方法名)，第二个参数array(参数列表)，修饰必须是可见的以及静态的 12345678910111213class A&#123; private static function inside($a,$b) &#123; echo $a.'_'.$b; &#125; public static function __callStatic($name,$args) //修饰必须是可见的以及静态的 &#123; echo 'static_funciton_name:'.$name.' parameter:'.implode(' , ',$args); &#125;&#125;A::inside(1,2,3); //static_funciton_name:inside parameter:1 , 2 , 3 __clone() 描述:当使用关键字clone对象是，__clone()方法会被自动调用. 作用:因为clone是浅克隆，当要复制的对象内部有一个引用属性时，并不会进行复制，而是照搬引用，所以此时需要在__clone方法中对某些引用属性进行深克隆 1234567891011121314151617181920212223242526class A&#123; public $obj ; //引用对象 public function __construct(B $ojb) &#123; $this-&gt;obj = $ojb; &#125; function __clone()&#123; $this-&gt;obj = clone $this-&gt;obj; //对应引用对象进行深克隆 &#125;&#125;class B&#123; public $content=\"abc\";&#125;$a = new A(new B());$b = clone $a;$a-&gt;obj-&gt;content = \"efg\"; //即使$a内部的引用对象改变了echo $b-&gt;obj-&gt;content; //$b内部的引用对象仍不变 为abc __sleep() 描述:serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 备注:__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 12345678910111213141516class A&#123; public $var1 = 1; public $var2 = 2; public $var3 = 3; public function __sleep() //返回应被序列化的变量名称的数组 &#123; return array('var1','var2'); //序列化时忽略序列化$var3 &#125;&#125;$instance = new A();echo serialize($instance); //O:1:\"A\":2:&#123;s:4:\"var1\";i:1;s:4:\"var2\";i:2;&#125; Notice:serialize()和unserialize()，是将php的值与字符串相互转化的方法(序列化与反序列化)，主要便于存储，同时也不丢失类型结构。 __wakeup() 描述:unserialize(反序列化)对象时，__wakeup()会被自动调用。 作用:经常用在反序列化操作(字符串还原成对象时)中，例如重新建立数据库连接，或执行其它初始化操作。 123456789101112131415161718192021222324252627class A&#123; public $var1 = 1; public $var2 = 2; public $var3 = 3; public function __sleep() &#123; return array('var1','var2'); &#125; function __wakeup() &#123; $this-&gt;var1 = 233; &#125;&#125;$instance = new A();$a=serialize($instance);echo $a; // O:1:\"A\":2:&#123;s:4:\"var1\";i:1;s:4:\"var2\";i:2;&#125; 可见var1的值为1$a=unserialize($a);echo $a-&gt;var1; //输出233 而不是 1 魔术方法实现重载属性重载 PHP所提供的”属性重载”是指动态地”创建”类属性 12345678910111213141516171819202122232425262728class A&#123; // 可重载的属性存放在data数组中 private $data = array(); // 此属性不能被重载 public $declared = 1; // 从类外部访问此属性时才发生重载 private $hidden = 2; // 利用__set动态创建 public function __set($name , $value) &#123; $this-&gt;data[$name] = $value; &#125; // 返回重载属性数组data public function getData() &#123; return $this-&gt;data; &#125;&#125;$instance = new A();$instance-&gt;a = 3; //a属性被动态添加print_r($instance-&gt;getData()); //Array ( [a] =&gt; 3 ) 方法重载 传统的”重载”是用于提供多个同名的类方法，但各方法的参数类型和个数不同。不过要实现相同的功能可以使用__call()魔术方法. 1234567891011121314151617181920212223242526272829class A&#123; function __call($name,$args) &#123; if($name == 'func') &#123; $args_num = count($args); $invoke_name=$name.$args_num; if(method_exists($this,$invoke_name))&#123; call_user_func_array(array($this,$invoke_name),$args); //参数1:回调方法 参数2:数组形式的参数列表 &#125; &#125; &#125; function func1($arg1) &#123; echo \"invoke func1:\".$arg1; &#125; function func2($arg1,$arg2) &#123; echo \"invoke func2:\".$arg1.','.$arg2; &#125;&#125;$instance = new A();$instance-&gt;func(1); //执行func1$instance-&gt;func(1,2); //执行func2 notice:call_user_func_array方法的第一个参数是callable类型，一个已实例化的 object 的方法被作为 array 传递，下标 0 包含该 object，下标 1 包含方法名。 在同一个类里可以访问 protected 和 private 方法。 参考资料PHP官方文档","tags":[{"name":"PHP魔术方法","slug":"PHP魔术方法","permalink":"https://dawnki.github.io/tags/PHP魔术方法/"},{"name":"重载","slug":"重载","permalink":"https://dawnki.github.io/tags/重载/"}]},{"title":"Ubuntu完全卸载mysql","date":"2017-05-10T04:45:44.000Z","path":"2017/05/10/删除mysql/","text":"我们安装了mysql之后想卸载mysql时，往往是卸载不完全，导致下次安装又有问题，下面就提供ubuntu完全卸载mysql的方法. 实验环境 Linux: Ubuntu 16:04 Mysql 5.7 步骤 温馨提示:执行之前务必确认是否备份了数据库的数据,数据无价! 先在shell里执行以下指令 12345sudo apt-get autoremove --purge mysql-server*sudo apt-get remove mysql-server*sudo apt-get autoremove mysql-server*sudo apt-get remove mysql-commonsudo rm -rf /etc/my.cnf 建一个shell脚本(文件)叫deleteMysql.sh,内容如下: 1234567#!/bin/bashlist=`sudo find / -name mysql*`for i in $list do sudo rm -rf $idoneexit 0 给这个脚本加上执行权限后执行 12sudo chmod u+x deleteMysql.shsudo ./deleteMysql.sh 小结这下子mysql应该算是完全卸载了，然后就可以跑路(误)了!!!∑(ﾟДﾟノ)ノ","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"},{"name":"ubunut","slug":"ubunut","permalink":"https://dawnki.github.io/tags/ubunut/"}]},{"title":"Laravel5.2消息队列实践","date":"2017-05-10T03:21:41.000Z","path":"2017/05/10/laravel-job/","text":"在后台开发中，很多情况需要用到队列来处理业务逻辑，前几天亲自实践了一下Laravel的队列功能，在此分享一蛤。 使用情景举几个使用到消息队列的栗子 在处理商城的库存问题，简单的实现是当用户的某件商品下单了，库存就相对应减少，但是当并发量一大时，比如A,B两个顾客同时下单，如果不使用队列可能会造成库存错误，使用队列了保证不同时执行两个减库存操作(一个阻塞掉了另外一个)。 当一个服务器要处理一个请求端发来的多组大量数据，而且每组数据处理起来的时间会很慢时，可以采取异步队列，就相当于请求端发过来的数据先存着，放进队列里，然后再异步处理数据(即处理数据的过程不在请求的生命周期里) 由于比如用户登陆了某网站之后，后台就过xx分钟给用户发延迟邮件来推送广告(怎么有点流氓(°Д°))，这里也可以用到异步队列，虽然可以用设计定时任务来轮询检查的笨方法，不过感觉用轮询来实现异步不是真正的异步 扯了这么多，刚回到正题了—实践 实验环境 Laravel 5.2 系统: Windows(wamp) or Linux(lnmp) 步骤 配置laravel提供了多种消息队列驱动: sync(同步) database beanstalkd sqs redis默认是sync，不过实际上其他几种异步队列多点，本章先用database练练手，前几天刚服务器刚配好redis，迟点再补上redis的吧~ so,先到 /.env (默认根目录为你的项目目录) 中 填上 QUEUE_DRIVER=database ,当然你也可以到/config/queue.php的default中将sync修改，但是建议修改.env 建表修改完队列驱动后，就用Laravel的migration自动生成队列需要的表，到根目录执行artisan 123php artisan queue:tablephp artisan queue:failed-table #处理出错队列用的表php artisan migrate 此时，数据库中就会出现jobs表和failed_jobs表 创建任务类并编写任务类执行artisan命令快速生成任务类并在/app/jobs/ 目录下面找到刚创建的任务 1php artisan make:job yourJobName 刚自动生成的任务类包含了两个初始方法 12345678910111213141516171819/** * Create a new job instance. * * @return void */public function __construct()&#123; //&#125;/** * Execute the job. * * @return void */public function handle()&#123; //&#125; 构造方法__construct用于你给任务类传值or对象用，至于handle方法则是队列任务的处理(即给排在队列里的任务如何执行业务逻辑) 这时就有个问题了，排在队列里的任务如果处理时失败了，或者因不符合某些业务逻辑需要进行统一的失败操作，那该怎么办呢？ 此时可以在这个任务类中添加一个failed方法 1234public function failed()&#123; //&#125; 这样laravel就可以识别得到，当一个任务在执行handle方法时，遇到异常了(Throw Exception)，laravel就会自动捕获异常并执行failed方法，并在failed_job表中记录信息。这个用来管控你看不见摸不着的异步队列任务比较有用，你可以根据业务逻辑在failed方法里将错误信息输出到自己的日志或者其他操作。 任务类里自带的几个有用方法通过artisan生成的任务类里，由于使用(use)了InteractsWithQueue这个trait，所以可以使用到里面有几个自带的方法 attempts 作用:返回任务的已经执行次数(eg.可以用于在handle方法中判断任务执行超过n次时就抛出异常来执行failed方法等等) 食用方法:在任务类的handle方法或者failed方法中,无参 1$this-&gt;attempts(); delete 作用:在队列中删除该任务(jobs表里删除) 食用方法:同上 1$this-&gt;delete(); release 作用:将当前任务再次放进队列中，可传入参数，来控制同一个任务两次运行之间的等待时间 食用方法:同上，不过有参，参数为int类型 表示多少秒 1$this-&gt;release(10); // 同一个任务两次运行之间隔10秒执行 目前任务类里比较常用的就是这几个方法了。 执行任务代码里要做的事编写好任务类之后，你可以在你的控制器里面创建任务，并且将它调度执行(dispatch) 12$job=new yourJobName($value); // 按实际情况来传值dispatch($job); 如果想设置延时 12$job=new yourJobName()-&gt;delay(10); // 延迟10秒执行dispatch($job); 如果想指定队列(分类) 12$job=new yourJobName()-&gt;onQueue('test'); //可以查看对应job表的queue字段dispatch($job); shell里要做的事当代码里做的事做好了之后，我们一个请求过去服务器的项目程序就能启动任务了吗？不能，因为之前我们说过，除了sync其他驱动都是异步的，而php是单线程的(意味着一个开启一个php脚本相当于开启一个进程，而这个进程里面只有一个线程)，所以我们一个请求只有一个线程，因此我们需要开多一个进程来进行队列监听了，当监听脚本监听到队列有动静时，就对队列进行处理。 1php artisan queue:listen 测试 开始监听 发送请求(可以用postman试试)到指定控制器来调度队列任务 观察正在执行监听任务的shell(ctrl+c 退出监听) 小结 通过实践，算是掌握了laravel的队列使用，下面就提一下我遇到的坑点以及改进吧~ 注意事(坑)项(点) 当你使用了onQueue方法来给任务分类然后调度时，监听的命令该怎么写？ 一开始我天真的认为一句 php artisan queue:listen 就能监听所有分类的任务，结果之后发现我定义的一个分类的任务一直不执行，看了文档又找不到缘故 12$job=new yourJobName()-&gt;onQueue('test'); //将一个任务归为test分类dispatch($job); 1php artisan queue:listen # 你会发现,是监听不了上面的的任务的 翻了一下帮助命令 1php artisan help queue:listen 可以看到 所以正确的执行姿势应该是 12php artisan queue:listen --queue test # 以我上面的例子而言 此处队列分类是testphp artisan queue:listen --QUEUE test # help里面说到大写也可以 还有其他queue的命令就自己发掘或者看文档吧~ 优化 为了保护监听进程(失败后重启等)，我们可以尝试用一下Supervisor(linux) 因为现在很多缓存都用redis，所以这个队列任务如果用redis的话，就可以一举两得了~~ 以上两点列入到Todo list中，有空再捣鼓一蛤!! 感谢感谢 Laravel学院 的中文文档 ！","tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://dawnki.github.io/tags/Laravel/"},{"name":"异步消息队列","slug":"异步消息队列","permalink":"https://dawnki.github.io/tags/异步消息队列/"}]},{"title":"Sublime Text 安装Package Controller","date":"2017-05-10T00:38:46.000Z","path":"2017/05/10/sublimetextPC/","text":"前言众所周知，sublime是一款很好用的文本编辑器，其好用之处在于其背后强大的插件功能，但是刚安装的sublime是不能直接安装插件的，需要先安装Package Controller 才能通过Package Controller来安装插件，下面就介绍如何安装Package Controller. 安装方法安装方法分为简单安装和手动安装,自行选择即可. 简单的安装方法使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码： Sublime Text 3 1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 如果顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了。 Sublime Text 2 的如下: 1import urllib2,os; pf=&apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), &apos;wb&apos; ).write( urllib2.urlopen( &apos;http://sublime.wbond.net/&apos; +pf.replace( &apos; &apos;,&apos;%20&apos; )).read()); print( &apos;Please restart Sublime Text to finish installation&apos;) 手动安装可能由于各种原因，无法使用代码安装，那可以通过以下步骤手动安装Package Control： 点击Preferences &gt; Browse Packages菜单 进入打开的目录的上层目录，然后再进入Installed Packages/目录 下载Package Control.sublime-package并复制到Installed Packages/目录 重启Sublime Text。 如何使用Package Controller 安装插件 快捷键ctrl+shift+P，或者直接在Preferences &gt; Package Controller 来打开 在输入框中输入 install package 按回车 在新弹出的框中输入你要安装的插件即可 效果如下图:","tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"https://dawnki.github.io/tags/Sublime-Text/"}]},{"title":"LNMP坑点系列:\"mysql.serviceJob for mysql.service failed because the control process exited with error code.\"","date":"2017-05-09T13:02:09.000Z","path":"2017/05/09/mysql-question/","text":"一天舍友在lnmp下，动了一下/etc/my.cnf文件之后,重启lnmp是出现了”mysql.serviceJob for mysql.service failed because the control process exited with error code.”的问题。 寻找元凶经过几番询问后，发现原来舍友为了更改mysql密码动了一下/etc/my.cnf文件. 锁定/etc/my.cnf文件！！ 可以看到这个文件的初始权限是拥有者有读写功能，但同组或者其他人只有读的功能，由于舍友为了修改这个文件，帮这个文件加了所有身份都加了写的功能。 即：1sudo chmod go+w /etc/my.cnf 接着重启就炸了 1sudo lnmp restart 解决办法要解决很简单，只将这个文件的权限还原即可(只保留拥有者有写功能) 1sudo chmod go-w /etc/my.cnf 如图修改完之后，大功告成!lnmp能正常重启了! 小结这个坑告诉我们一定要有做事要有头有尾，文件由于一时特殊需要改了权限的，之后完事后记得改回权限!!","tags":[{"name":"mysql","slug":"mysql","permalink":"https://dawnki.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"https://dawnki.github.io/tags/linux/"}]},{"title":"Hello World","date":"2017-05-09T10:51:21.767Z","path":"2017/05/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]